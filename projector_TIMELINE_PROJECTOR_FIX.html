<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Panasonic PT-RQ25K - Professional Shadow-Mapped Projection Shader</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
        }
        #container { width: 100vw; height: 100vh; }

        /* Top Menu Bar */
        #top-menu {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: rgba(0,0,0,0.95);
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            padding: 0 10px;
            z-index: 500;
            gap: 4px;
        }
        .menu-item {
            position: relative;
            padding: 8px 14px;
            cursor: pointer;
            font-size: 12px;
            border-radius: 4px;
            transition: background 0.2s;
        }
        .menu-item:hover {
            background: #333;
        }
        .menu-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: rgba(20,20,20,0.98);
            border: 1px solid #444;
            border-radius: 6px;
            min-width: 220px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.6);
            z-index: 1000;
            padding: 6px 0;
        }
        .menu-item:hover .menu-dropdown {
            display: block;
        }
        .dropdown-item {
            padding: 10px 16px;
            cursor: pointer;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: background 0.15s;
        }
        .dropdown-item:hover {
            background: #0d9488;
        }
        .dropdown-item.has-submenu {
            position: relative;
        }
        .dropdown-item.has-submenu::after {
            content: '‚ñ∏';
            margin-left: auto;
            font-size: 10px;
            opacity: 0.6;
        }
        .submenu {
            display: none;
            position: absolute;
            left: 100%;
            top: -6px;
            background: rgba(20,20,20,0.98);
            border: 1px solid #444;
            border-radius: 6px;
            min-width: 280px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.6);
            padding: 6px 0;
            max-height: 400px;
            overflow-y: auto;
        }
        .dropdown-item.has-submenu:hover .submenu {
            display: block;
        }
        .submenu-header {
            padding: 6px 16px;
            font-size: 9px;
            color: #0d9488;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #333;
            margin-bottom: 4px;
        }
        .projector-item {
            padding: 10px 16px;
            cursor: pointer;
            font-size: 11px;
            transition: background 0.15s;
        }
        .projector-item:hover {
            background: #0d9488;
        }
        .projector-item .model-name {
            font-weight: 600;
            margin-bottom: 2px;
        }
        .projector-item .model-specs {
            font-size: 9px;
            color: #aaa;
        }
        .projector-item:hover .model-specs {
            color: #ccc;
        }
        .dropdown-divider {
            height: 1px;
            background: #333;
            margin: 4px 0;
        }
        .menu-logo {
            font-weight: bold;
            color: #0d9488;
            font-size: 13px;
            padding: 0 12px;
            border-right: 1px solid #333;
            margin-right: 6px;
        }
        
        /* Undo/Redo Buttons */
        .history-buttons {
            display: flex;
            gap: 2px;
            margin-right: 8px;
            padding-right: 8px;
            border-right: 1px solid #333;
        }
        .history-btn {
            width: 32px;
            height: 28px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #888;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: all 0.15s;
        }
        .history-btn:hover:not(:disabled) {
            background: #333;
            border-color: #0d9488;
            color: #fff;
        }
        .history-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        .history-btn:active:not(:disabled) {
            background: #0d9488;
        }

        #controls { position: absolute; top: 60px; right: 20px; background: rgba(0,0,0,0.95); padding:15px; border-radius:8px; width:300px; max-height:calc(90vh - 60px); overflow-y:auto; font-size:11px; }
        .control-group { margin-bottom:12px; padding-bottom:10px; border-bottom:1px solid #333; }
        .control-group h3 { font-size:10px; margin-bottom:8px; color:#0d9488; text-transform:uppercase; }
        .control-row { margin-bottom:8px; }
        label { display:block; font-size:10px; margin-bottom:3px; color:#aaa; }
        input[type="range"] { width:100%; height:3px; background:#333; border-radius:2px; outline:none; }
        input[type="range"]::-webkit-slider-thumb { appearance:none; width:10px; height:10px; border-radius:50%; background:#0d9488; cursor:pointer; }
        input[type="number"], select, input[type="file"] { width:100%; padding:5px; background:#2a2a2a; border:1px solid #444; color:white; border-radius:3px; font-size:11px; }
        button { width:100%; padding:6px; background:#0d9488; color:white; border:none; border-radius:3px; cursor:pointer; font-size:10px; margin-top:4px; }
        button.secondary { background:#444; }
        button.danger { background:#dc2626; }
        .value-display { color:#0d9488; font-weight:600; margin-left:5px; }
        .checkbox-row { display:flex; align-items:center; gap:6px; margin:5px 0; }
        .throw-display { background: linear-gradient(135deg,#0d9488 0%,#065f46 100%); padding:8px; border-radius:5px; text-align:center; margin-bottom:10px; }
        .throw-display .label { font-size:8px; color:rgba(255,255,255,0.7); }
        .throw-display .value { font-size:18px; font-weight:700; }
        .throw-display .sub { font-size:9px; color:rgba(255,255,255,0.6); }
        .measurement-group { display:grid; grid-template-columns:1fr 1fr; gap:6px; }
        .measurement-input { background:#1a1a1a; padding:6px; border-radius:3px; text-align:center; }
        .lens-specs { background:#1a1a1a; padding:5px; border-radius:3px; margin-top:5px; font-size:9px; }
        .lens-specs .spec-row { display:flex; justify-content:space-between; padding:2px 0; }
        .lens-specs .spec-value { color:#0d9488; }
        .projector-model { background: linear-gradient(135deg,#1e3a5f 0%,#0d1b2a 100%); padding:8px; border-radius:5px; margin-bottom:10px; border:1px solid #2a4a6f; }
        .snap-selector { width:60px; height:60px; background:#1a1a1a; border:1px solid #444; border-radius:4px; position:relative; padding:6px; }
        .snap-btn { width:12px; height:12px; border-radius:50%; border:none; cursor:pointer; background:#444; position:absolute; transition: all 0.2s; }
        .snap-btn:hover { background:#0d9488; transform: scale(1.2); }
        .snap-btn.active { background:#0d9488; box-shadow: 0 0 6px #0d9488; }
        .snap-btn[data-snap="tl"] { top:6px; left:6px; }
        .snap-btn[data-snap="tr"] { top:6px; right:6px; }
        .snap-btn[data-snap="c"] { top:50%; left:50%; transform:translate(-50%,-50%); }
        .snap-btn[data-snap="bl"] { bottom:6px; left:6px; }
        .snap-btn[data-snap="br"] { bottom:6px; right:6px; }
        .snap-btn.active[data-snap="c"] { transform:translate(-50%,-50%) scale(1.1); }
        .object-snap-points { display:none; margin-top:8px; padding:8px; background:#1a1a1a; border-radius:4px; }
        .object-snap-points.visible { display:block; }
        .snap-point-btn { padding:4px 8px; background:#2a2a2a; border:1px solid #444; color:#ccc; border-radius:3px; cursor:pointer; font-size:9px; margin:2px; }
        .snap-point-btn:hover { background:#0d9488; border-color:#0d9488; }
        .snap-point-btn.active { background:#0d9488; border-color:#0d9488; }
        .status { padding:4px; border-radius:3px; font-size:9px; margin-top:4px; }
        .status.success { background:rgba(13,148,136,0.2); color:#0d9488; }
        .status.info { background:rgba(59,130,246,0.2); color:#3b82f6; }

        /* 3D Model Loader Modal */
        .model-modal { display:none; position:fixed; z-index:2000; left:0; top:0; width:100%; height:100%; background-color:rgba(0,0,0,0.85); backdrop-filter:blur(4px); }
        .model-modal.show { display:flex; align-items:center; justify-content:center; }
        .model-modal-content { background:#252526; border-radius:8px; width:95%; max-width:1100px; max-height:90vh; overflow:hidden; box-shadow:0 8px 32px rgba(0,0,0,.5); display:flex; flex-direction:column; border:1px solid #0d9488; }
        .model-modal-header { padding:12px 16px; background:#1a1a1a; border-bottom:1px solid #333; display:flex; justify-content:space-between; align-items:center; }
        .model-modal-title { font-size:14px; font-weight:600; color:#0d9488; }
        .model-modal-close { background:none; border:none; color:#999; font-size:20px; cursor:pointer; width:28px; height:28px; display:flex; align-items:center; justify-content:center; border-radius:4px; transition:all .2s; }
        .model-modal-close:hover { background:#3e3e3e; color:#fff; }
        .model-modal-body { padding:16px; overflow-y:auto; flex:1; display:flex; gap:16px; }
        .model-modal-viewport { flex:1; position:relative; background:#1a1a1a; border-radius:4px; overflow:hidden; min-height:400px; border:1px solid #333; }
        .model-modal-controls { width:300px; display:flex; flex-direction:column; gap:12px; }
        .model-modal-footer { padding:12px 16px; background:#1a1a1a; border-top:1px solid #333; display:flex; justify-content:flex-end; gap:10px; }
        .model-modal-footer button { padding:8px 16px; border-radius:4px; cursor:pointer; font-size:11px; }
        .modal-section { background:#1e1e1e; border-radius:4px; padding:10px; }
        .modal-section-title { font-size:10px; font-weight:600; text-transform:uppercase; color:#0d9488; margin-bottom:8px; letter-spacing:0.5px; }
        .axis-option { background:#2d2d2d; border:1px solid #3a3a3a; border-radius:4px; padding:8px; cursor:pointer; transition:all .2s; margin-bottom:6px; }
        .axis-option:hover { border-color:#0d9488; background:#333; }
        .axis-option.selected { border-color:#0d9488; background:#094771; }
        .axis-option-title { font-size:11px; font-weight:600; margin-bottom:2px; }
        .axis-option-desc { font-size:9px; color:#888; }
        .pivot-btn { width:100%; background:#2d2d2d; border:1px solid #3a3a3a; color:#ccc; padding:8px; border-radius:4px; cursor:pointer; text-align:center; font-size:10px; transition:all .2s; margin-bottom:4px; }
        .pivot-btn:hover { background:#3a3a3a; border-color:#0d9488; }
        .pivot-btn.active { background:#0d9488; border-color:#0d9488; color:white; }
        .rotate-controls { display:flex; gap:4px; margin-top:6px; }
        .rotate-controls button { flex:1; padding:6px; font-size:9px; background:#2d2d2d; border:1px solid #3a3a3a; color:#ccc; border-radius:3px; cursor:pointer; }
        .rotate-controls button:hover { background:#0d9488; border-color:#0d9488; color:white; }
        .upload-zone { background:#2d2d2d; border:2px dashed #3a3a3a; border-radius:6px; padding:20px; text-align:center; cursor:pointer; transition:all .2s; }
        .upload-zone:hover { border-color:#0d9488; background:#333; }
        .upload-zone-icon { font-size:28px; margin-bottom:6px; }
        .upload-zone-text { font-size:11px; color:#999; margin-bottom:4px; }
        .upload-zone-formats { font-size:9px; color:#666; }
        .keyboard-hint { background:#2a2a2a; padding:4px; border-radius:3px; font-size:8px; color:#888; margin-top:5px; }
        .shader-quality-badge {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 8px;
            text-align: center;
            margin-bottom: 8px;
            font-weight: bold;
        }

        /* Floating Window Base Style */
        .floating-window {
            position: absolute;
            background: rgba(0,0,0,0.95);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #0d9488;
            display: none;
            z-index: 100;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            cursor: move;
        }
        .floating-window.visible { display: block; }
        .floating-window-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #333;
        }
        .floating-window-header h3 {
            font-size: 11px;
            color: #0d9488;
            margin: 0;
            text-transform: uppercase;
        }
        .floating-window-close {
            background: none;
            border: none;
            color: #888;
            font-size: 16px;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
        }
        .floating-window-close:hover {
            background: #333;
            color: #fff;
        }

        /* Transform Parameters Panel */
        #transform-params {
            bottom: 20px;
            left: 20px;
            width: 320px;
        }
        .param-section {
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }
        .param-section:last-child { border-bottom: none; }
        .param-section-title {
            font-size: 9px;
            color: #888;
            margin-bottom: 6px;
            text-transform: uppercase;
        }
        .param-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 4px;
            margin-bottom: 4px;
        }
        .param-input {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .param-input label {
            font-size: 8px;
            margin-bottom: 2px;
            color: #aaa;
        }
        .param-input input {
            width: 100%;
            text-align: center;
            padding: 4px;
            font-size: 10px;
        }

        /* Keystone Window */
        #keystone-window {
            top: 100px;
            right: 340px;
            width: 280px;
        }

        /* Soft Edge Window */
        #softedge-window {
            top: 100px;
            right: 340px;
            width: 280px;
        }

        /* Scene Parameters Window */
        #scene-params-window {
            top: 100px;
            left: 340px;
            width: 300px;
        }

        /* Photometric Window */
        #photometric-window {
            top: 200px;
            left: 340px;
            width: 320px;
        }

        /* Export Window */
        #export-window {
            top: 150px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
        }

        /* Brand Tabs */
        .brand-tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 12px;
            border-bottom: 1px solid #333;
            padding-bottom: 8px;
        }
        .brand-tab {
            padding: 8px 12px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px 4px 0 0;
            color: #aaa;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.2s;
        }
        .brand-tab:hover { background: #333; border-color: #0d9488; }
        .brand-tab.active { background: #0d9488; border-color: #0d9488; color: white; }
        .brand-grid { display: none; }
        .brand-grid.active { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 12px; }

        /* Photometric Analysis */
        .photometric-result {
            background: #1a1a1a;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
        }
        .photometric-value {
            font-size: 24px;
            font-weight: bold;
            color: #0d9488;
        }
        .photometric-label {
            font-size: 9px;
            color: #888;
            text-transform: uppercase;
        }
        .photometric-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        /* Gizmo Mode Controls */
        #gizmo-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.95);
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #0d9488;
            display: none;
        }
        #gizmo-controls.visible { display: block; }
        #gizmo-controls .title {
            font-size: 9px;
            color: #888;
            margin-bottom: 8px;
            text-transform: uppercase;
            text-align: center;
        }
        .gizmo-mode-buttons {
            display: flex;
            gap: 6px;
        }
        .gizmo-mode-btn {
            flex: 1;
            padding: 8px;
            background: #2a2a2a;
            border: 1px solid #444;
            color: #aaa;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            text-align: center;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        .gizmo-mode-btn:hover {
            background: #333;
            border-color: #0d9488;
        }
        .gizmo-mode-btn.active {
            background: #0d9488;
            border-color: #0d9488;
            color: white;
        }
        .gizmo-mode-btn .icon {
            font-size: 16px;
        }
        .gizmo-mode-btn .label {
            font-size: 8px;
            text-transform: uppercase;
        }
        .gizmo-mode-btn .key {
            font-size: 7px;
            opacity: 0.6;
        }

        /* Popup Menu for Primitives */
        #primitive-popup, #projector-popup {
            position: fixed;
            background: rgba(0,0,0,0.98);
            border: 2px solid #0d9488;
            border-radius: 8px;
            padding: 8px;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        #primitive-popup.visible, #projector-popup.visible { display: block; }
        .popup-item {
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 11px;
            transition: all 0.2s;
            white-space: nowrap;
        }
        .popup-item:hover {
            background: #0d9488;
        }
        .popup-icon {
            font-size: 18px;
            width: 24px;
            text-align: center;
        }
        .popup-divider {
            height: 1px;
            background: #333;
            margin: 4px 0;
        }
        
        /* Projector Creation Modal */
        #projector-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.85);
            backdrop-filter: blur(4px);
        }
        #projector-modal.show { display: flex; align-items: center; justify-content: center; }
        .projector-modal-content {
            background: #252526;
            border-radius: 8px;
            width: 95%;
            max-width: 600px;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0,0,0,.5);
            display: flex;
            flex-direction: column;
            border: 1px solid #0d9488;
        }
        .projector-modal-header {
            padding: 12px 16px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .projector-modal-title {
            font-size: 14px;
            font-weight: 600;
            color: #0d9488;
        }
        .projector-modal-close {
            background: none;
            border: none;
            color: #999;
            font-size: 20px;
            cursor: pointer;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all .2s;
        }
        .projector-modal-close:hover { background: #3e3e3e; color: #fff; }
        .projector-modal-body {
            padding: 16px;
            overflow-y: auto;
            flex: 1;
        }
        .projector-modal-footer {
            padding: 12px 16px;
            background: #1a1a1a;
            border-top: 1px solid #333;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        .projector-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 12px;
            margin-bottom: 16px;
        }
        .projector-card {
            background: #1e1e1e;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .projector-card:hover {
            border-color: #0d9488;
            background: #252525;
        }
        .projector-card.selected {
            border-color: #0d9488;
            background: #094771;
        }
        .projector-card-name {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 4px;
            color: #fff;
        }
        .projector-card-specs {
            font-size: 10px;
            color: #888;
        }
        .projector-card-icon {
            font-size: 24px;
            margin-bottom: 8px;
        }
        .projector-section-title {
            font-size: 10px;
            color: #0d9488;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
            padding-bottom: 4px;
            border-bottom: 1px solid #333;
        }
        .lens-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 8px;
        }
        .lens-option {
            background: #1e1e1e;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 8px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.2s;
        }
        .lens-option:hover { border-color: #0d9488; }
        .lens-option.selected { border-color: #0d9488; background: #094771; }
        .lens-option-name { font-weight: 600; margin-bottom: 2px; }
        .lens-option-throw { color: #888; }

        /* Add Primitive Button */
        .add-primitive-btn {
            background: linear-gradient(135deg, #0d9488 0%, #065f46 100%);
            padding: 10px;
            text-align: center;
            font-weight: bold;
            font-size: 11px;
            cursor: pointer;
            border-radius: 4px;
            margin-top: 8px;
            transition: all 0.2s;
        }
        .add-primitive-btn:hover {
            background: linear-gradient(135deg, #0f9d96 0%, #076e52 100%);
            transform: translateY(-1px);
        }

        /* Floating Window Toggle Buttons */
        .floating-toggle-btn {
            width: 100%;
            padding: 8px;
            background: #2a2a2a;
            border: 1px solid #444;
            color: #ccc;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            text-align: center;
            transition: all 0.2s;
            margin-bottom: 4px;
        }
        .floating-toggle-btn:hover {
            background: #333;
            border-color: #0d9488;
        }
        .floating-toggle-btn.active {
            background: #0d9488;
            border-color: #0d9488;
            color: white;
        }


        /* Controls Panel Visibility */
        #controls.hidden {
            display: none;
        }

        /* No Projector Message */
        #no-projector-msg {
            position: absolute;
            top: 60px;
            right: 20px;
            background: rgba(0,0,0,0.95);
            padding: 20px;
            border-radius: 8px;
            width: 300px;
            text-align: center;
            border: 1px solid #333;
        }
        #no-projector-msg h4 {
            color: #0d9488;
            margin-bottom: 10px;
        }
        #no-projector-msg p {
            color: #888;
            font-size: 11px;
            margin-bottom: 15px;
        }

        /* Calculateur Modal */
        #widescreen-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.85);
            backdrop-filter: blur(4px);
        }
        #widescreen-modal.show { display: flex; align-items: center; justify-content: center; }
        .widescreen-modal-content {
            background: #252526;
            border-radius: 8px;
            width: 95%;
            max-width: 700px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0,0,0,.5);
            display: flex;
            flex-direction: column;
            border: 1px solid #0d9488;
        }
        .widescreen-modal-header {
            padding: 12px 16px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .widescreen-modal-title {
            font-size: 14px;
            font-weight: 600;
            color: #0d9488;
        }
        .widescreen-modal-body {
            padding: 16px;
            overflow-y: auto;
            flex: 1;
        }
        .ws-section {
            background: #1e1e1e;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
        }
        .ws-section-title {
            font-size: 10px;
            color: #0d9488;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
            text-align: center;
            padding-bottom: 6px;
            border-bottom: 1px solid #333;
        }
        .ws-toggle-group {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 10px;
        }
        .ws-toggle-btn {
            padding: 8px 16px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 20px;
            color: #aaa;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.2s;
        }
        .ws-toggle-btn:hover { background: #333; }
        .ws-toggle-btn.active { background: #0d9488; border-color: #0d9488; color: white; }
        .ws-layout-options {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .ws-layout-card {
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
            min-width: 100px;
        }
        .ws-layout-card:hover { border-color: #0d9488; }
        .ws-layout-card.selected { border-color: #0d9488; background: #094771; }
        .ws-layout-icon { font-size: 32px; margin-bottom: 6px; }
        .ws-layout-label { font-size: 10px; color: #ccc; }
        .ws-input-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        .ws-input-group {
            text-align: center;
        }
        .ws-input-group label {
            display: block;
            font-size: 9px;
            color: #888;
            margin-bottom: 4px;
        }
        .ws-input-group input, .ws-input-group select {
            width: 100%;
            padding: 8px;
            background: #2a2a2a;
            border: 1px solid #444;
            color: white;
            border-radius: 4px;
            font-size: 12px;
            text-align: center;
        }
        .ws-input-group input:focus {
            border-color: #0d9488;
            outline: none;
        }
        .ws-result-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        .ws-result-box {
            background: #1a1a1a;
            padding: 12px;
            border-radius: 6px;
            border-left: 3px solid #0d9488;
        }
        .ws-result-box h4 {
            font-size: 9px;
            color: #0d9488;
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        .ws-result-row {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            padding: 3px 0;
        }
        .ws-result-row .label { color: #888; }
        .ws-result-row .value { color: #fff; font-weight: 600; }
        .widescreen-modal-footer {
            padding: 12px 16px;
            background: #1a1a1a;
            border-top: 1px solid #333;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        
        /* Calculateur Mode Selection Modal */
        #widescreen-mode-modal {
            display: none;
            position: fixed;
            z-index: 2100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.9);
            backdrop-filter: blur(6px);
        }
        #widescreen-mode-modal.show { display: flex; align-items: center; justify-content: center; }
        .ws-mode-cards {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-top: 16px;
        }
        .ws-mode-card {
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s;
        }
        .ws-mode-card:hover {
            border-color: #0d9488;
            background: #252525;
            transform: translateY(-4px);
        }
        .ws-mode-card.selected {
            border-color: #0d9488;
            background: #094771;
            box-shadow: 0 0 20px rgba(13, 148, 136, 0.3);
        }
        .ws-mode-icon { font-size: 48px; margin-bottom: 12px; }
        .ws-mode-label { font-size: 16px; font-weight: bold; color: #fff; margin-bottom: 6px; }
        .ws-mode-desc { font-size: 10px; color: #888; margin-bottom: 12px; }
        .ws-mode-preview {
            margin-top: 10px;
        }
        .ws-preview-box {
            display: flex;
            gap: 3px;
            justify-content: center;
            align-items: center;
            padding: 8px;
            background: #2a2a2a;
            border-radius: 4px;
        }
        .ws-preview-box.landscape {
            flex-direction: row;
        }
        .ws-preview-box.portrait {
            flex-direction: column;
        }
        .ws-preview-box.square {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 3px;
            width: fit-content;
            margin: 0 auto;
        }
        .ws-preview-box span {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 18px;
            background: #0d9488;
            border-radius: 2px;
            font-size: 9px;
            color: #fff;
            font-weight: bold;
        }
        .ws-preview-box.portrait span {
            width: 18px;
            height: 24px;
        }
        .ws-preview-box.square span {
            width: 22px;
            height: 22px;
        }
        
        /* Blueprint Modal */
        #blueprint-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.85);
            backdrop-filter: blur(4px);
        }
        #blueprint-modal.show { display: flex; align-items: center; justify-content: center; }
        .blueprint-content {
            background: #fff;
            width: 95%;
            max-width: 1200px;
            max-height: 90vh;
            overflow: auto;
            border-radius: 8px;
        }
        .blueprint-canvas {
            width: 100%;
            height: auto;
            background: #fff;
        }
        .blueprint-header {
            padding: 12px 16px;
            background: #1a1a1a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .blueprint-header h2 { color: #0d9488; font-size: 14px; margin: 0; }
        
        /* Test Pattern Modal */
        #testpattern-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.85);
            backdrop-filter: blur(4px);
        }
        #testpattern-modal.show { display: flex; align-items: center; justify-content: center; }
        .testpattern-content {
            background: #252526;
            border-radius: 8px;
            width: 95%;
            max-width: 1000px;
            max-height: 90vh;
            overflow: hidden;
            border: 1px solid #0d9488;
        }
        .testpattern-preview {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 12px;
            padding: 16px;
            background: #1a1a1a;
            max-height: 65vh;
            overflow-y: auto;
        }
        .testpattern-preview > div[style*="grid-column: 1/-1"] {
            grid-column: 1 / -1;
        }
        .pattern-card {
            background: #000;
            border: 2px solid #333;
            border-radius: 6px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s;
        }
        .pattern-card:hover { border-color: #0d9488; }
        .pattern-card canvas { width: 100%; height: auto; }
        .pattern-card-label {
            padding: 8px;
            text-align: center;
            font-size: 10px;
            color: #888;
            background: #1e1e1e;
        }
        
        /* ========== NEW MODERN INTERFACE CSS ========== */
        
        /* New Top Bar */
        #modern-top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 56px;
            background: rgba(15, 15, 15, 0.95);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 20px;
            z-index: 1000;
        }
        
        .modern-logo {
            font-size: 18px;
            font-weight: 700;
            color: #0d9488;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .modern-logo-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #0d9488, #14b8a6);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        
        .nav-tabs {
            display: flex;
            gap: 4px;
            margin-left: auto;
        }
        
        .nav-tab {
            padding: 8px 16px;
            background: transparent;
            border: none;
            color: #888;
            cursor: pointer;
            border-radius: 6px;
            font-size: 13px;
            transition: all 0.2s;
            font-family: inherit;
        }
        
        .nav-tab:hover {
            background: rgba(255, 255, 255, 0.05);
            color: #e0e0e0;
        }
        
        .nav-tab.active {
            background: rgba(13, 148, 136, 0.15);
            color: #0d9488;
        }
        
        .action-buttons {
            display: flex;
            gap: 8px;
            margin-left: 20px;
        }
        
        .btn-modern {
            padding: 8px 16px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
            font-family: inherit;
        }
        
        .btn-modern-primary {
            background: #0d9488;
            color: white;
        }
        
        .btn-modern-primary:hover {
            background: #0f9d8f;
            transform: translateY(-1px);
        }
        
        .btn-modern-secondary {
            background: rgba(255, 255, 255, 0.05);
            color: #e0e0e0;
        }
        
        .btn-modern-secondary:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        /* 3-Column Layout */
        .modern-container {
            display: flex !important;
            height: calc(100vh - 56px);
            margin-top: 56px;
            width: 100%;
            max-width: 100vw;
            position: relative;
            overflow-x: hidden;
            overflow-y: visible;
        }
        
        /* Left Sidebar */
        .modern-sidebar-left {
            width: 320px;
            min-width: 320px;
            max-width: 320px;
            flex-shrink: 0;
            background: rgba(15, 15, 15, 0.95);
            backdrop-filter: blur(20px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        .sidebar-header {
            padding: 16px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            position: sticky;
            top: 0;
            background: rgba(15, 15, 15, 0.98);
            z-index: 10;
        }
        
        .search-box {
            position: relative;
        }
        
        .search-box input {
            width: 100%;
            padding: 10px 12px 10px 36px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #e0e0e0;
            font-size: 13px;
            font-family: inherit;
        }
        
        .search-box input:focus {
            outline: none;
            border-color: #0d9488;
        }
        
        .search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #888;
        }
        
        /* Collapsible Panels */
        .collapsible-panel {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .panel-header {
            padding: 16px 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: all 0.2s;
            user-select: none;
            background: rgba(13, 148, 136, 0.05);
            border-left: 3px solid #0d9488;
        }
        
        .panel-header:hover {
            background: rgba(13, 148, 136, 0.1);
        }
        
        .panel-title {
            font-size: 13px;
            font-weight: 600;
            color: #e0e0e0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .panel-icon {
            font-size: 16px;
        }
        
        .panel-count {
            color: #0d9488;
            font-size: 11px;
            margin-left: 4px;
        }
        
        .panel-chevron {
            font-size: 12px;
            color: #888;
            transition: transform 0.3s ease;
        }
        
        .collapsible-panel.collapsed .panel-chevron {
            transform: rotate(-90deg);
        }
        
        .panel-content {
            max-height: 2000px;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
            padding: 0 20px 20px;
        }
        
        .collapsible-panel.collapsed .panel-content {
            max-height: 0;
            padding: 0 20px;
        }
        
        /* Center Viewport */
        .modern-viewport {
            flex: 1;
            max-width: calc(100vw - 600px); /* Force space for sidebars (320px + 280px) */
            position: relative;
            background: #000;
        }
        
        /* Right Panel (Properties) */
        .modern-sidebar-right {
            width: 280px;
            min-width: 280px;
            flex-shrink: 0;
            background: rgba(15, 15, 15, 0.95);
            backdrop-filter: blur(20px);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            overflow-y: auto;
            padding: 20px;
        }
        
        .properties-header {
            font-size: 13px;
            font-weight: 600;
            color: #e0e0e0;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .property-item {
            margin-bottom: 16px;
        }
        
        /* Scene Hierarchy C4D Style - COMPLETE */
        #scene-hierarchy {
            background: #0a0a0a;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .hierarchy-header {
            display: grid;
            grid-template-columns: 1fr 24px 24px;
            padding: 6px 8px;
            background: rgba(13, 148, 136, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 10px;
            color: #888;
            font-weight: 600;
        }
        
        .hierarchy-header-name {
            padding-left: 4px;
        }
        
        .hierarchy-item {
            display: grid;
            grid-template-columns: 1fr 24px 24px;
            align-items: center;
            padding: 6px 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
            cursor: pointer;
            transition: background 0.2s;
            user-select: none;
        }
        
        .hierarchy-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .hierarchy-item.selected {
            background: rgba(13, 148, 136, 0.2);
            border-left: 3px solid #0d9488;
        }
        
        .hierarchy-item.child {
            padding-left: 28px; /* Indentation for children */
        }
        
        .hierarchy-item-name {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            color: #e0e0e0;
            overflow: hidden;
        }
        
        .hierarchy-item-icon {
            font-size: 14px;
            flex-shrink: 0;
        }
        
        .hierarchy-item-text {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .hierarchy-btn {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 3px;
            font-size: 12px;
            transition: all 0.2s;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .hierarchy-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        .hierarchy-btn.active {
            background: rgba(13, 148, 136, 0.3);
            border-color: #0d9488;
            color: #0d9488;
        }
        
        .hierarchy-btn.solo-active {
            background: rgba(255, 193, 7, 0.3);
            border-color: #ffc107;
            color: #ffc107;
        }
        
        .hierarchy-btn.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        /* Context Menu */
        #context-menu {
            position: fixed;
            background: rgba(20, 20, 20, 0.98);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 8px 0;
            min-width: 180px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
            z-index: 10000;
            display: none;
        }
        
        .context-menu-item {
            padding: 10px 16px;
            cursor: pointer;
            font-size: 12px;
            color: #e0e0e0;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: background 0.2s;
        }
        
        .context-menu-item:hover {
            background: rgba(13, 148, 136, 0.2);
            color: #0d9488;
        }
        
        .context-menu-item .icon {
            width: 16px;
            text-align: center;
        }
        
        .property-label {
            font-size: 11px;
            color: #888;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .property-value {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            font-size: 13px;
            color: #e0e0e0;
        }
        
        /* Hide old top menu when modern interface active */
        body.modern-interface #top-menu {
            display: none;
        }
        
        body.modern-interface #gizmo-controls {
            top: 56px; /* Adjust for new top bar */
        }
        
        body.modern-interface #container {
            display: none; /* Canvas will be in viewport */
        }
        
        /* Hide old controls sidebar in modern interface */
        body.modern-interface #controls {
            display: none !important;
        }
        
        /* Hide old gizmo controls in modern interface */
        body.modern-interface #gizmo-controls {
            display: none !important;
        }
        
        /* Timeline Keyframe Markers */
        .timeline-keyframe-marker {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background: #0d9488;
            border: 2px solid #0a0a0a;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .timeline-keyframe-marker:hover {
            transform: translate(-50%, -50%) scale(1.5);
            background: #14b8a6;
        }
        
    </style>
</head>
<body class="modern-interface">
    
    <!-- MODERN TOP BAR -->
    <div id="modern-top-bar">
        <div class="modern-logo">
            <div class="modern-logo-icon">üéØ</div>
            <span>Projector Simulator</span>
        </div>
        
        <!-- Calculator Button (avant tabs) -->
        <button class="btn-modern btn-modern-secondary" onclick="openWidescreenCalculator()" style="margin-right: 20px; font-size: 11px;">
            üßÆ Calc
        </button>
        
        <div class="nav-tabs">
            <button class="nav-tab active" onclick="switchTab('setup')">Setup</button>
            <button class="nav-tab" onclick="switchTab('calibration')">Calibration</button>
            <button class="nav-tab" onclick="switchTab('export')">Export</button>
        </div>
        
        <!-- Camera Views Dropdown -->
        <div style="margin-left: 20px;">
            <select onchange="setCameraView(this.value); this.selectedIndex=0;" style="padding: 6px 12px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #888; cursor: pointer; font-size: 11px; font-weight: 600;">
                <option value="" disabled selected>üé• Camera Views</option>
                <option value="top">‚¨ÜÔ∏è Top</option>
                <option value="bottom">‚¨áÔ∏è Bottom</option>
                <option value="front">‚û°Ô∏è Front</option>
                <option value="back">‚¨ÖÔ∏è Back</option>
                <option value="left">‚¨ÖÔ∏è Left</option>
                <option value="right">‚û°Ô∏è Right</option>
                <option value="perspective">üé• Perspective</option>
            </select>
        </div>
        
        <!-- Transform Gizmo Controls -->
        <div style="display: flex; gap: 4px; margin-left: 12px; align-items: center;">
            <button onclick="setGizmoMode('translate')" id="gizmo-move-btn-top" title="Move (G)" style="padding: 6px 10px; background: rgba(13,148,136,0.1); border: 1px solid #0d9488; border-radius: 4px; color: #0d9488; cursor: pointer; font-size: 14px;">‚ûú</button>
            <button onclick="setGizmoMode('rotate')" id="gizmo-rotate-btn-top" title="Rotate (R)" style="padding: 6px 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #888; cursor: pointer; font-size: 14px;">‚Üª</button>
            <button onclick="setGizmoMode('scale')" id="gizmo-scale-btn-top" title="Scale (S)" style="padding: 6px 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #888; cursor: pointer; font-size: 14px;">‚áî</button>
        </div>
        
        <!-- Brightness Button (shrunk) -->
        <button class="btn-modern btn-modern-secondary" onclick="toggleBrightnessPanel()" style="margin-left: 12px; padding: 8px 12px; font-size: 11px;">
            ‚òÄÔ∏è
        </button>
        
        <!-- Undo/Redo -->
        <button onclick="undo()" id="undo-btn" title="Undo (Ctrl+Z)" style="margin-left: 12px; padding: 6px 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #888; cursor: pointer; font-size: 14px;">
            ‚Ü∂
        </button>
        <button onclick="redo()" id="redo-btn" title="Redo (Ctrl+Shift+Z)" style="margin-left: 4px; padding: 6px 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #888; cursor: pointer; font-size: 14px;">
            ‚Ü∑
        </button>
        
        <!-- Grid/Snap -->
        <button onclick="toggleGrid()" id="grid-btn" title="Toggle Grid" style="margin-left: 12px; padding: 6px 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #888; cursor: pointer; font-size: 11px; font-weight: 600;">
            üî≤ Grid
        </button>
        
        <!-- Measurement -->
        <button onclick="toggleMeasurements()" id="measure-btn" title="Toggle Measurements" style="margin-left: 4px; padding: 6px 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #888; cursor: pointer; font-size: 11px; font-weight: 600;">
            üìè Measure
        </button>
        
        <!-- Photometric -->
        <button onclick="toggleFloatingWindow('photometric-window')" id="photo-btn" title="Photometric Analysis" style="margin-left: 4px; padding: 6px 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #888; cursor: pointer; font-size: 11px; font-weight: 600;">
            üí° Photo
        </button>
        
        <button onclick="exportScenePNG()" id="export-png-btn" title="Export Scene as PNG" style="margin-left: 4px; padding: 6px 10px; background: rgba(13,148,136,0.1); border: 1px solid #0d9488; border-radius: 4px; color: #0d9488; cursor: pointer; font-size: 11px; font-weight: 600;">
            üì∏ Export PNG
        </button>
        
        <button onclick="toggleTimeline()" id="timeline-toggle-btn" title="Toggle Timeline" style="margin-left: 4px; padding: 6px 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #888; cursor: pointer; font-size: 11px; font-weight: 600;">
            ‚è±Ô∏è Timeline
        </button>
        
        <div class="action-buttons" style="margin-left: auto;">
            <button class="btn-modern btn-modern-secondary" onclick="openPrimitivePopup(event)" style="padding: 6px 12px; font-size: 11px;">üî∑</button>
            <button class="btn-modern btn-modern-secondary" onclick="openModelLoader()" style="padding: 6px 12px; font-size: 11px;">üìÅ</button>
            <button class="btn-modern btn-modern-secondary" onclick="createCamera()" style="padding: 6px 12px; font-size: 11px;" title="Create Camera">üì∑</button>
            <button class="btn-modern btn-modern-secondary" onclick="saveProject()" style="padding: 6px 12px; font-size: 11px;">üíæ</button>
            <button class="btn-modern btn-modern-primary" onclick="openProjectorModal()" style="padding: 6px 12px; font-size: 11px; font-weight: 600;">+ Proj</button>
        </div>
    </div>
    
    <!-- Hidden file inputs moved to projector controls -->
    
    <!-- MODERN 3-COLUMN CONTAINER -->
    <div class="modern-container">
        
        <!-- LEFT SIDEBAR -->
        <div class="modern-sidebar-left">
            
            <div class="sidebar-header">
                <div class="search-box">
                    <span class="search-icon">üîç</span>
                    <input type="text" id="global-search" placeholder="Search projectors, lenses..." onkeyup="globalSearch(this.value)">
                </div>
            </div>
            
            <!-- Panel: Projectors (SETUP) -->
            <div class="collapsible-panel" id="panel-projectors" data-tab="setup">
                <div class="panel-header" onclick="togglePan('panel-projectors')">
                    <div class="panel-title">
                        <span class="panel-icon">üìΩÔ∏è</span>
                        <span>Projectors</span>
                        <span class="panel-count" id="projector-count">(0)</span>
                    </div>
                    <span class="panel-chevron">‚ñº</span>
                </div>
                <div class="panel-content" id="panel-projectors-content">
                    <!-- Will be populated dynamically -->
                    <div style="padding: 20px; text-align: center;">
                        <div style="font-size: 32px; margin-bottom: 8px;">üìΩÔ∏è</div>
                        <div style="color: #888; font-size: 12px; margin-bottom: 4px;">No projectors yet</div>
                        <div style="color: #666; font-size: 11px;">Click "+ New Projector" to add one</div>
                    </div>
                </div>
            </div>
            
            <!-- Panel: Lens & Position (SETUP) -->
            <div class="collapsible-panel" id="panel-lens" data-tab="setup">
                <div class="panel-header" onclick="togglePan('panel-lens')">
                    <div class="panel-title">
                        <span class="panel-icon">üî≠</span>
                        <span>Lens & Position</span>
                    </div>
                    <span class="panel-chevron">‚ñº</span>
                </div>
                <div class="panel-content" id="panel-lens-content">
                    <!-- Lens Selection -->
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; font-size: 11px; color: #888; margin-bottom: 8px; text-transform: uppercase;">üî≠ Lens</label>
                        <select id="lens-select" onchange="changeLens()" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; color: #e0e0e0; font-size: 13px;">
                            <option value="ET-D3LEU100">ET-D3LEU100 (0.36:1)</option>
                            <option value="ET-D3LEW200">ET-D3LEW200 (0.48-0.55:1)</option>
                            <option value="ET-D3LEW60">ET-D3LEW60 (0.68-0.80:1)</option>
                            <option value="ET-D75LE6">ET-D75LE6 (0.90-1.10:1)</option>
                            <option value="ET-D3LEW10">ET-D3LEW10 (1.01-1.30:1)</option>
                            <option value="ET-D3LES20" selected>ET-D3LES20 (1.36-1.78:1)</option>
                            <option value="ET-D3LET80">ET-D3LET80 (1.81-2.56:1)</option>
                            <option value="ET-D75LE95">ET-D75LE95 (0.80:1)</option>
                        </select>
                        <div style="margin-top: 8px; padding: 8px; background: rgba(13, 148, 136, 0.05); border-radius: 4px; font-size: 10px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 2px;">
                                <span style="color: #666;">Throw:</span>
                                <span style="color: #0d9488;" id="spec-throw">1.36-1.78:1</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 2px;">
                                <span style="color: #666;">Shift V:</span>
                                <span style="color: #0d9488;" id="spec-shift-v">¬±66%</span>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: #666;">Shift H:</span>
                                <span style="color: #0d9488;" id="spec-shift-h">¬±24%</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Throw Ratio / Zoom -->
                    <div style="margin-bottom: 16px;">
                        <label style="font-size: 11px; color: #888; text-transform: uppercase;">Throw Ratio</label>
                        <div style="display: flex; align-items: center; gap: 12px; margin-top: 8px;">
                            <input type="range" id="zoom" min="1.36" max="1.78" step="0.01" value="1.36" oninput="updateZoom()" style="flex: 1;">
                            <span id="zoom-val" style="min-width: 60px; text-align: right; color: #0d9488; font-weight: 600; font-size: 12px;">1.36:1</span>
                        </div>
                    </div>
                    
                    <!-- Lens Shift V -->
                    <div style="margin-bottom: 16px;">
                        <label style="font-size: 11px; color: #888; text-transform: uppercase;">Lens Shift Vertical</label>
                        <div style="display: flex; align-items: center; gap: 12px; margin-top: 8px;">
                            <input type="range" id="shift-v" min="-66" max="66" step="1" value="0" oninput="updateLensShift()" style="flex: 1;">
                            <span id="shift-v-val" style="min-width: 60px; text-align: right; color: #0d9488; font-weight: 600; font-size: 12px;">0%</span>
                        </div>
                    </div>
                    
                    <!-- Lens Shift H -->
                    <div style="margin-bottom: 16px;">
                        <label style="font-size: 11px; color: #888; text-transform: uppercase;">Lens Shift Horizontal</label>
                        <div style="display: flex; align-items: center; gap: 12px; margin-top: 8px;">
                            <input type="range" id="shift-h" min="-24" max="24" step="1" value="0" oninput="updateLensShift()" style="flex: 1;">
                            <span id="shift-h-val" style="min-width: 60px; text-align: right; color: #0d9488; font-weight: 600; font-size: 12px;">0%</span>
                        </div>
                    </div>
                    
                    <!-- Intensity -->
                    <div style="margin-bottom: 16px;">
                        <label style="font-size: 11px; color: #888; text-transform: uppercase;">Intensity</label>
                        <div style="display: flex; align-items: center; gap: 12px; margin-top: 8px;">
                            <input type="range" id="proj-intensity" min="0" max="2" step="0.1" value="1.0" oninput="updateProjectionIntensity()" style="flex: 1;">
                            <span id="proj-intensity-val" style="min-width: 60px; text-align: right; color: #0d9488; font-weight: 600; font-size: 12px;">1.0</span>
                        </div>
                    </div>
                    
                    <!-- Target Controls (Lock Aim + Set as Target) -->
                    <div style="margin-bottom: 24px;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                            <!-- Lock Aim Button -->
                            <button onclick="toggleTargetLock()" id="lock-aim-btn" style="padding: 12px; background: rgba(13,148,136,0.2); border: 1px solid #0d9488; border-radius: 6px; color: #0d9488; cursor: pointer; font-size: 12px; font-weight: 600;">
                                üéØ Lock Aim
                            </button>
                            
                            <!-- Set as Target Button -->
                            <button onclick="setSelectedAsTarget()" id="set-target-btn-panel" style="padding: 12px; background: rgba(255,159,64,0.1); border: 1px solid #ff9f40; border-radius: 6px; color: #ff9f40; cursor: pointer; font-size: 12px; font-weight: 600;" disabled>
                                üéØ Set Target
                            </button>
                        </div>
                    </div>
                    
                    <!-- PROJECTION CONTENT -->
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; font-size: 11px; color: #888; margin-bottom: 12px; text-transform: uppercase;">üé¨ Projection Content</label>
                        
                        <!-- Image Upload -->
                        <button onclick="document.getElementById('proj-image-upload').click()" style="width: 100%; padding: 10px; margin-bottom: 8px; background: rgba(13,148,136,0.1); border: 1px solid #0d9488; border-radius: 6px; color: #0d9488; cursor: pointer; font-size: 12px; font-weight: 600;">
                            üñºÔ∏è Load Image (JPG, PNG...)
                        </button>
                        <input type="file" id="proj-image-upload" accept="image/*" style="display:none;" onchange="loadProjectorImage()">
                        
                        <!-- Modern File Picker (Chrome 86+) -->
                        <button onclick="loadVideoModern()" style="width: 100%; padding: 10px; margin-bottom: 8px; background: rgba(13,148,136,0.1); border: 1px solid #0d9488; border-radius: 6px; color: #0d9488; cursor: pointer; font-size: 12px; font-weight: 600;">
                            üé¨ Load Video
                        </button>
                        
                        <!-- MEDIA PLAYER CONTROLS -->
                        <div id="media-controls" style="margin-top: 16px; padding: 12px; background: rgba(13,148,136,0.05); border: 1px solid #0d9488; border-radius: 6px; display: none;">
                            <div style="font-size: 11px; color: #0d9488; font-weight: 600; margin-bottom: 12px;">üé¨ MEDIA PLAYER</div>
                            
                            <!-- Play/Pause/Stop -->
                            <div style="display: flex; gap: 6px; margin-bottom: 12px;">
                                <button id="btn-play" onclick="mediaPlay()" style="flex: 1; padding: 8px; background: rgba(13,148,136,0.1); border: 1px solid #0d9488; border-radius: 4px; color: #0d9488; cursor: pointer; font-size: 11px;">
                                    ‚ñ∂Ô∏è Play
                                </button>
                                <button id="btn-pause" onclick="mediaPause()" style="flex: 1; padding: 8px; background: rgba(255,107,107,0.1); border: 1px solid #ff6b6b; border-radius: 4px; color: #ff6b6b; cursor: pointer; font-size: 11px;">
                                    ‚è∏Ô∏è Pause
                                </button>
                                <button onclick="mediaStop()" style="flex: 1; padding: 8px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #888; cursor: pointer; font-size: 11px;">
                                    ‚èπÔ∏è Stop
                                </button>
                            </div>
                            
                            <!-- Timeline / Seek Bar -->
                            <div style="margin-bottom: 12px;">
                                <div style="display: flex; justify-content: space-between; font-size: 9px; color: #666; margin-bottom: 4px;">
                                    <span id="time-current">0:00</span>
                                    <span id="time-total">0:00</span>
                                </div>
                                <input type="range" id="seek-bar" min="0" max="100" value="0" step="0.1" oninput="mediaSeek(this.value)" style="width: 100%; cursor: pointer;">
                            </div>
                            
                            <!-- Volume -->
                            <div style="margin-bottom: 8px;">
                                <label style="font-size: 10px; color: #888; margin-bottom: 4px; display: block;">üîä Volume</label>
                                <input type="range" id="volume-slider" min="0" max="100" value="100" oninput="mediaVolume(this.value)" style="width: 100%;">
                            </div>
                            
                            <!-- Speed -->
                            <div style="display: flex; gap: 4px; font-size: 10px;">
                                <button onclick="mediaSpeed(0.5)" style="flex: 1; padding: 4px; background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1); border-radius: 3px; color: #888; cursor: pointer;">0.5x</button>
                                <button onclick="mediaSpeed(1.0)" style="flex: 1; padding: 4px; background: rgba(13,148,136,0.1); border: 1px solid #0d9488; border-radius: 3px; color: #0d9488; cursor: pointer;">1x</button>
                                <button onclick="mediaSpeed(1.5)" style="flex: 1; padding: 4px; background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1); border-radius: 3px; color: #888; cursor: pointer;">1.5x</button>
                                <button onclick="mediaSpeed(2.0)" style="flex: 1; padding: 4px; background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1); border-radius: 3px; color: #888; cursor: pointer;">2x</button>
                            </div>
                        </div>
                        
                        <!-- Preset Textures -->
                        <div style="margin-top: 12px;">
                            <label style="font-size: 10px; color: #666; margin-bottom: 6px; display: block;">Or choose preset:</label>
                            <select id="preset-texture" onchange="loadPresetTexture()" style="width: 100%; padding: 6px; background: #1a1a1a; border: 1px solid #333; border-radius: 4px; color: #e0e0e0; font-size: 11px;">
                                <option value="">-- Select Preset --</option>
                                <option value="uv-grid">UV Grid</option>
                                <option value="white">White</option>
                                <option value="checkerboard">Checkerboard</option>
                                <option value="gradient">Gradient</option>
                                <option value="color-bars">Color Bars</option>
                                <option value="test-pattern">Test Pattern</option>
                            </select>
                        </div>
                        
                        <div id="image-status" style="margin-top: 8px; font-size: 10px;"></div>
                    </div>
                    
                    <!-- Reset Button -->
                    <button onclick="resetLensShift()" style="width: 100%; padding: 8px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: #e0e0e0; cursor: pointer; font-size: 12px;">
                        Reset Lens Shift
                    </button>
                </div>
            </div>
            
            
            <!-- Panel: Correction -->
            <!-- Panel: Correction (CALIBRATION) -->
            <div class="collapsible-panel" id="panel-correction" data-tab="calibration">
                <div class="panel-header" onclick="togglePan('panel-correction')">
                    <div class="panel-title">
                        <span class="panel-icon">‚öôÔ∏è</span>
                        <span>Correction</span>
                    </div>
                    <span class="panel-chevron">‚ñº</span>
                </div>
                <div class="panel-content" id="panel-correction-content">
                    <!-- Keystone Global -->
                    <div style="margin-bottom: 16px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <label style="font-size: 11px; color: #888; text-transform: uppercase;">üî≤ Keystone Global</label>
                            <button id="keystone-bypass-btn" onclick="toggleKeystoneBypass()" style="padding: 4px 10px; background: rgba(255,107,107,0.1); border: 1px solid #ff6b6b; border-radius: 4px; color: #ff6b6b; cursor: pointer; font-size: 9px; font-weight: 600;">
                                BYPASS
                            </button>
                        </div>
                        
                        <div style="margin-bottom: 12px;">
                            <label style="font-size: 11px; color: #888;">Vertical</label>
                            <div style="display: flex; align-items: center; gap: 12px; margin-top: 6px;">
                                <input type="range" id="keystone-v" min="-50" max="50" step="1" value="0" oninput="updateKeystone()" style="flex: 1;">
                                <span id="keystone-v-val" style="min-width: 40px; text-align: right; color: #0d9488; font-weight: 600; font-size: 12px;">0</span>
                            </div>
                        </div>
                        
                        <div>
                            <label style="font-size: 11px; color: #888;">Horizontal</label>
                            <div style="display: flex; align-items: center; gap: 12px; margin-top: 6px;">
                                <input type="range" id="keystone-h" min="-50" max="50" step="1" value="0" oninput="updateKeystone()" style="flex: 1;">
                                <span id="keystone-h-val" style="min-width: 40px; text-align: right; color: #0d9488; font-weight: 600; font-size: 12px;">0</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Individual Corner Control (2D) - INTEGRATED -->
                    <div style="background:#0a0a0a; padding:10px; border-radius:6px; margin-bottom:10px;">
                        <div style="font-size:9px; color:#888; margin-bottom:8px; text-transform:uppercase;">üî≤ Contr√¥le des Coins (2D)</div>
                        
                        <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                            <!-- Top-Left Corner -->
                            <div style="background:#1a1a1a; padding:8px; border-radius:4px;">
                                <div style="font-size:9px; color:#0d9488; margin-bottom:4px; font-weight:600;">üî∫ HAUT-GAUCHE</div>
                                <div class="control-row" style="margin-bottom:4px;">
                                    <label style="font-size:9px;">X: <span class="value-display" id="keystone-tl-x-val-2">0</span></label>
                                    <input type="range" id="keystone-tl-x-2" min="0" max="200" step="1" value="0" oninput="syncCornerControl('tl-x', this.value)">
                                </div>
                                <div class="control-row" style="margin:0;">
                                    <label style="font-size:9px;">Y: <span class="value-display" id="keystone-tl-y-val-2">0</span></label>
                                    <input type="range" id="keystone-tl-y-2" min="0" max="200" step="1" value="0" oninput="syncCornerControl('tl-y', this.value)">
                                </div>
                            </div>
                            
                            <!-- Top-Right Corner -->
                            <div style="background:#1a1a1a; padding:8px; border-radius:4px;">
                                <div style="font-size:9px; color:#0d9488; margin-bottom:4px; font-weight:600;">üî∫ HAUT-DROIT</div>
                                <div class="control-row" style="margin-bottom:4px;">
                                    <label style="font-size:9px;">X: <span class="value-display" id="keystone-tr-x-val-2">0</span></label>
                                    <input type="range" id="keystone-tr-x-2" min="0" max="200" step="1" value="0" oninput="syncCornerControl('tr-x', this.value)">
                                </div>
                                <div class="control-row" style="margin:0;">
                                    <label style="font-size:9px;">Y: <span class="value-display" id="keystone-tr-y-val-2">0</span></label>
                                    <input type="range" id="keystone-tr-y-2" min="0" max="200" step="1" value="0" oninput="syncCornerControl('tr-y', this.value)">
                                </div>
                            </div>
                            
                            <!-- Bottom-Left Corner -->
                            <div style="background:#1a1a1a; padding:8px; border-radius:4px;">
                                <div style="font-size:9px; color:#0d9488; margin-bottom:4px; font-weight:600;">üîª BAS-GAUCHE</div>
                                <div class="control-row" style="margin-bottom:4px;">
                                    <label style="font-size:9px;">X: <span class="value-display" id="keystone-bl-x-val-2">0</span></label>
                                    <input type="range" id="keystone-bl-x-2" min="0" max="200" step="1" value="0" oninput="syncCornerControl('bl-x', this.value)">
                                </div>
                                <div class="control-row" style="margin:0;">
                                    <label style="font-size:9px;">Y: <span class="value-display" id="keystone-bl-y-val-2">0</span></label>
                                    <input type="range" id="keystone-bl-y-2" min="0" max="200" step="1" value="0" oninput="syncCornerControl('bl-y', this.value)">
                                </div>
                            </div>
                            
                            <!-- Bottom-Right Corner -->
                            <div style="background:#1a1a1a; padding:8px; border-radius:4px;">
                                <div style="font-size:9px; color:#0d9488; margin-bottom:4px; font-weight:600;">üîª BAS-DROIT</div>
                                <div class="control-row" style="margin-bottom:4px;">
                                    <label style="font-size:9px;">X: <span class="value-display" id="keystone-br-x-val-2">0</span></label>
                                    <input type="range" id="keystone-br-x-2" min="0" max="200" step="1" value="0" oninput="syncCornerControl('br-x', this.value)">
                                </div>
                                <div class="control-row" style="margin:0;">
                                    <label style="font-size:9px;">Y: <span class="value-display" id="keystone-br-y-val-2">0</span></label>
                                    <input type="range" id="keystone-br-y-2" min="0" max="200" step="1" value="0" oninput="syncCornerControl('br-y', this.value)">
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Reset Button -->
                    <button onclick="resetKeystone()" style="width: 100%; padding: 8px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: #e0e0e0; cursor: pointer; font-size: 12px;">
                        Reset All
                    </button>
                </div>
            </div>
            
            <!-- Panel: Advanced Tools (CALIBRATION) -->
            <div class="collapsible-panel" id="panel-advanced" data-tab="calibration">
                <div class="panel-header" onclick="togglePan('panel-advanced')">
                    <div class="panel-title">
                        <span class="panel-icon">üéöÔ∏è</span>
                        <span>Advanced</span>
                    </div>
                    <span class="panel-chevron">‚ñº</span>
                </div>
                <div class="panel-content" id="panel-advanced-content">
                    
                    <!-- Stack System - INTEGRATED -->
                    <div style="background:#0a0a0a; padding:12px; border-radius:6px; margin-bottom:16px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom:12px;">
                            <div style="font-size:9px; color:#888; text-transform:uppercase;">üìö Projector Stack</div>
                            <button id="stack-bypass-btn" onclick="toggleStackBypass()" style="padding: 4px 10px; background: rgba(255,107,107,0.1); border: 1px solid #ff6b6b; border-radius: 4px; color: #ff6b6b; cursor: pointer; font-size: 9px; font-weight: 600;">
                                BYPASS
                            </button>
                        </div>
                        
                        <div class="control-row" style="margin-bottom:12px;">
                            <label style="font-size:10px;">Dummy Projectors: <span class="value-display" id="stack-count-val-2">0</span></label>
                            <input type="range" id="stack-count-2" min="0" max="10" step="1" value="0" oninput="syncStack('count', this.value)">
                        </div>
                        
                        <div style="padding:8px; background:#0d2520; border-left:3px solid #0d9488; border-radius:4px; margin-bottom:12px;">
                            <div style="font-size:9px; color:#666; margin-bottom:2px;">Total Output:</div>
                            <div style="font-size:14px; font-weight:bold; color:#0d9488;">
                                <span id="stack-total-lumens-2">25,000</span> lumens
                            </div>
                            <div style="font-size:8px; color:#666; margin-top:2px;">
                                <span id="stack-multiplier-2">1</span>x base projector
                            </div>
                        </div>
                        
                        <div style="margin-bottom:12px;">
                            <div style="font-size:9px; color:#888; margin-bottom:8px;">Offset Position</div>
                            <div class="control-row" style="margin-bottom:6px;">
                                <label style="font-size:9px;">X: <span class="value-display" id="stack-offset-x-val-2">0.00</span>m</label>
                                <input type="range" id="stack-offset-x-2" min="-2" max="2" step="0.01" value="0" oninput="syncStack('offset-x', this.value)">
                            </div>
                            <div class="control-row" style="margin-bottom:6px;">
                                <label style="font-size:9px;">Y: <span class="value-display" id="stack-offset-y-val-2">0.00</span>m</label>
                                <input type="range" id="stack-offset-y-2" min="-2" max="2" step="0.01" value="0" oninput="syncStack('offset-y', this.value)">
                            </div>
                            <div class="control-row">
                                <label style="font-size:9px;">Z: <span class="value-display" id="stack-offset-z-val-2">0.00</span>m</label>
                                <input type="range" id="stack-offset-z-2" min="-2" max="2" step="0.01" value="0" oninput="syncStack('offset-z', this.value)">
                            </div>
                        </div>
                        
                        <div style="font-size:9px; color:#888; margin-bottom:6px;">Settings</div>
                        <div class="checkbox-row" style="margin-bottom:4px;">
                            <input type="checkbox" id="stack-auto-lumens-2" checked onchange="syncStack('auto-lumens', this.checked)">
                            <span style="font-size:10px;">Auto Lumens</span>
                        </div>
                        <div class="checkbox-row" style="margin-bottom:4px;">
                            <input type="checkbox" id="stack-visible-2" checked onchange="syncStack('visible', this.checked)">
                            <span style="font-size:10px;">Visible</span>
                        </div>
                        <div class="checkbox-row">
                            <input type="checkbox" id="stack-powered-2" checked onchange="syncStack('powered', this.checked)">
                            <span style="font-size:10px;">Powered</span>
                        </div>
                    </div>
                    
                    <!-- Soft Edge - INTEGRATED -->
                    <div style="background:#0a0a0a; padding:12px; border-radius:6px; margin-bottom:16px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom:12px;">
                            <div style="font-size:9px; color:#888; text-transform:uppercase;">üå´Ô∏è Soft Edge</div>
                            <button id="softedge-bypass-btn" onclick="toggleSoftEdgeBypass()" style="padding: 4px 10px; background: rgba(255,107,107,0.1); border: 1px solid #ff6b6b; border-radius: 4px; color: #ff6b6b; cursor: pointer; font-size: 9px; font-weight: 600;">
                                BYPASS
                            </button>
                        </div>
                        
                        <div class="control-row" style="margin-bottom:8px;">
                            <label style="font-size:10px;">Gauche: <span class="value-display" id="softedge-l-val-2">0%</span></label>
                            <input type="range" id="softedge-l-2" min="0" max="50" step="1" value="0" oninput="syncSoftEdge('l', this.value)">
                        </div>
                        <div class="control-row" style="margin-bottom:8px;">
                            <label style="font-size:10px;">Droite: <span class="value-display" id="softedge-r-val-2">0%</span></label>
                            <input type="range" id="softedge-r-2" min="0" max="50" step="1" value="0" oninput="syncSoftEdge('r', this.value)">
                        </div>
                        <div class="control-row" style="margin-bottom:8px;">
                            <label style="font-size:10px;">Haut: <span class="value-display" id="softedge-t-val-2">0%</span></label>
                            <input type="range" id="softedge-t-2" min="0" max="50" step="1" value="0" oninput="syncSoftEdge('t', this.value)">
                        </div>
                        <div class="control-row" style="margin-bottom:8px;">
                            <label style="font-size:10px;">Bas: <span class="value-display" id="softedge-b-val-2">0%</span></label>
                            <input type="range" id="softedge-b-2" min="0" max="50" step="1" value="0" oninput="syncSoftEdge('b', this.value)">
                        </div>
                        <div class="control-row" style="margin-bottom:8px;">
                            <label style="font-size:10px;">Gamma: <span class="value-display" id="softedge-gamma-val-2">2.2</span></label>
                            <input type="range" id="softedge-gamma-2" min="1.0" max="3.0" step="0.1" value="2.2" oninput="syncSoftEdge('gamma', this.value)">
                        </div>
                        
                        <button class="secondary" onclick="resetSoftEdge()" style="width:100%; margin-top:4px;">Reset</button>
                    </div>
                    
                    <!-- Photometric Button -->
                    <button class="btn-modern btn-modern-secondary" style="width:100%;" onclick="toggleFloatingWindow('photometric-window')">
                        üí° Photometric
                    </button>
                </div>
            </div>
            
        </div>
        
        <!-- CENTER VIEWPORT -->
        <div class="modern-viewport" id="modern-viewport">
            <!-- Canvas will be moved here -->
        </div>
        
        <!-- TIMELINE (Bottom) - Layer-based -->
        <div id="timeline-container" style="position: fixed; bottom: 0; left: 320px; right: 280px; height: 250px; background: rgba(10, 10, 10, 0.98); border-top: 1px solid rgba(255,255,255,0.1); z-index: 100; display: none; overflow: hidden;">
            <!-- Timeline Header -->
            <div style="padding: 8px 16px; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; align-items: center; gap: 8px; background: rgba(0,0,0,0.5);">
                <div style="font-size: 12px; font-weight: 600; color: #0d9488;">‚è±Ô∏è Timeline</div>
                
                <button id="timeline-play-btn" onclick="timeline.playing ? pauseTimeline() : playTimeline()" style="padding: 6px 12px; background: rgba(13,148,136,0.1); border: 1px solid #0d9488; border-radius: 4px; color: #0d9488; cursor: pointer; font-size: 16px;">
                    ‚ñ∂Ô∏è
                </button>
                
                <button onclick="stopTimeline()" style="padding: 6px 12px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #fff; cursor: pointer; font-size: 16px;">
                    ‚èπÔ∏è
                </button>
                
                <div id="timeline-time" style="font-size: 11px; color: #888; font-family: monospace;">
                    0.00s / 30s
                </div>
                
                <div style="margin-left: auto; display: flex; gap: 6px;">
                    <button onclick="if(selectedObject) addToTimeline(selectedObject)" title="Add selected object as layer" style="padding: 6px 10px; background: rgba(13,148,136,0.1); border: 1px solid #0d9488; border-radius: 4px; color: #0d9488; cursor: pointer; font-size: 10px; font-weight: 600;">
                        + Layer
                    </button>
                    
                    <button onclick="addKeyframeQuick()" title="Add keyframe (K)" style="padding: 6px 10px; background: rgba(13,148,136,0.1); border: 1px solid #0d9488; border-radius: 4px; color: #0d9488; cursor: pointer; font-size: 10px; font-weight: 600;">
                        K Keyframe
                    </button>
                    
                    <button onclick="console.log('üîç Timeline Debug:', {layers: timeline.layers.length, currentTime: timeline.currentTime, allKeyframes: timeline.layers.map(l => ({name: l.name, keyframes: l.keyframes.length}))})" title="Debug timeline" style="padding: 6px 10px; background: rgba(255,193,7,0.1); border: 1px solid #ffc107; border-radius: 4px; color: #ffc107; cursor: pointer; font-size: 10px; font-weight: 600;">
                        üîç
                    </button>
                    
                    <select id="easing-select" style="padding: 6px; background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #fff; font-size: 10px; cursor: pointer;">
                        <option value="linear">Linear</option>
                        <option value="easeInQuad">Ease In</option>
                        <option value="easeOutQuad">Ease Out</option>
                        <option value="easeInOutQuad" selected>Ease In/Out</option>
                        <option value="easeInCubic">Ease In (Strong)</option>
                        <option value="easeOutCubic">Ease Out (Strong)</option>
                    </select>
                    
                    <button onclick="toggleTimeline()" style="padding: 6px 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #fff; cursor: pointer; font-size: 10px;">
                        ‚úï
                    </button>
                </div>
            </div>
            
            <!-- Timeline Content (Layers) -->
            <div style="display: grid; grid-template-columns: 200px 1fr; height: calc(100% - 50px); overflow: hidden;">
                <!-- Layers List (Left) -->
                <div id="timeline-layers" style="overflow-y: auto; background: rgba(0,0,0,0.3); border-right: 1px solid rgba(255,255,255,0.1);">
                    <!-- Layers will be rendered here -->
                </div>
                
                <!-- Timeline Ruler & Tracks (Right) -->
                <div style="overflow-x: auto; overflow-y: hidden;">
                    <!-- Time Ruler -->
                    <div id="timeline-ruler" style="height: 30px; background: rgba(0,0,0,0.5); border-bottom: 1px solid rgba(255,255,255,0.1); position: relative; cursor: crosshair;">
                        <!-- Main time markers (every 5s) -->
                        <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex;">
                            <div style="flex: 1; border-right: 1px solid rgba(255,255,255,0.1); display: flex; align-items: center; justify-content: center; font-size: 9px; color: #666; font-weight: 600;">0s</div>
                            <div style="flex: 1; border-right: 1px solid rgba(255,255,255,0.1); display: flex; align-items: center; justify-content: center; font-size: 9px; color: #666; font-weight: 600;">5s</div>
                            <div style="flex: 1; border-right: 1px solid rgba(255,255,255,0.1); display: flex; align-items: center; justify-content: center; font-size: 9px; color: #666; font-weight: 600;">10s</div>
                            <div style="flex: 1; border-right: 1px solid rgba(255,255,255,0.1); display: flex; align-items: center; justify-content: center; font-size: 9px; color: #666; font-weight: 600;">15s</div>
                            <div style="flex: 1; border-right: 1px solid rgba(255,255,255,0.1); display: flex; align-items: center; justify-content: center; font-size: 9px; color: #666; font-weight: 600;">20s</div>
                            <div style="flex: 1; border-right: 1px solid rgba(255,255,255,0.1); display: flex; align-items: center; justify-content: center; font-size: 9px; color: #666; font-weight: 600;">25s</div>
                            <div style="flex: 1; display: flex; align-items: center; justify-content: center; font-size: 9px; color: #666; font-weight: 600;">30s</div>
                        </div>
                        
                        <!-- Secondary time markers (every 1s) -->
                        <div id="timeline-ticks" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></div>
                        
                        <!-- Playhead (draggable) -->
                        <div id="timeline-playhead" style="position: absolute; top: 0; left: 0%; width: 2px; height: calc(100% + 200px); background: #0d9488; pointer-events: all; z-index: 10; cursor: grab;">
                            <div style="width: 12px; height: 12px; background: #0d9488; border: 2px solid #0a0a0a; border-radius: 50%; position: absolute; top: 9px; left: -5px; cursor: grab; box-shadow: 0 2px 8px rgba(13,148,136,0.5);"></div>
                            <!-- Time tooltip -->
                            <div id="playhead-time" style="position: absolute; top: -20px; left: -20px; background: rgba(13,148,136,0.9); color: #fff; padding: 2px 6px; border-radius: 3px; font-size: 10px; font-weight: 600; white-space: nowrap; pointer-events: none;">0.00s</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- RIGHT PANEL (Gizmo + Scene + Properties) -->
        <div class="modern-sidebar-right">
            
            <!-- Gizmo Mode Controls -->
            <div style="margin-bottom: 20px;">
                <div class="properties-header">üéõÔ∏è Gizmo Mode</div>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">
                    <button onclick="setGizmoMode('translate')" id="gizmo-move-btn" style="padding: 12px; background: rgba(13,148,136,0.1); border: 1px solid #0d9488; border-radius: 6px; color: #0d9488; cursor: pointer; font-size: 20px;">
                        ‚ûú
                    </button>
                    <button onclick="setGizmoMode('rotate')" id="gizmo-rotate-btn" style="padding: 12px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: #e0e0e0; cursor: pointer; font-size: 20px;">
                        ‚Üª
                    </button>
                    <button onclick="setGizmoMode('scale')" id="gizmo-scale-btn" style="padding: 12px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: #e0e0e0; cursor: pointer; font-size: 20px;">
                        ‚áî
                    </button>
                </div>
            </div>
            
            <!-- Scene Hierarchy (C4D Style) -->
            <div style="margin-bottom: 20px;">
                <div class="properties-header">üé¨ Scene Hierarchy</div>
                <div id="scene-hierarchy" style="max-height: 400px; overflow-y: auto; font-size: 11px;">
                    <!-- Hierarchy will be populated here -->
                </div>
            </div>
            
            <!-- Properties -->
            <div>
                <div class="properties-header">Properties</div>
                
                <div class="property-item">
                    <div class="property-label">Selection</div>
                    <div class="property-value" id="prop-selection">None</div>
                </div>
                
                <div class="property-item">
                    <div class="property-label">Model</div>
                    <div class="property-value" id="prop-model">-</div>
                </div>
                
                <div class="property-item">
                    <div class="property-label">Position</div>
                    <div class="property-value" id="prop-position">X: - Y: - Z: -</div>
                </div>
                
                <div class="property-item">
                    <div class="property-label">Rotation</div>
                    <div class="property-value" id="prop-rotation">X: - Y: - Z: -</div>
                </div>
                
                <div class="property-item" id="prop-lumens-group" style="display:none;">
                    <div class="property-label">Brightness</div>
                    <div class="property-value" id="prop-lumens">-</div>
                </div>
                
                <!-- Set as Target Button (only for non-projector objects) -->
                <button id="set-target-btn" onclick="setSelectedAsTarget()" style="width: 100%; padding: 10px; margin-top: 16px; background: rgba(13,148,136,0.1); border: 1px solid #0d9488; border-radius: 6px; color: #0d9488; cursor: pointer; font-size: 12px; font-weight: 600; display: none;">
                    üéØ Set as Target
                </button>
            </div>
        </div>
    </div>
    
    <!-- ORIGINAL CONTAINER (hidden when modern-interface active) -->
    <div id="container"></div>

    <!-- Top Menu Bar -->
    <div id="top-menu">
        <div class="menu-logo">PROJECTOR STUDIO</div>
        
        <!-- Undo/Redo Buttons -->
        <div class="history-buttons">
            <button id="undo-btn" class="history-btn" onclick="historyUndo()" disabled title="Annuler (Ctrl+Z)">‚Ü∂</button>
            <button id="redo-btn" class="history-btn" onclick="historyRedo()" disabled title="R√©tablir (Ctrl+Y)">‚Ü∑</button>
        </div>
        
        <!-- Calculateur -->
        <div class="menu-item" onclick="openWidescreenCalculator()" style="cursor:pointer;">
            üßÆ Calculateur
        </div>
        
        <!-- Direct Action Buttons -->
        <div class="menu-item" onclick="openProjectorModal()" style="cursor:pointer;">
            üìΩÔ∏è + Projecteur
        </div>
        
        <div class="menu-item" onclick="openPrimitivePopup(event)" style="cursor:pointer;">
            üî∑ + Primitive
        </div>
        
        <div class="menu-item" onclick="openModelLoader()" style="cursor:pointer;">
            üìÅ Charger 3D
        </div>
        
        <!-- Vue Menu -->
        <div class="menu-item">
            üëÅÔ∏è Vue
            <div class="menu-dropdown">
                <div class="dropdown-item" onclick="toggleFrustumFromMenu()">
                    <span id="menu-frustum-icon">‚úì</span> Frustum Helper
                </div>
                <div class="dropdown-item" onclick="toggleMeasurementsFromMenu()">
                    <span id="menu-measurements-icon">‚úì</span> Mesures Viewport
                </div>
                <div class="dropdown-divider"></div>
                <div class="dropdown-item" onclick="setCameraView('top')">
                    <span>‚¨ÜÔ∏è</span> Vue de Dessus (Top)
                </div>
                <div class="dropdown-item" onclick="setCameraView('front')">
                    <span>üéØ</span> Vue de Face (Front)
                </div>
                <div class="dropdown-item" onclick="setCameraView('left')">
                    <span>‚óÄÔ∏è</span> Vue Gauche (Left)
                </div>
                <div class="dropdown-item" onclick="setCameraView('right')">
                    <span>‚ñ∂Ô∏è</span> Vue Droite (Right)
                </div>
                <div class="dropdown-item" onclick="setCameraView('back')">
                    <span>üîô</span> Vue Arri√®re (Back)
                </div>
                <div class="dropdown-item" onclick="setCameraView('perspective')">
                    <span>üé•</span> Perspective (D√©faut)
                </div>
            </div>
        </div>
        
        <!-- Tools Menu -->
        <div class="menu-item">
            üõ†Ô∏è Outils
            <div class="menu-dropdown">
                <div class="dropdown-item" onclick="toggleFloatingWindow('scene-params-window')">
                    <span>‚öôÔ∏è</span> Param√®tres Sc√®ne
                </div>
                <div class="dropdown-item" onclick="toggleFloatingWindow('photometric-window')">
                    <span>üí°</span> Analyse Photom√©trique
                </div>
                <div class="dropdown-item" onclick="toggleFloatingWindow('export-window')">
                    <span>üìÑ</span> Export PDF
                </div>
            </div>
        </div>
    </div>

    <!-- Gizmo Mode Controls -->
    <div id="gizmo-controls">
        <div class="title">üéõÔ∏è Gizmo Mode</div>
        <div class="gizmo-mode-buttons">
            <div class="gizmo-mode-btn active" data-mode="translate" onclick="setGizmoMode('translate')">
                <div class="icon">‚ÜîÔ∏è</div>
                <div class="label">Move</div>
                <div class="key">[G]</div>
            </div>
            <div class="gizmo-mode-btn" data-mode="rotate" onclick="setGizmoMode('rotate')">
                <div class="icon">üîÑ</div>
                <div class="label">Rotate</div>
                <div class="key">[R]</div>
            </div>
            <div class="gizmo-mode-btn" data-mode="scale" onclick="setGizmoMode('scale')">
                <div class="icon">‚§°</div>
                <div class="label">Scale</div>
                <div class="key">[S]</div>
            </div>
        </div>
    </div>


    <!-- No Projector Message (shown when no projector exists) -->

    <!-- Calculateur Mode Selection Modal -->
    <div id="widescreen-mode-modal">
        <div class="widescreen-modal-content" style="max-width:500px;">
            <div class="widescreen-modal-header">
                <h2 class="widescreen-modal-title">üßÆ Calculateur - S√©lection du Mode</h2>
                <button class="projector-modal-close" onclick="closeWidescreenModeModal()">&times;</button>
            </div>
            <div class="widescreen-modal-body">
                <div class="ws-section">
                    <div class="ws-section-title">üìê Choisissez l'orientation principale de votre installation</div>
                    <div class="ws-mode-cards">
                        <div class="ws-mode-card" data-mode="landscape" onclick="selectWSMode('landscape')">
                            <div class="ws-mode-icon">üñ•Ô∏è</div>
                            <div class="ws-mode-label">LANDSCAPE</div>
                            <div class="ws-mode-desc">Format horizontal - largeur > hauteur (ex: 3x2, 4x2, 6x3...)</div>
                            <div class="ws-mode-preview">
                                <div class="ws-preview-box landscape">
                                    <span>1</span><span>2</span><span>3</span>
                                </div>
                            </div>
                        </div>
                        <div class="ws-mode-card" data-mode="portrait" onclick="selectWSMode('portrait')">
                            <div class="ws-mode-icon">üì±</div>
                            <div class="ws-mode-label">PORTRAIT</div>
                            <div class="ws-mode-desc">Format vertical - hauteur > largeur (ex: 2x3, 2x4, 3x6...)</div>
                            <div class="ws-mode-preview">
                                <div class="ws-preview-box portrait">
                                    <span>1</span><span>2</span><span>3</span>
                                </div>
                            </div>
                        </div>
                        <div class="ws-mode-card" data-mode="square" onclick="selectWSMode('square')">
                            <div class="ws-mode-icon">‚¨õ</div>
                            <div class="ws-mode-label">SQUARE</div>
                            <div class="ws-mode-desc">Format carr√© par paire (2x2, 4x4, 8x8...)</div>
                            <div class="ws-mode-preview">
                                <div class="ws-preview-box square">
                                    <span>1</span><span>2</span><span>3</span><span>4</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Calculateur Modal -->
    <div id="widescreen-modal">
        <div class="widescreen-modal-content">
            <div class="widescreen-modal-header">
                <h2 class="widescreen-modal-title">üßÆ Calculateur - <span id="ws-mode-display">LANDSCAPE</span></h2>
                <button class="projector-modal-close" onclick="closeWidescreenCalculator()">&times;</button>
            </div>
            <div class="widescreen-modal-body">
                <!-- Settings Section -->
                <div class="ws-section">
                    <div class="ws-section-title">‚öôÔ∏è Param√®tres</div>
                    <div class="ws-toggle-group">
                        <button class="ws-toggle-btn active" id="ws-unit-meter" onclick="setWSUnit('meter')">M√®tres</button>
                        <button class="ws-toggle-btn" id="ws-unit-inch" onclick="setWSUnit('inch')">Pouces</button>
                        <button class="ws-toggle-btn" onclick="openWidescreenModeModal()" style="margin-left:auto;">‚Ü©Ô∏è Changer Mode</button>
                    </div>
                </div>

                <!-- Matrix Configuration (dynamic based on mode) -->
                <div class="ws-section">
                    <div class="ws-section-title">üî¢ Matrice - <span id="ws-matrix-mode-label">LANDSCAPE</span></div>
                    <div class="ws-input-grid">
                        <div class="ws-input-group" id="ws-proj-h-group">
                            <label id="ws-proj-h-label">N. Projecteurs</label>
                            <input type="number" id="ws-proj-h" value="2" min="1" max="20" onchange="calculateWS()">
                        </div>
                        <div class="ws-input-group">
                            <label>R√©solution</label>
                            <select id="ws-resolution" onchange="calculateWS()">
                                <option value="1920x1080">1920 x 1080</option>
                                <option value="1920x1200">1920 x 1200</option>
                                <option value="3840x2160">3840 x 2160</option>
                                <option value="3840x2400">3840 x 2400</option>
                                <option value="4096x2160">4096 x 2160</option>
                            </select>
                        </div>
                        <div class="ws-input-group">
                            <label id="ws-overlap-label">Overlap (px)</label>
                            <input type="number" id="ws-overlap" value="600" min="0" max="1000" onchange="calculateWS()">
                        </div>
                    </div>
                    <div class="ws-input-grid" style="margin-top:10px;" id="ws-vertical-row">
                        <div class="ws-input-group" id="ws-proj-v-group">
                            <label id="ws-proj-v-label">N. Proj. Vertical</label>
                            <input type="number" id="ws-proj-v" value="1" min="1" max="10" onchange="calculateWS()">
                        </div>
                        <div class="ws-input-group" id="ws-overlap-v-group">
                            <label>Overlap V (px)</label>
                            <input type="number" id="ws-overlap-v" value="0" min="0" max="1000" onchange="calculateWS()">
                        </div>
                        <div class="ws-input-group">
                            <label>Auto Mode</label>
                            <input type="checkbox" id="ws-auto-mode" onchange="calculateWS()" style="width:auto;">
                        </div>
                    </div>
                    <!-- Square mode layout selector -->
                    <div class="ws-input-grid" style="margin-top:10px; display:none;" id="ws-square-selector">
                        <div class="ws-input-group" style="grid-column: span 3;">
                            <label>Configuration Carr√©e</label>
                            <select id="ws-square-config" onchange="setSquareConfig()">
                                <option value="2x2">2 x 2 (4 projecteurs)</option>
                                <option value="4x4">4 x 4 (16 projecteurs)</option>
                                <option value="6x6">6 x 6 (36 projecteurs)</option>
                                <option value="8x8">8 x 8 (64 projecteurs)</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Screen Configuration -->
                <div class="ws-section">
                    <div class="ws-section-title">üì∫ √âcran</div>
                    <div class="ws-input-grid">
                        <div class="ws-input-group">
                            <label>Largeur (<span class="ws-unit">m</span>)</label>
                            <input type="number" id="ws-screen-w" value="18.00" step="0.1" min="1" onchange="calculateWS()">
                        </div>
                        <div class="ws-input-group">
                            <label>Hauteur (<span class="ws-unit">m</span>)</label>
                            <input type="number" id="ws-screen-h" value="6.00" step="0.1" min="1" onchange="calculateWS()">
                        </div>
                        <div class="ws-input-group">
                            <label>Ratio</label>
                            <input type="number" id="ws-screen-ratio" value="3.00" step="0.01" readonly style="background:#1a1a1a;">
                        </div>
                    </div>
                </div>

                <!-- Projector Configuration -->
                <div class="ws-section">
                    <div class="ws-section-title">üìΩÔ∏è Projecteur</div>
                    <div class="ws-input-grid">
                        <div class="ws-input-group">
                            <label>Lens Factor</label>
                            <input type="number" id="ws-lens-factor" value="1.36" step="0.01" min="0.3" max="6" onchange="calculateWS()">
                        </div>
                        <div class="ws-input-group">
                            <label>Throw Ratio Calc</label>
                            <input type="text" id="ws-throw-calc" readonly style="background:#1a1a1a;">
                        </div>
                        <div class="ws-input-group">
                            <label>Lumens</label>
                            <input type="number" id="ws-lumens" value="20000" step="1000" min="1000" onchange="calculateWS()">
                        </div>
                    </div>
                    <div class="ws-input-grid" style="margin-top:10px;">
                        <div class="ws-input-group">
                            <label>Hauteur Proj. (<span class="ws-unit">m</span>)</label>
                            <input type="number" id="ws-proj-height" value="0" step="0.1" onchange="calculateWS()">
                        </div>
                        <div class="ws-input-group">
                            <label>Distance √âcran (<span class="ws-unit">m</span>)</label>
                            <input type="number" id="ws-proj-distance" value="12" step="0.5" min="1" onchange="calculateWS()">
                        </div>
                        <div class="ws-input-group">
                            <label>Position √âcran Z</label>
                            <input type="number" id="ws-screen-z" value="0" step="0.5" readonly style="background:#1a1a1a;">
                        </div>
                    </div>
                </div>

                <!-- Results -->
                <div class="ws-result-grid">
                    <div class="ws-result-box">
                        <h4>Picture Info</h4>
                        <div class="ws-result-row">
                            <span class="label">R√©solution Totale:</span>
                            <span class="value" id="ws-res-total">3240 x 1080 px</span>
                        </div>
                        <div class="ws-result-row">
                            <span class="label">Pixel Size:</span>
                            <span class="value" id="ws-pixel-size">5.56 mm</span>
                        </div>
                        <div class="ws-result-row">
                            <span class="label">Lost Image:</span>
                            <span class="value" id="ws-lost-image">0.00 m¬≤</span>
                        </div>
                    </div>
                    <div class="ws-result-box">
                        <h4>Projector Info</h4>
                        <div class="ws-result-row">
                            <span class="label">Total Size:</span>
                            <span class="value" id="ws-total-size">10.67 x 6.00 m</span>
                        </div>
                        <div class="ws-result-row">
                            <span class="label">Util Size:</span>
                            <span class="value" id="ws-util-size">10.67 x 6.00 m</span>
                        </div>
                        <div class="ws-result-row">
                            <span class="label">Lens Axis:</span>
                            <span class="value" id="ws-lens-axis">x: 5.33 y: 3.00 m</span>
                        </div>
                        <div class="ws-result-row">
                            <span class="label">Lux (lm/m¬≤):</span>
                            <span class="value" id="ws-lux">468.75</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="widescreen-modal-footer">
                <button onclick="closeWidescreenCalculator()" style="background:#444; border:none; color:#ccc; padding:8px 16px; border-radius:4px; cursor:pointer;">Fermer</button>
                <button onclick="openBlueprintModal()" style="background:#1e3a5f; border:none; color:white; padding:8px 16px; border-radius:4px; cursor:pointer;">üìê Blueprint</button>
                <button onclick="openTestPatternModal()" style="background:#7c3aed; border:none; color:white; padding:8px 16px; border-radius:4px; cursor:pointer;">üéØ Mires</button>
                <button onclick="applyWSCalculation()" style="background:#0d9488; border:none; color:white; padding:8px 16px; border-radius:4px; cursor:pointer;">Appliquer √† la Sc√®ne</button>
            </div>
        </div>
    </div>

    <!-- Blueprint Modal -->
    <div id="blueprint-modal">
        <div class="blueprint-content">
            <div class="blueprint-header">
                <h2>üìê Blueprint - Plan de Projection</h2>
                <button class="projector-modal-close" onclick="closeBlueprintModal()" style="color:#fff;">&times;</button>
            </div>
            <canvas id="blueprint-canvas" width="1100" height="800" class="blueprint-canvas"></canvas>
            <div style="padding:12px; background:#1a1a1a; display:flex; justify-content:flex-end; gap:10px;">
                <button onclick="downloadBlueprint()" style="background:#0d9488; border:none; color:white; padding:8px 16px; border-radius:4px; cursor:pointer;">üíæ T√©l√©charger PNG</button>
                <button onclick="closeBlueprintModal()" style="background:#444; border:none; color:#ccc; padding:8px 16px; border-radius:4px; cursor:pointer;">Fermer</button>
            </div>
        </div>
    </div>

    <!-- Test Pattern Modal -->
    <div id="testpattern-modal">
        <div class="testpattern-content">
            <div class="widescreen-modal-header">
                <h2 class="widescreen-modal-title">üéØ Mires de Test - Test Patterns</h2>
                <button class="projector-modal-close" onclick="closeTestPatternModal()">&times;</button>
            </div>
            <div class="testpattern-preview" id="testpattern-preview">
                <!-- Patterns will be generated here -->
            </div>
            <div style="padding:12px; background:#1a1a1a; display:flex; justify-content:flex-end; gap:10px;">
                <button onclick="downloadAllPatterns()" style="background:#0d9488; border:none; color:white; padding:8px 16px; border-radius:4px; cursor:pointer;">üíæ T√©l√©charger Tous</button>
                <button onclick="closeTestPatternModal()" style="background:#444; border:none; color:#ccc; padding:8px 16px; border-radius:4px; cursor:pointer;">Fermer</button>
            </div>
        </div>
    </div>

    <!-- Transform Parameters Floating Window -->
    <div id="transform-params" class="floating-window">
        <div class="floating-window-header">
            <h3>‚öôÔ∏è Transform</h3>
            <button class="floating-window-close" onclick="toggleFloatingWindow('transform-params')">&times;</button>
        </div>

        <div class="param-section">
            <div class="param-section-title">Position</div>
            <div class="param-row">
                <div class="param-input">
                    <label>X</label>
                    <input type="number" id="pos-x" step="0.1" onchange="updateTransformFromInputs()">
                </div>
                <div class="param-input">
                    <label>Y</label>
                    <input type="number" id="pos-y" step="0.1" onchange="updateTransformFromInputs()">
                </div>
                <div class="param-input">
                    <label>Z</label>
                    <input type="number" id="pos-z" step="0.1" onchange="updateTransformFromInputs()">
                </div>
            </div>
        </div>

        <div class="param-section">
            <div class="param-section-title">Rotation (degr√©s) <span style="font-size:7px;color:#666;">[Shift = 15¬∞]</span></div>
            <div class="param-row">
                <div class="param-input">
                    <label>X</label>
                    <input type="number" id="rot-x" step="1" onchange="updateTransformFromInputs()">
                </div>
                <div class="param-input">
                    <label>Y</label>
                    <input type="number" id="rot-y" step="1" onchange="updateTransformFromInputs()">
                </div>
                <div class="param-input">
                    <label>Z</label>
                    <input type="number" id="rot-z" step="1" onchange="updateTransformFromInputs()">
                </div>
            </div>
        </div>

        <div class="param-section">
            <div class="param-section-title">Scale</div>
            <div class="param-row">
                <div class="param-input">
                    <label>X</label>
                    <input type="number" id="scale-x" step="0.1" min="0.01" onchange="updateTransformFromInputs()">
                </div>
                <div class="param-input">
                    <label>Y</label>
                    <input type="number" id="scale-y" step="0.1" min="0.01" onchange="updateTransformFromInputs()">
                </div>
                <div class="param-input">
                    <label>Z</label>
                    <input type="number" id="scale-z" step="0.1" min="0.01" onchange="updateTransformFromInputs()">
                </div>
            </div>
        </div>

        <button onclick="resetTransform()">Reset Transform</button>
    </div>

    <!-- Projector Creation Modal -->
    <div id="projector-modal">
        <div class="projector-modal-content" style="max-width:800px;">
            <div class="projector-modal-header">
                <h2 class="projector-modal-title">üìΩÔ∏è Cr√©er un Projecteur</h2>
                <button class="projector-modal-close" onclick="closeProjectorModal()">&times;</button>
            </div>
            <div class="projector-modal-body">
                <!-- Brand Tabs -->
                <div class="brand-tabs">
                    <div class="brand-tab active" data-brand="panasonic" onclick="selectBrand('panasonic')">Panasonic</div>
                    <div class="brand-tab" data-brand="epson" onclick="selectBrand('epson')">Epson</div>
                    <div class="brand-tab" data-brand="barco" onclick="selectBrand('barco')">Barco</div>
                    <div class="brand-tab" data-brand="optoma" onclick="selectBrand('optoma')">Optoma</div>
                </div>
                
                <!-- Panasonic -->
                <div class="brand-grid active" id="brand-panasonic">
                    <div class="projector-section-title">Mod√®les 4K (DLP)</div>
                    <div class="projector-grid" id="projector-panasonic-4k"></div>
                    <div class="projector-section-title" style="margin-top:16px;">Mod√®les WUXGA</div>
                    <div class="projector-grid" id="projector-panasonic-wuxga"></div>
                </div>
                
                <!-- Epson -->
                <div class="brand-grid" id="brand-epson">
                    <div class="projector-section-title">Mod√®les Laser 4K</div>
                    <div class="projector-grid" id="projector-epson-4k"></div>
                    <div class="projector-section-title" style="margin-top:16px;">Mod√®les WUXGA</div>
                    <div class="projector-grid" id="projector-epson-wuxga"></div>
                    <div class="projector-section-title" style="margin-top:16px;">Mod√®les Short-Throw</div>
                    <div class="projector-grid" id="projector-epson-shortthrow"></div>
                </div>
                
                <!-- Barco -->
                <div class="brand-grid" id="brand-barco">
                    <div class="projector-section-title">S√©rie UDX</div>
                    <div class="projector-grid" id="projector-barco-udx"></div>
                    <div class="projector-section-title" style="margin-top:16px;">S√©rie G</div>
                    <div class="projector-grid" id="projector-barco-g"></div>
                </div>
                
                <!-- Optoma -->
                <div class="brand-grid" id="brand-optoma">
                    <div class="projector-section-title">S√©rie ProScene</div>
                    <div class="projector-grid" id="projector-optoma-proscene"></div>
                    <div class="projector-section-title" style="margin-top:16px;">S√©rie ZU</div>
                    <div class="projector-grid" id="projector-optoma-zu"></div>
                </div>
                
                <div class="projector-section-title" style="margin-top:16px;">Optique</div>
                <div class="lens-grid" id="lens-selection-grid"></div>
            </div>
            <div class="projector-modal-footer">
                <button onclick="closeProjectorModal()" style="background:#444; border:none; color:#ccc; padding:8px 16px; border-radius:4px; cursor:pointer;">Annuler</button>
                <button onclick="confirmProjectorCreation()" style="background:#0d9488; border:none; color:white; padding:8px 16px; border-radius:4px; cursor:pointer;">Cr√©er Projecteur</button>
            </div>
        </div>
    </div>

    <!-- Keystone Floating Window -->
    <div id="keystone-window" class="floating-window" style="width:420px;">
        <div class="floating-window-header">
            <h3>üî≤ Keystone & Corner Pin</h3>
            <button class="floating-window-close" onclick="toggleFloatingWindow('keystone-window')">&times;</button>
        </div>
        
        <!-- Global Keystone -->
        <div style="background:#1a1a1a; padding:10px; border-radius:6px; margin-bottom:10px;">
            <div style="font-size:9px; color:#888; margin-bottom:6px; text-transform:uppercase;">Keystone Global</div>
            <div class="control-row">
                <label>Vertical: <span class="value-display" id="keystone-v-val">0</span></label>
                <input type="range" id="keystone-v" min="-50" max="50" step="1" value="0" oninput="updateKeystone()">
            </div>
            <div class="control-row">
                <label>Horizontal: <span class="value-display" id="keystone-h-val">0</span></label>
                <input type="range" id="keystone-h" min="-50" max="50" step="1" value="0" oninput="updateKeystone()">
            </div>
        </div>
        
        <!-- Individual Corner Control (2D) -->
        <div style="background:#0a0a0a; padding:10px; border-radius:6px; margin-bottom:10px;">
            <div style="font-size:9px; color:#888; margin-bottom:8px; text-transform:uppercase;">Contr√¥le des Coins (2D)</div>
            
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                <!-- Top-Left Corner - Slider 0 = edges -->
                <div style="background:#1a1a1a; padding:8px; border-radius:4px;">
                    <div style="font-size:9px; color:#0d9488; margin-bottom:4px; font-weight:600;">üî∫ HAUT-GAUCHE</div>
                    <div class="control-row" style="margin-bottom:4px;">
                        <label style="font-size:9px;">X: <span class="value-display" id="keystone-tl-x-val">0</span></label>
                        <input type="range" id="keystone-tl-x" min="0" max="200" step="1" value="0" oninput="updateKeystoneCorners()">
                    </div>
                    <div class="control-row" style="margin:0;">
                        <label style="font-size:9px;">Y: <span class="value-display" id="keystone-tl-y-val">0</span></label>
                        <input type="range" id="keystone-tl-y" min="0" max="200" step="1" value="0" oninput="updateKeystoneCorners()">
                    </div>
                </div>
                
                <!-- Top-Right Corner - Slider 0 = edges -->
                <div style="background:#1a1a1a; padding:8px; border-radius:4px;">
                    <div style="font-size:9px; color:#0d9488; margin-bottom:4px; font-weight:600;">üî∫ HAUT-DROIT</div>
                    <div class="control-row" style="margin-bottom:4px;">
                        <label style="font-size:9px;">X: <span class="value-display" id="keystone-tr-x-val">0</span></label>
                        <input type="range" id="keystone-tr-x" min="0" max="200" step="1" value="0" oninput="updateKeystoneCorners()">
                    </div>
                    <div class="control-row" style="margin:0;">
                        <label style="font-size:9px;">Y: <span class="value-display" id="keystone-tr-y-val">0</span></label>
                        <input type="range" id="keystone-tr-y" min="0" max="200" step="1" value="0" oninput="updateKeystoneCorners()">
                    </div>
                </div>
                
                <!-- Bottom-Left Corner - Slider 0 = edges -->
                <div style="background:#1a1a1a; padding:8px; border-radius:4px;">
                    <div style="font-size:9px; color:#0d9488; margin-bottom:4px; font-weight:600;">üîª BAS-GAUCHE</div>
                    <div class="control-row" style="margin-bottom:4px;">
                        <label style="font-size:9px;">X: <span class="value-display" id="keystone-bl-x-val">0</span></label>
                        <input type="range" id="keystone-bl-x" min="0" max="200" step="1" value="0" oninput="updateKeystoneCorners()">
                    </div>
                    <div class="control-row" style="margin:0;">
                        <label style="font-size:9px;">Y: <span class="value-display" id="keystone-bl-y-val">0</span></label>
                        <input type="range" id="keystone-bl-y" min="0" max="200" step="1" value="0" oninput="updateKeystoneCorners()">
                    </div>
                </div>
                
                <!-- Bottom-Right Corner - Slider 0 = edges -->
                <div style="background:#1a1a1a; padding:8px; border-radius:4px;">
                    <div style="font-size:9px; color:#0d9488; margin-bottom:4px; font-weight:600;">üîª BAS-DROIT</div>
                    <div class="control-row" style="margin-bottom:4px;">
                        <label style="font-size:9px;">X: <span class="value-display" id="keystone-br-x-val">0</span></label>
                        <input type="range" id="keystone-br-x" min="0" max="200" step="1" value="0" oninput="updateKeystoneCorners()">
                    </div>
                    <div class="control-row" style="margin:0;">
                        <label style="font-size:9px;">Y: <span class="value-display" id="keystone-br-y-val">0</span></label>
                        <input type="range" id="keystone-br-y" min="0" max="200" step="1" value="0" oninput="updateKeystoneCorners()">
                    </div>
                </div>
            </div>
        </div>
        
        <button class="secondary" onclick="resetKeystone()">Reset All</button>
    </div>

    <!-- Brightness Settings Panel -->
    <div id="brightness-panel" class="floating-window" style="width:380px; top:80px; right:20px; display:none;">
        <div class="floating-window-header">
            <span class="floating-window-title">‚òÄÔ∏è Brightness Settings</span>
            <button class="floating-window-close" onclick="toggleBrightnessPanel()">√ó</button>
        </div>
        <div class="floating-window-content">
            
            <!-- Auto Viewport Range -->
            <div class="control-group">
                <div class="control-header">
                    <label style="font-size:11px; font-weight:600; color:#0d9488;">Auto Viewport Range</label>
                    <label class="toggle-switch" style="margin-left:auto;">
                        <input type="checkbox" id="auto-viewport-range" checked onchange="updateAutoViewportRange()">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div style="font-size:9px; color:#666; margin-top:4px;">
                    Max brightness based on projector illuminance
                </div>
            </div>
            
            <!-- Manual Range (when auto disabled) -->
            <div id="manual-range-controls" class="control-group" style="display:none;">
                <label class="control-label">Manual Max Brightness (Lux)</label>
                <div class="control-row">
                    <input type="range" id="manual-max-lux" min="10" max="5000" step="10" value="250" oninput="updateManualMaxLux(this.value)">
                    <input type="number" id="manual-max-lux-num" value="250" min="10" max="5000" oninput="document.getElementById('manual-max-lux').value=this.value; updateManualMaxLux(this.value);" style="width:70px;">
                    <span style="font-size:10px; color:#888;">Lux</span>
                </div>
            </div>
            
            <!-- Projection Texture -->
            <div class="control-group">
                <label class="control-label">Projection Texture Brightness</label>
                <div class="control-row">
                    <input type="range" id="projection-brightness" min="0" max="10000" step="10" value="0" oninput="updateProjectionBrightness(this.value)">
                    <input type="number" id="projection-brightness-num" value="0" min="0" max="10000" oninput="document.getElementById('projection-brightness').value=this.value; updateProjectionBrightness(this.value);" style="width:70px;">
                    <span style="font-size:10px; color:#888;">Lux</span>
                </div>
                <div style="font-size:9px; color:#666; margin-top:4px;">
                    Global effect - reveals all projected textures
                </div>
            </div>
            
            <!-- Ambient Light -->
            <div class="control-group">
                <label class="control-label">Ambient Light</label>
                <div class="control-row">
                    <input type="range" id="ambient-light" min="0" max="1000" step="1" value="50" oninput="updateAmbientLight(this.value)">
                    <input type="number" id="ambient-light-num" value="50" min="0" max="1000" oninput="document.getElementById('ambient-light').value=this.value; updateAmbientLight(this.value);" style="width:70px;">
                    <span style="font-size:10px; color:#888;">Lux</span>
                </div>
                <div style="font-size:9px; color:#666; margin-top:4px;">
                    Light emitted equally from all directions
                </div>
            </div>
            
            <!-- Directional Light -->
            <div class="control-group">
                <label class="control-label">Directional Light</label>
                <div class="control-row">
                    <input type="range" id="directional-light" min="0" max="1000" step="1" value="0" oninput="updateDirectionalLight(this.value)">
                    <input type="number" id="directional-light-num" value="0" min="0" max="1000" oninput="document.getElementById('directional-light').value=this.value; updateDirectionalLight(this.value);" style="width:70px;">
                    <span style="font-size:10px; color:#888;">Lux</span>
                </div>
                
                <!-- Yaw -->
                <div class="control-row" style="margin-top:8px;">
                    <label style="font-size:10px; color:#888; width:60px;">Yaw:</label>
                    <input type="range" id="directional-yaw" min="0" max="360" step="1" value="0" oninput="updateDirectionalLight()">
                    <input type="number" id="directional-yaw-num" value="0" min="0" max="360" oninput="document.getElementById('directional-yaw').value=this.value; updateDirectionalLight();" style="width:60px;">
                    <span style="font-size:10px; color:#888;">¬∞</span>
                </div>
                
                <!-- Pitch -->
                <div class="control-row" style="margin-top:4px;">
                    <label style="font-size:10px; color:#888; width:60px;">Pitch:</label>
                    <input type="range" id="directional-pitch" min="-90" max="90" step="1" value="45" oninput="updateDirectionalLight()">
                    <input type="number" id="directional-pitch-num" value="45" min="-90" max="90" oninput="document.getElementById('directional-pitch').value=this.value; updateDirectionalLight();" style="width:60px;">
                    <span style="font-size:10px; color:#888;">¬∞</span>
                </div>
                
                <div style="font-size:9px; color:#666; margin-top:4px;">
                    Light from single source with direction
                </div>
            </div>
            
        </div>
    </div>
    
    <!-- Corner Pin Visual Editor Window -->
    <div id="cornerpin-window" class="floating-window" style="width:420px; top:80px; right:340px;">
        <div class="floating-window-header">
            <h3>üìê Corner Pin Visual Editor</h3>
            <button class="floating-window-close" onclick="toggleFloatingWindow('cornerpin-window')">&times;</button>
        </div>
        
        <!-- Visual Corner Pin Editor -->
        <div style="margin-bottom:12px; background:#0a0a0a; border-radius:6px; padding:12px;">
            <div style="font-size:9px; color:#888; margin-bottom:8px; text-transform:uppercase;">Visual Editor</div>
            <div id="cornerpin-visual" style="position:relative; width:100%; aspect-ratio:16/9; background:#1a1a1a; border:2px solid #333; border-radius:4px;">
                <!-- Handles will be created here by JavaScript -->
            </div>
            <div style="font-size:8px; color:#666; margin-top:6px; text-align:center;">
                Drag corners to adjust ‚Ä¢ Use arrow keys for precision ‚Ä¢ Shift = 10x speed
            </div>
        </div>
        
        <div style="margin-top:8px; padding:8px; background:#1a1a1a; border-radius:4px; font-size:8px; color:#666;">
            <strong style="color:#0d9488;">üí° Pro Tip:</strong> Use this visual editor for intuitive corner adjustment, then fine-tune with the Keystone sliders.
        </div>
    </div>

    <!-- Projector Stack Floating Window -->
    <div id="stack-window" class="floating-window" style="width:380px; top:80px; right:680px;">
        <div class="floating-window-header">
            <h3>üìö Projector Stack</h3>
            <button class="floating-window-close" onclick="toggleFloatingWindow('stack-window')">&times;</button>
        </div>
        
        <div style="margin-bottom:16px;">
            <div class="control-row">
                <label>Dummy Projectors: <span class="value-display" id="stack-count-val">0</span></label>
                <input type="range" id="stack-count" min="0" max="10" step="1" value="0" oninput="updateStackCount()">
            </div>
            <div style="margin-top:8px; padding:8px; background:#0d2520; border-left:3px solid #0d9488; border-radius:4px;">
                <div style="font-size:10px; color:#666; margin-bottom:2px;">Total Output:</div>
                <div style="font-size:16px; font-weight:bold; color:#0d9488;">
                    <span id="stack-total-lumens">25,000</span> lumens
                </div>
                <div style="font-size:8px; color:#666; margin-top:2px;">
                    <span id="stack-multiplier">1</span>x base projector
                </div>
            </div>
        </div>
        
        <div style="margin-bottom:12px; background:#0a0a0a; border-radius:6px; padding:12px;">
            <div style="font-size:9px; color:#888; margin-bottom:8px; text-transform:uppercase;">Offset Position</div>
            <div class="control-row">
                <label>X Offset: <span class="value-display" id="stack-offset-x-val">0.00</span>m</label>
                <input type="range" id="stack-offset-x" min="-2" max="2" step="0.01" value="0" oninput="updateStackOffset()">
            </div>
            <div class="control-row">
                <label>Y Offset: <span class="value-display" id="stack-offset-y-val">0.00</span>m</label>
                <input type="range" id="stack-offset-y" min="-2" max="2" step="0.01" value="0" oninput="updateStackOffset()">
            </div>
            <div class="control-row">
                <label>Z Offset: <span class="value-display" id="stack-offset-z-val">0.00</span>m</label>
                <input type="range" id="stack-offset-z" min="-2" max="2" step="0.01" value="0" oninput="updateStackOffset()">
            </div>
        </div>
        
        <div style="margin-bottom:12px; background:#0a0a0a; border-radius:6px; padding:12px;">
            <div style="font-size:9px; color:#888; margin-bottom:8px; text-transform:uppercase;">Stack Settings</div>
            <div class="checkbox-row">
                <input type="checkbox" id="stack-auto-lumens" checked onchange="updateStackSettings()">
                <span>Auto Lumens Multiplication</span>
            </div>
            <div class="checkbox-row">
                <input type="checkbox" id="stack-visible" checked onchange="updateStackSettings()">
                <span>Visible</span>
            </div>
            <div class="checkbox-row">
                <input type="checkbox" id="stack-powered" checked onchange="updateStackSettings()">
                <span>Powered</span>
            </div>
        </div>
        
        <div style="margin-top:8px; padding:8px; background:#1a1a1a; border-radius:4px; font-size:8px; color:#666;">
            <strong style="color:#0d9488;">üí° Stack Info:</strong> Stack multiple virtual projectors to simulate higher lumen output. Auto Lumens multiplies the effective brightness.
        </div>
    </div>

    <!-- Soft Edge Floating Window -->
    <div id="softedge-window" class="floating-window">
        <div class="floating-window-header">
            <h3>üå´Ô∏è Soft Edge</h3>
            <button class="floating-window-close" onclick="toggleFloatingWindow('softedge-window')">&times;</button>
        </div>
        <div class="control-row">
            <label>Gauche: <span class="value-display" id="softedge-l-val">0%</span></label>
            <input type="range" id="softedge-l" min="0" max="50" step="1" value="0" oninput="updateSoftEdge()">
        </div>
        <div class="control-row">
            <label>Droite: <span class="value-display" id="softedge-r-val">0%</span></label>
            <input type="range" id="softedge-r" min="0" max="50" step="1" value="0" oninput="updateSoftEdge()">
        </div>
        <div class="control-row">
            <label>Haut: <span class="value-display" id="softedge-t-val">0%</span></label>
            <input type="range" id="softedge-t" min="0" max="50" step="1" value="0" oninput="updateSoftEdge()">
        </div>
        <div class="control-row">
            <label>Bas: <span class="value-display" id="softedge-b-val">0%</span></label>
            <input type="range" id="softedge-b" min="0" max="50" step="1" value="0" oninput="updateSoftEdge()">
        </div>
        <div class="control-row">
            <label>Gamma Blend: <span class="value-display" id="softedge-gamma-val">2.2</span></label>
            <input type="range" id="softedge-gamma" min="1.0" max="3.0" step="0.1" value="2.2" oninput="updateSoftEdge()">
        </div>
        <button class="secondary" onclick="resetSoftEdge()" style="margin-top:8px;">Reset Soft Edge</button>
    </div>

    <!-- Custom Screen Modal Window -->
    <div id="custom-screen-modal" class="floating-window" style="width:360px; top:50%; left:50%; transform:translate(-50%, -50%); display:none;">
        <div class="floating-window-header">
            <h3>üì∫ √âcran Personnalis√©</h3>
            <button class="floating-window-close" onclick="closeCustomScreenModal()">&times;</button>
        </div>
        
        <div style="padding:4px;">
            <div style="margin-bottom:16px;">
                <label style="display:block; font-size:11px; color:#888; margin-bottom:8px;">Largeur de l'√©cran (m√®tres)</label>
                <input type="number" id="custom-screen-width" 
                       min="0.1" max="100" step="0.1" value="4.0"
                       style="width:100%; padding:10px; background:#1a1a1a; border:1px solid #333; border-radius:6px; color:#e0e0e0; font-size:14px;">
            </div>
            
            <div style="margin-bottom:16px; padding:10px; background:#0d2520; border-left:3px solid #0d9488; border-radius:4px;">
                <div style="font-size:10px; color:#666; margin-bottom:4px;">Dimensions calcul√©es:</div>
                <div style="font-size:13px; color:#0d9488;">
                    <span id="screen-preview-width">4.0</span>m √ó <span id="screen-preview-height">2.25</span>m
                </div>
                <div style="font-size:9px; color:#666; margin-top:2px;">
                    Ratio: 16:9
                </div>
            </div>
            
            <div style="display:flex; gap:8px;">
                <button onclick="closeCustomScreenModal()" 
                        style="flex:1; padding:10px; background:#333; border:none; border-radius:6px; color:#e0e0e0; cursor:pointer; font-size:13px;">
                    Annuler
                </button>
                <button onclick="createCustomScreen()" 
                        style="flex:1; padding:10px; background:#0d9488; border:none; border-radius:6px; color:white; cursor:pointer; font-size:13px; font-weight:600;">
                    Cr√©er l'√©cran
                </button>
            </div>
            
            <div style="margin-top:12px; padding:8px; background:#1a1a1a; border-radius:4px; font-size:8px; color:#666;">
                <strong style="color:#0d9488;">üí° Astuce:</strong> L'√©cran sera cr√©√© √† la position de la target du projecteur actif, ou √† (0, 2.5, 0) par d√©faut.
            </div>
        </div>
    </div>

    <!-- Photometric Analysis Floating Window -->
    <div id="photometric-window" class="floating-window" style="width:380px; top:80px; right:340px;">
        <div class="floating-window-header">
            <h3>üí° Photometric Analysis</h3>
            <button class="floating-window-close" onclick="toggleFloatingWindow('photometric-window')">&times;</button>
        </div>
        
        <!-- Enable/Disable Toggle -->
        <div style="margin-bottom:12px;">
            <button id="photometric-toggle" onclick="togglePhotometric()" style="width:100%; padding:10px; background:#0d9488;">
                ‚úÖ Enable Analysis Mode
            </button>
        </div>
        
        <!-- Analysis Settings -->
        <div id="photometric-settings" style="display:none;">
            <!-- Scale Settings -->
            <div style="background:#1a1a1a; padding:10px; border-radius:6px; margin-bottom:10px;">
                <div style="font-size:9px; color:#0d9488; margin-bottom:8px; font-weight:600; text-transform:uppercase;">üìä Scale Settings</div>
                
                <div class="control-row">
                    <label>Scale Max: <span class="value-display" id="photo-scale-max-val">1000</span> lux</label>
                    <input type="range" id="photo-scale-max" min="100" max="5000" step="100" value="1000" oninput="updatePhotometric()">
                </div>
                
                <div style="display:flex; gap:8px; margin-top:8px;">
                    <label style="display:flex; align-items:center; gap:6px; flex:1; font-size:10px;">
                        <input type="checkbox" id="photo-scale-log" onchange="updatePhotometric()">
                        <span>Logarithmic Scale</span>
                    </label>
                    <label style="display:flex; align-items:center; gap:6px; flex:1; font-size:10px;">
                        <input type="checkbox" id="photo-shader-log" onchange="updatePhotometric()">
                        <span>Shader Log Mode</span>
                    </label>
                </div>
            </div>
            
            <!-- Ambient Light -->
            <div style="background:#1a1a1a; padding:10px; border-radius:6px; margin-bottom:10px;">
                <div style="font-size:9px; color:#0d9488; margin-bottom:8px; font-weight:600; text-transform:uppercase;">üåû Environmental Light</div>
                
                <div class="control-row">
                    <label>Ambient Light: <span class="value-display" id="photo-ambient-val">0</span> lux</label>
                    <input type="range" id="photo-ambient" min="0" max="500" step="5" value="0" oninput="updatePhotometric()">
                </div>
                
                <div class="control-row">
                    <label>Directional Light: <span class="value-display" id="photo-directional-val">0</span> lux</label>
                    <input type="range" id="photo-directional" min="0" max="1000" step="10" value="0" oninput="updatePhotometric()">
                </div>
            </div>
            
            <!-- Material Properties -->
            <div style="background:#1a1a1a; padding:10px; border-radius:6px; margin-bottom:10px;">
                <div style="font-size:9px; color:#0d9488; margin-bottom:8px; font-weight:600; text-transform:uppercase;">üé® Material Properties</div>
                
                <div class="control-row">
                    <label>Material Gain: <span class="value-display" id="photo-gain-val">1.0</span></label>
                    <input type="range" id="photo-gain" min="0.1" max="2.0" step="0.05" value="1.0" oninput="updatePhotometric()">
                </div>
                
                <div style="font-size:8px; color:#666; margin-top:6px;">
                    Matte White: 1.0 ‚Ä¢ Screen: 1.2-1.5 ‚Ä¢ High Gain: 1.8-2.0
                </div>
            </div>
        </div>
    </div>

    <!-- Photometric Results Panel (Always Visible when enabled) -->
    <div id="photometric-results" class="floating-window" style="width:280px; top:400px; right:340px; display:none;">
        <div class="floating-window-header">
            <h3>üìà Photometric Results</h3>
            <button class="floating-window-close" onclick="closePhotometricResults()">&times;</button>
        </div>
        
        <!-- Real-time Results -->
        <div style="background:#0a0a0a; padding:12px; border-radius:6px; margin-bottom:10px;">
            <div style="display:grid; gap:8px;">
                <!-- Illuminance -->
                <div style="background:#1a1a1a; padding:8px; border-radius:4px;">
                    <div style="font-size:9px; color:#0d9488; margin-bottom:4px; font-weight:600;">ILLUMINANCE</div>
                    <div style="font-size:18px; color:#06d6a0; font-weight:700;" id="photo-result-illuminance">--- lux</div>
                    <div style="font-size:8px; color:#888; margin-top:2px;">At target point</div>
                </div>
                
                <!-- Luminance -->
                <div style="background:#1a1a1a; padding:8px; border-radius:4px;">
                    <div style="font-size:9px; color:#0d9488; margin-bottom:4px; font-weight:600;">LUMINANCE</div>
                    <div style="font-size:18px; color:#06d6a0; font-weight:700;" id="photo-result-luminance">--- cd/m¬≤</div>
                    <div style="font-size:8px; color:#888; margin-top:2px;">Surface brightness</div>
                </div>
                
                <!-- Pixel Size -->
                <div style="background:#1a1a1a; padding:8px; border-radius:4px;">
                    <div style="font-size:9px; color:#0d9488; margin-bottom:4px; font-weight:600;">PIXEL SIZE</div>
                    <div style="font-size:18px; color:#06d6a0; font-weight:700;" id="photo-result-pixelsize">--- mm</div>
                    <div style="font-size:8px; color:#888; margin-top:2px;">At projection distance</div>
                </div>
                
                <!-- Contrast Ratio -->
                <div style="background:#1a1a1a; padding:8px; border-radius:4px;">
                    <div style="font-size:9px; color:#0d9488; margin-bottom:4px; font-weight:600;">CONTRAST RATIO</div>
                    <div style="font-size:18px; color:#06d6a0; font-weight:700;" id="photo-result-contrast">---:1</div>
                    <div style="font-size:8px; color:#888; margin-top:2px;">Projection vs ambient</div>
                </div>
            </div>
        </div>
        
        <!-- Info -->
        <div style="padding:8px; background:#1a1a1a; border-radius:4px; font-size:8px; color:#666;">
            <strong style="color:#0d9488;">‚ÑπÔ∏è Note:</strong> Results calculated using IES photometric standards. Move projector or target to update.
        </div>
    </div>

    <!-- Scene Parameters Floating Window -->
    <div id="scene-params-window" class="floating-window">
        <div class="floating-window-header">
            <h3>‚öôÔ∏è Param√®tres Sc√®ne</h3>
            <button class="floating-window-close" onclick="toggleFloatingWindow('scene-params-window')">&times;</button>
        </div>
        <div class="control-row">
            <label>Shadow Softness (Global): <span class="value-display" id="scene-shadow-softness-val">1.0</span></label>
            <input type="range" id="scene-shadow-softness" min="0" max="3" step="0.1" value="1.0" oninput="updateSceneShadowQuality()">
        </div>
        <div class="control-row">
            <label>Shadow Bias (Global): <span class="value-display" id="scene-shadow-bias-val">0.003</span></label>
            <input type="range" id="scene-shadow-bias" min="0.0001" max="0.01" step="0.0001" value="0.003" oninput="updateSceneShadowQuality()">
        </div>
        <div class="control-row">
            <label>High Quality PCF:</label>
            <input type="checkbox" id="scene-hq-pcf" checked onchange="updateSceneShadowQuality()">
        </div>
        <div style="margin-top:10px; padding-top:10px; border-top:1px solid #333;">
            <div style="font-size:9px; color:#888; margin-bottom:6px;">INFORMATIONS SC√àNE</div>
            <div style="font-size:10px;">Projecteurs: <span id="scene-projector-count">0</span></div>
            <div style="font-size:10px;">Objets: <span id="scene-object-count">0</span></div>
        </div>
    </div>

    <!-- Photometric Analysis Floating Window -->
    <div id="photometric-window" class="floating-window">
        <div class="floating-window-header">
            <h3>üí° Analyse Photom√©trique</h3>
            <button class="floating-window-close" onclick="toggleFloatingWindow('photometric-window')">&times;</button>
        </div>
        <div class="photometric-grid">
            <div class="photometric-result">
                <div class="photometric-value" id="photo-lux">0</div>
                <div class="photometric-label">Lux (√©clairement)</div>
            </div>
            <div class="photometric-result">
                <div class="photometric-value" id="photo-lumens">0</div>
                <div class="photometric-label">Lumens</div>
            </div>
            <div class="photometric-result">
                <div class="photometric-value" id="photo-coverage">0</div>
                <div class="photometric-label">Couverture (m¬≤)</div>
            </div>
            <div class="photometric-result">
                <div class="photometric-value" id="photo-ratio">0</div>
                <div class="photometric-label">Throw Ratio</div>
            </div>
        </div>
        <div style="margin-top:10px; padding-top:10px; border-top:1px solid #333;">
            <div class="control-row">
                <label>Gain √âcran: <span class="value-display" id="screen-gain-val">1.0</span></label>
                <input type="range" id="screen-gain" min="0.5" max="2.5" step="0.1" value="1.0" oninput="updatePhotometrics()">
            </div>
            <div class="control-row">
                <label>Ambient Light (lux): <span class="value-display" id="ambient-light-val">0</span></label>
                <input type="range" id="ambient-light" min="0" max="500" step="10" value="0" oninput="updatePhotometrics()">
            </div>
        </div>
        <div style="margin-top:10px; padding:8px; background:#1a1a1a; border-radius:4px; font-size:9px;">
            <div style="color:#0d9488; margin-bottom:4px;">RECOMMANDATIONS</div>
            <div id="photo-recommendations">-</div>
        </div>
        <button onclick="updatePhotometrics()" style="margin-top:8px;">üîÑ Actualiser</button>
    </div>

    <!-- Export PDF Floating Window -->
    <div id="export-window" class="floating-window">
        <div class="floating-window-header">
            <h3>üìÑ Export PDF</h3>
            <button class="floating-window-close" onclick="toggleFloatingWindow('export-window')">&times;</button>
        </div>
        <div style="margin-bottom:12px;">
            <div style="font-size:9px; color:#888; margin-bottom:6px; text-transform:uppercase;">Options d'export</div>
            <label style="display:flex; align-items:center; gap:6px; font-size:10px; margin-bottom:4px;">
                <input type="checkbox" id="export-viewport" checked> Screenshot Viewport
            </label>
            <label style="display:flex; align-items:center; gap:6px; font-size:10px; margin-bottom:4px;">
                <input type="checkbox" id="export-projector-list" checked> Liste des Projecteurs
            </label>
            <label style="display:flex; align-items:center; gap:6px; font-size:10px; margin-bottom:4px;">
                <input type="checkbox" id="export-specs" checked> Sp√©cifications Techniques
            </label>
            <label style="display:flex; align-items:center; gap:6px; font-size:10px; margin-bottom:4px;">
                <input type="checkbox" id="export-photometric"> Analyse Photom√©trique
            </label>
        </div>
        <div style="margin-bottom:12px;">
            <label style="font-size:9px; color:#888;">Titre du Projet:</label>
            <input type="text" id="export-title" value="Projection Setup" style="width:100%; margin-top:4px;">
        </div>
        <div style="margin-bottom:12px;">
            <label style="font-size:9px; color:#888;">Notes:</label>
            <textarea id="export-notes" rows="3" style="width:100%; margin-top:4px; resize:vertical;"></textarea>
        </div>
        <div style="display:flex; gap:8px;">
            <button onclick="renderViewportSnapshot()" style="flex:1;">üì∑ Snapshot PNG</button>
            <button onclick="generatePDFReport()" style="flex:1; background:#0d9488;">üìÑ G√©n√©rer PDF</button>
        </div>
    </div>

    <!-- Primitive Creation Popup -->
    <div id="primitive-popup">
        <!-- Section √âcrans 16:9 -->
        <div style="padding:8px; font-size:10px; color:#0d9488; font-weight:600; text-transform:uppercase;">
            üì∫ √âcrans 16:9
        </div>
        <div class="popup-item" onclick="addScreenSmall()">
            <span class="popup-icon">üì∫</span>
            <span>Petit (3m)</span>
        </div>
        <div class="popup-item" onclick="addScreenMedium()">
            <span class="popup-icon">üì∫</span>
            <span>Moyen (5m)</span>
        </div>
        <div class="popup-item" onclick="addScreenLarge()">
            <span class="popup-icon">üì∫</span>
            <span>Grand (8m)</span>
        </div>
        <div class="popup-item" onclick="addScreenCustom()">
            <span class="popup-icon">üì∫</span>
            <span>Personnalis√©...</span>
        </div>
        <div class="popup-divider"></div>
        
        <!-- Section Primitives -->
        <div style="padding:8px; font-size:10px; color:#888; font-weight:600; text-transform:uppercase;">
            üî∑ Primitives
        </div>
        <div class="popup-item" onclick="addPrimitive('cube')">
            <span class="popup-icon">‚¨õ</span>
            <span>Cube</span>
        </div>
        <div class="popup-item" onclick="addPrimitive('sphere')">
            <span class="popup-icon">‚ö´</span>
            <span>Sph√®re</span>
        </div>
        <div class="popup-item" onclick="addPrimitive('cylinder')">
            <span class="popup-icon">‚¨ú</span>
            <span>Cylindre</span>
        </div>
        <div class="popup-item" onclick="addPrimitive('cone')">
            <span class="popup-icon">üî∫</span>
            <span>C√¥ne</span>
        </div>
        <div class="popup-item" onclick="addPrimitive('torus')">
            <span class="popup-icon">‚≠ï</span>
            <span>Tore</span>
        </div>
        <div class="popup-item" onclick="addPrimitive('plane')">
            <span class="popup-icon">‚ñ≠</span>
            <span>Plan</span>
        </div>
        <div class="popup-divider"></div>
        <div class="popup-item" onclick="addPrimitive('human-realistic')">
            <span class="popup-icon">üßç</span>
            <span>Mannequin Realistic (1.80m)</span>
        </div>
        <div class="popup-item" onclick="addPrimitive('human-lowpoly')">
            <span class="popup-icon">ü§ñ</span>
            <span>Mannequin Low-Poly (1.80m)</span>
        </div>
        <div class="popup-item" onclick="addPrimitive('human-stick')">
            <span class="popup-icon">üï¥Ô∏è</span>
            <span>Mannequin Stick Figure (1.80m)</span>
        </div>
        <div class="popup-divider"></div>
        <div class="popup-item" onclick="addWall()">
            <span class="popup-icon">üß±</span>
            <span>Mur Standard</span>
        </div>
    </div>

    <!-- 3D Model Loader Modal -->
    <div id="model-loader-modal" class="model-modal">
        <div class="model-modal-content">
            <div class="model-modal-header">
                <h2 class="model-modal-title">üìÅ Charger un Mod√®le 3D</h2>
                <button class="model-modal-close" onclick="closeModelLoader()">&times;</button>
            </div>
            <div class="model-modal-body">
                <div class="model-modal-viewport" id="model-preview-viewport"></div>
                <div class="model-modal-controls">
                    <div class="modal-section">
                        <div class="modal-section-title">Fichier</div>
                        <div class="upload-zone" onclick="document.getElementById('model-file-input').click()">
                            <div class="upload-zone-icon">üìÅ</div>
                            <div class="upload-zone-text">Cliquer pour charger</div>
                            <div class="upload-zone-formats">glTF ‚Ä¢ GLB ‚Ä¢ OBJ ‚Ä¢ FBX</div>
                            <input type="file" id="model-file-input" accept=".glb,.gltf,.obj,.fbx" style="display:none" onchange="handleModelFileSelect(event)">
                        </div>
                        <div id="model-load-status" style="margin-top:6px; font-size:10px; color:#888;"></div>
                    </div>
                    
                    <div class="modal-section">
                        <div class="modal-section-title">Axe du Mod√®le</div>
                        <div id="axis-options">
                            <div class="axis-option selected" data-axis="y" onclick="pickAxisOption(this)">
                                <div class="axis-option-title">Y Up (d√©faut)</div>
                                <div class="axis-option-desc">La plupart des moteurs utilisent Y comme haut.</div>
                            </div>
                            <div class="axis-option" data-axis="x" onclick="pickAxisOption(this)">
                                <div class="axis-option-title">X Up</div>
                                <div class="axis-option-desc">Rotation automatique vers Y-Up.</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="modal-section">
                        <div class="modal-section-title">Rotation Rapide (45¬∞)</div>
                        <div class="rotate-controls">
                            <button onclick="rotatePreviewModel('x', -45)">‚óÄ X</button>
                            <button onclick="rotatePreviewModel('x', 45)">X ‚ñ∂</button>
                        </div>
                        <div class="rotate-controls">
                            <button onclick="rotatePreviewModel('y', -45)">‚óÄ Y</button>
                            <button onclick="rotatePreviewModel('y', 45)">Y ‚ñ∂</button>
                        </div>
                        <div class="rotate-controls">
                            <button onclick="rotatePreviewModel('z', -45)">‚óÄ Z</button>
                            <button onclick="rotatePreviewModel('z', 45)">Z ‚ñ∂</button>
                        </div>
                    </div>
                    
                    <div class="modal-section">
                        <div class="modal-section-title">Position du Pivot</div>
                        <button class="pivot-btn active" data-pivot="floor" onclick="pickPivotOption(this)">Centre sur Sol (Drop to Floor)</button>
                        <button class="pivot-btn" data-pivot="center" onclick="pickPivotOption(this)">Centre G√©om√©trique</button>
                        <button class="pivot-btn" data-pivot="origin" onclick="pickPivotOption(this)">Origine du Mod√®le</button>
                    </div>
                    
                    <div class="modal-section">
                        <div class="modal-section-title">Options</div>
                        <label style="display:flex; align-items:center; gap:6px; font-size:10px; margin-bottom:4px;">
                            <input type="checkbox" id="model-auto-scale"> Auto-Scale (max 50m)
                        </label>
                        <label style="display:flex; align-items:center; gap:6px; font-size:10px; margin-bottom:4px;">
                            <input type="checkbox" id="model-cast-shadows" checked> Projeter des ombres
                        </label>
                        <label style="display:flex; align-items:center; gap:6px; font-size:10px;">
                            <input type="checkbox" id="model-wireframe"> Gouraud Shading (lignes)
                        </label>
                    </div>
                </div>
            </div>
            <div class="model-modal-footer">
                <button onclick="closeModelLoader()" style="background:#444; border:none; color:#ccc;">Annuler</button>
                <button onclick="confirmModelLoad()" style="background:#0d9488; border:none; color:white;">Confirmer & Charger</button>
            </div>
        </div>
    </div>

    <div id="controls" class="hidden">
        <div class="projector-model" id="projector-model-display">
            <div class="brand" id="proj-brand">Panasonic</div>
            <div class="model-name" id="proj-model-name">PT-RQ25K</div>
            <div class="specs-summary" id="proj-specs">20,000 lm ‚Ä¢ 4K ‚Ä¢ 16:10</div>
        </div>

        <div class="shader-quality-badge">
            ‚ú® PROFESSIONAL SHADOW-MAPPED SHADER ‚ú®
        </div>

        <div id="selection-info">S√©lection: <span class="selected-name" id="selected-name">Aucun</span></div>

        <div class="throw-display">
            <div class="label">THROW RATIO</div>
            <div class="value" id="throw-ratio-display">1.36:1</div>
            <div class="sub">Distance: <span id="distance-display">10.00</span> m</div>
        </div>

        <div class="control-group">
            <h3>üìê Dimensions Image</h3>
            <div class="measurement-group">
                <div class="measurement-input">
                    <label>Largeur</label>
                    <input type="number" id="image-width" value="7.35" step="0.1" min="1" max="50" onchange="updateFromWidth()">
                    <div class="unit">m√®tres</div>
                </div>
                <div class="measurement-input">
                    <label>Hauteur</label>
                    <input type="number" id="image-height" value="4.59" step="0.1" min="0.5" max="30" onchange="updateFromHeight()">
                    <div class="unit">m√®tres</div>
                </div>
            </div>
            <div class="control-row" style="margin-top:8px;">
                <label>Frustum Far: <span class="value-display" id="frustum-far-val">100.0 m</span></label>
                <input type="range" id="frustum-far" min="0.5" max="500" step="0.1" value="100" oninput="updateFrustumFar()">
            </div>
        </div>

        <div class="control-group">
            <h3>üî≠ Optique</h3>
            <select id="lens-select" onchange="changeLens()">
                <option value="ET-D3LEU100">ET-D3LEU100 (0.36:1)</option>
                <option value="ET-D3LEW200">ET-D3LEW200 (0.48-0.55:1)</option>
                <option value="ET-D3LEW60">ET-D3LEW60 (0.68-0.80:1)</option>
                <option value="ET-D75LE6">ET-D75LE6 (0.90-1.10:1)</option>
                <option value="ET-D3LEW10">ET-D3LEW10 (1.01-1.30:1)</option>
                <option value="ET-D3LES20" selected>ET-D3LES20 (1.36-1.78:1)</option>
                <option value="ET-D3LET80">ET-D3LET80 (1.81-2.56:1)</option>
                <option value="ET-D75LE95">ET-D75LE95 (0.80:1)</option>
            </select>
            <div class="lens-specs">
                <div class="spec-row"><span>Throw:</span><span class="spec-value" id="spec-throw">1.36-1.78:1</span></div>
                <div class="spec-row"><span>Shift V:</span><span class="spec-value" id="spec-shift-v">¬±66%</span></div>
                <div class="spec-row"><span>Shift H:</span><span class="spec-value" id="spec-shift-h">¬±24%</span></div>
            </div>
            <div class="control-row" style="margin-top:6px;">
                <label>Zoom: <span class="value-display" id="zoom-val">1.36:1</span></label>
                <input type="range" id="zoom" min="1.36" max="1.78" step="0.01" value="1.36" oninput="updateZoom()">
            </div>
        </div>

        <div class="control-group">
            <h3>üìê Lens Shift</h3>
            <div class="control-row">
                <label>Vertical: <span class="value-display" id="shift-v-val">0%</span></label>
                <input type="range" id="shift-v" min="-66" max="66" step="1" value="0" oninput="updateLensShift()">
            </div>
            <div class="control-row">
                <label>Horizontal: <span class="value-display" id="shift-h-val">0%</span></label>
                <input type="range" id="shift-h" min="-24" max="24" step="1" value="0" oninput="updateLensShift()">
            </div>
            <button class="secondary" onclick="resetLensShift()">Reset</button>
        </div>

        <div class="control-group">
            <h3>üõ†Ô∏è Outils Avanc√©s</h3>
            <button class="floating-toggle-btn" id="btn-transform" onclick="toggleFloatingWindow('transform-params')">
                ‚öôÔ∏è Transform
            </button>
            <button class="floating-toggle-btn" id="btn-keystone" onclick="toggleFloatingWindow('keystone-window')">
                üî≤ Keystone
            </button>
            <button class="floating-toggle-btn" id="btn-cornerpin" onclick="toggleFloatingWindow('cornerpin-window')">
                üìê Corner Pin Visual
            </button>
            <button class="floating-toggle-btn" id="btn-stack" onclick="toggleFloatingWindow('stack-window')">
                üìö Projector Stack
            </button>
            <button class="floating-toggle-btn" id="btn-softedge" onclick="toggleFloatingWindow('softedge-window')">
                üå´Ô∏è Soft Edge
            </button>
            <button class="floating-toggle-btn" id="btn-photometric" onclick="toggleFloatingWindow('photometric-window')">
                üí° Photometric Analysis
            </button>
        </div>

        <div class="control-group">
            <h3>üí° Projection</h3>
            <div class="control-row">
                <label>Intensit√©: <span class="value-display" id="proj-intensity-val">1.0</span></label>
                <input type="range" id="proj-intensity" min="0" max="2" step="0.1" value="1.0" oninput="updateProjectionIntensity()">
            </div>
        </div>

        <div class="control-group">
            <h3>üéØ Options</h3>
            <div class="checkbox-row">
                <input type="checkbox" id="target-locked" checked onchange="toggleTargetLock()">
                <span>Lock Aim to Target</span>
            </div>
            <div class="checkbox-row">
                <input type="checkbox" id="show-frustum" checked onchange="toggleFrustum()">
                <span>Frustum Helper</span>
            </div>
            <div class="checkbox-row">
                <input type="checkbox" id="show-measurements" checked onchange="toggleMeasurements()">
                <span>Mesures Viewport</span>
            </div>

            <div style="margin-top:8px;">
                <label style="margin-bottom:4px;">Snap Target (d√© de 5):</label>
                <div style="display:flex; align-items:center; gap:8px;">
                    <div class="snap-selector">
                        <button class="snap-btn" data-snap="tl" onclick="setSnapPoint('tl')" title="Haut-gauche"></button>
                        <button class="snap-btn" data-snap="tr" onclick="setSnapPoint('tr')" title="Haut-droite"></button>
                        <button class="snap-btn active" data-snap="c" onclick="setSnapPoint('c')" title="Centre"></button>
                        <button class="snap-btn" data-snap="bl" onclick="setSnapPoint('bl')" title="Bas-gauche"></button>
                        <button class="snap-btn" data-snap="br" onclick="setSnapPoint('br')" title="Bas-droite"></button>
                    </div>
                    <div style="flex:1; display:flex; flex-direction:column; gap:4px;">
                        <button class="secondary" style="margin-top:0;" onclick="setSelectedAsTarget()">Appliquer au centre</button>
                        <button class="secondary" style="margin-top:0;" onclick="showObjectSnapPoints()">Points sur objet</button>
                    </div>
                </div>
                <div id="object-snap-points" class="object-snap-points">
                    <label style="font-size:9px; color:#888;">Points d'ancrage:</label>
                    <div id="snap-points-list" style="display:flex; flex-wrap:wrap; margin-top:4px;"></div>
                </div>
            </div>
        </div>

        <div class="control-group">
            <h3>üñºÔ∏è Contenu</h3>
            <div class="control-row">
                <label>Texture pr√©d√©finie:</label>
                <select id="preset-texture" onchange="loadPresetTexture()" style="margin-bottom:8px;">
                    <option value="">-- Choisir --</option>
                    <option value="uv-grid-full">UV Grid Full HD</option>
                    <option value="uv-grid">UV Grid (Simple)</option>
                    <option value="white">Blanc</option>
                    <option value="checkerboard">Damier</option>
                    <option value="gradient">Gradient</option>
                </select>
            </div>
            <div class="control-row">
                <label>Ou fichier personnalis√©:</label>
                <input type="file" id="image-upload" accept="image/*" onchange="loadImage()">
            </div>
            <button class="secondary" onclick="removeImage()">Enlever</button>
            <div id="image-status"></div>
        </div>

        <div class="control-group">
            <h3>üì¶ Sc√®ne</h3>
            <button id="toggle-projection-btn" onclick="toggleObjectProjection()" style="margin-bottom:8px; background:#444;">
                üé• Toggle Projection
            </button>
            <button class="danger" onclick="clearObjects()">Effacer Tous les Objets</button>
        </div>

        <div class="control-group">
            <h3>‚å®Ô∏è Raccourcis</h3>
            <div class="keyboard-hint">
                <strong>Gizmo:</strong> G = Move ‚Ä¢ R = Rotate ‚Ä¢ S = Scale<br>
                <strong>Rotation:</strong> Shift = Snap 15¬∞<br>
                <strong>Objet:</strong> Del = Supprimer ‚Ä¢ Esc = D√©s√©lectionner
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>

    <script>
    // ========== FUNCTION STUBS (defined later but needed for onclick) ==========
    window.openProjectorModal = function() { console.warn('Not initialized yet'); };
    window.toggleBrightnessPanel = function() { console.warn('Not initialized yet'); };
    window.setCameraView = function() { console.warn('Not initialized yet'); };
    window.openPrimitivePopup = function() { console.warn('Not initialized yet'); };
    window.openModelLoader = function() { console.warn('Not initialized yet'); };
    window.saveProject = function() { console.warn('Not initialized yet'); };
    window.switchTab = function() { console.warn('Not initialized yet'); };
    window.setGizmoMode = function() { console.warn('Not initialized yet'); };
    window.toggleTargetLockForProjector = function() { console.warn('Not initialized yet'); };
    window.changeProjectorTarget = function() { console.warn('Not initialized yet'); };
    window.toggleGrid = function() { console.warn('Not initialized yet'); };
    window.toggleMeasurements = function() { console.warn('Not initialized yet'); };
    window.toggleFloatingWindow = function() { console.warn('Not initialized yet'); };
    window.undo = function() { console.warn('Not initialized yet'); };
    window.redo = function() { console.warn('Not initialized yet'); };
    
    // ========== CONSTANTS ==========
    const ASPECT = 16/10;
    const PROJECTOR_CAMERA_FAR = 100000;

    // ========== PROJECTOR DATABASE ==========
    // Complete Panasonic PT-RQ Series with specifications
    const PROJECTOR_DATABASE = {
        'PT-RQ13K': {
            name: 'PT-RQ13K',
            brand: 'Panasonic',
            lumens: 10000,
            resolution: '5K (5120√ó3200)',
            resolutionPixels: [5120, 3200],
            aspect: 16/10,
            chipSize: '0.9"',
            type: '3-Chip DLP‚Ñ¢',
            contrast: '20,000:1',
            weight: 49.0,
            dimensions: '578√ó270√ó725 mm',
            defaultLens: 'ET-D75LE20',
            compatibleLenses: ['ET-D75LE6', 'ET-D75LE8', 'ET-D75LE10', 'ET-D75LE20', 'ET-D75LE30', 'ET-D75LE40', 'ET-D75LE50', 'ET-D75LE90']
        },
        'PT-RQ18K': {
            name: 'PT-RQ18K',
            brand: 'Panasonic',
            lumens: 16000,
            resolution: '4K (3840√ó2400)',
            resolutionPixels: [3840, 2400],
            aspect: 16/10,
            chipSize: '0.8"',
            type: '3-Chip DLP‚Ñ¢',
            contrast: '25,000:1',
            weight: 35.0,
            dimensions: '550√ó220√ó570 mm',
            defaultLens: 'ET-D3LES20',
            compatibleLenses: ['ET-D3LEU100', 'ET-D3LEW200', 'ET-D3LEW60', 'ET-D75LE6', 'ET-D3LEW10', 'ET-D3LES20', 'ET-D3LET80', 'ET-D75LE95']
        },
        'PT-RQ25K': {
            name: 'PT-RQ25K',
            brand: 'Panasonic',
            lumens: 20000,
            resolution: '4K (3840√ó2400)',
            resolutionPixels: [3840, 2400],
            aspect: 16/10,
            chipSize: '0.8"',
            type: '3-Chip DLP‚Ñ¢',
            contrast: '25,000:1',
            weight: 35.0,
            dimensions: '550√ó220√ó570 mm',
            defaultLens: 'ET-D3LES20',
            compatibleLenses: ['ET-D3LEU100', 'ET-D3LEW200', 'ET-D3LEW60', 'ET-D75LE6', 'ET-D3LEW10', 'ET-D3LES20', 'ET-D3LET80', 'ET-D75LE95']
        },
        'PT-RQ35K': {
            name: 'PT-RQ35K',
            brand: 'Panasonic',
            lumens: 30500,
            resolution: '4K (3840√ó2400)',
            resolutionPixels: [3840, 2400],
            aspect: 16/10,
            chipSize: '0.96"',
            type: '3-Chip DLP‚Ñ¢',
            contrast: '20,000:1',
            weight: 69.8,
            dimensions: '598√ó353√ó780 mm',
            defaultLens: 'ET-D3LES20',
            compatibleLenses: ['ET-D3LEU100', 'ET-D3LEW200', 'ET-D3LEW60', 'ET-D75LE6', 'ET-D3LEW10', 'ET-D3LES20', 'ET-D3LET80', 'ET-D75LE95']
        },
        'PT-RZ24K': {
            name: 'PT-RZ24K',
            brand: 'Panasonic',
            lumens: 20000,
            resolution: 'WUXGA (1920√ó1200)',
            resolutionPixels: [1920, 1200],
            aspect: 16/10,
            chipSize: '0.8"',
            type: '3-Chip DLP‚Ñ¢',
            contrast: '25,000:1',
            weight: 35.0,
            dimensions: '550√ó220√ó570 mm',
            defaultLens: 'ET-D3LES20',
            compatibleLenses: ['ET-D3LEU100', 'ET-D3LEW200', 'ET-D3LEW60', 'ET-D75LE6', 'ET-D3LEW10', 'ET-D3LES20', 'ET-D3LET80', 'ET-D75LE95']
        },
        'PT-RZ17K': {
            name: 'PT-RZ17K',
            brand: 'Panasonic',
            lumens: 16000,
            resolution: 'WUXGA (1920√ó1200)',
            resolutionPixels: [1920, 1200],
            aspect: 16/10,
            chipSize: '0.8"',
            type: '3-Chip DLP‚Ñ¢',
            contrast: '25,000:1',
            weight: 35.0,
            dimensions: '550√ó220√ó570 mm',
            defaultLens: 'ET-D3LES20',
            compatibleLenses: ['ET-D3LEU100', 'ET-D3LEW200', 'ET-D3LEW60', 'ET-D75LE6', 'ET-D3LEW10', 'ET-D3LES20', 'ET-D3LET80', 'ET-D75LE95']
        },
        'PT-RZ34K': {
            name: 'PT-RZ34K',
            brand: 'Panasonic',
            lumens: 30500,
            resolution: 'WUXGA (1920√ó1200)',
            resolutionPixels: [1920, 1200],
            aspect: 16/10,
            chipSize: '0.96"',
            type: '3-Chip DLP‚Ñ¢',
            contrast: '20,000:1',
            weight: 68.6,
            dimensions: '598√ó353√ó780 mm',
            defaultLens: 'ET-D3LES20',
            compatibleLenses: ['ET-D3LEU100', 'ET-D3LEW200', 'ET-D3LEW60', 'ET-D75LE6', 'ET-D3LEW10', 'ET-D3LES20', 'ET-D3LET80', 'ET-D75LE95']
        },
        
        // ===== EPSON PROJECTORS =====
        'EB-PU2220B': {
            name: 'EB-PU2220B',
            brand: 'Epson',
            lumens: 20000,
            resolution: 'WUXGA (1920√ó1200)',
            resolutionPixels: [1920, 1200],
            aspect: 16/10,
            chipSize: '0.76"',
            type: '3LCD',
            contrast: '2,500,000:1',
            weight: 45.0,
            dimensions: '613√ó268√ó748 mm',
            defaultLens: 'ELPLM15',
            compatibleLenses: ['ELPLX02S', 'ELPLU03S', 'ELPLW08', 'ELPLM15', 'ELPLL08']
        },
        'EB-PU2120W': {
            name: 'EB-PU2120W',
            brand: 'Epson',
            lumens: 12000,
            resolution: 'WUXGA (1920√ó1200)',
            resolutionPixels: [1920, 1200],
            aspect: 16/10,
            chipSize: '0.76"',
            type: '3LCD',
            contrast: '2,500,000:1',
            weight: 42.0,
            dimensions: '613√ó268√ó748 mm',
            defaultLens: 'ELPLM15',
            compatibleLenses: ['ELPLX02S', 'ELPLU03S', 'ELPLW08', 'ELPLM15', 'ELPLL08']
        },
        'EB-L30000U': {
            name: 'EB-L30000U',
            brand: 'Epson',
            lumens: 30000,
            resolution: 'WUXGA (1920√ó1200)',
            resolutionPixels: [1920, 1200],
            aspect: 16/10,
            chipSize: '1.0"',
            type: '3LCD Laser',
            contrast: '2,500,000:1',
            weight: 69.5,
            dimensions: '720√ó308√ó815 mm',
            defaultLens: 'ELPLM15',
            compatibleLenses: ['ELPLX02S', 'ELPLU03S', 'ELPLW08', 'ELPLM15', 'ELPLL08']
        },
        'EB-PQ2200B': {
            name: 'EB-PQ2200B',
            brand: 'Epson',
            lumens: 20000,
            resolution: '4K (3840√ó2160)',
            resolutionPixels: [3840, 2160],
            aspect: 16/9,
            chipSize: '0.74"',
            type: '3LCD',
            contrast: '2,500,000:1',
            weight: 47.0,
            dimensions: '613√ó268√ó748 mm',
            defaultLens: 'ELPLM15',
            compatibleLenses: ['ELPLX02S', 'ELPLU03S', 'ELPLW08', 'ELPLM15', 'ELPLL08']
        },
        'EB-L630SU': {
            name: 'EB-L630SU',
            brand: 'Epson',
            lumens: 6000,
            resolution: 'WUXGA (1920√ó1200)',
            resolutionPixels: [1920, 1200],
            aspect: 16/10,
            chipSize: '0.67"',
            type: '3LCD Laser',
            contrast: '2,500,000:1',
            weight: 8.4,
            dimensions: '136√ó440√ó320 mm',
            defaultLens: 'FIXED-ST',
            compatibleLenses: ['FIXED-ST']
        },
        'PowerLite L690SE': {
            name: 'PowerLite L690SE',
            brand: 'Epson',
            lumens: 6000,
            resolution: 'WUXGA with 4K Enhancement (1920√ó1200)',
            resolutionPixels: [1920, 1200],
            aspect: 16/10,
            chipSize: '0.67"',
            type: '3LCD Laser',
            contrast: '5,000,000:1',
            weight: 9.3,
            dimensions: '440√ó362√ó151 mm',
            defaultLens: 'SHORT-ZOOM',
            compatibleLenses: ['SHORT-ZOOM']
        },
        'PowerLite L695SE': {
            name: 'PowerLite L695SE',
            brand: 'Epson',
            lumens: 6000,
            resolution: 'WUXGA with 4K Enhancement (1920√ó1200)',
            resolutionPixels: [1920, 1200],
            aspect: 16/10,
            chipSize: '0.67"',
            type: '3LCD Laser',
            contrast: '5,000,000:1',
            weight: 9.3,
            dimensions: '440√ó362√ó151 mm',
            defaultLens: 'SHORT-ZOOM',
            compatibleLenses: ['SHORT-ZOOM']
        }
    };

    // Complete lens database with all compatible lenses
    const LENSES = {
        // Modern ET-D3L series (for PT-RQ18K, RQ25K, RQ35K)
        'ET-D3LEU100': { throwMin: 0.36, throwMax: 0.36, fixed: true, shiftV: [-66, 66], shiftH: [-25, 30], name: 'Ultra Short Throw' },
        'ET-D3LEW200': { throwMin: 0.48, throwMax: 0.55, fixed: false, shiftV: [-57, 57], shiftH: [-18, 18], name: 'Short Throw Zoom' },
        'ET-D3LEW60': { throwMin: 0.68, throwMax: 0.80, fixed: false, shiftV: [-52, 52], shiftH: [-18, 18], name: 'Wide Zoom' },
        'ET-D3LEW10': { throwMin: 1.01, throwMax: 1.30, fixed: false, shiftV: [-66, 66], shiftH: [-24, 24], name: 'Standard Zoom' },
        'ET-D3LES20': { throwMin: 1.36, throwMax: 1.78, fixed: false, shiftV: [-66, 66], shiftH: [-24, 24], name: 'Standard Zoom' },
        'ET-D3LET80': { throwMin: 1.81, throwMax: 2.56, fixed: false, shiftV: [-66, 66], shiftH: [-24, 24], name: 'Long Throw Zoom' },
        // Classic ET-D75LE series (for PT-RQ13K and compatible)
        'ET-D75LE6': { throwMin: 0.90, throwMax: 1.10, fixed: false, shiftV: [-52, 52], shiftH: [-18, 18], name: 'Short Zoom' },
        'ET-D75LE8': { throwMin: 1.73, throwMax: 2.41, fixed: false, shiftV: [-66, 66], shiftH: [-24, 24], name: 'Long Throw Zoom' },
        'ET-D75LE10': { throwMin: 1.01, throwMax: 1.30, fixed: false, shiftV: [-66, 66], shiftH: [-24, 24], name: 'Standard Zoom' },
        'ET-D75LE20': { throwMin: 1.26, throwMax: 1.70, fixed: false, shiftV: [-66, 66], shiftH: [-24, 24], name: 'Standard Zoom' },
        'ET-D75LE30': { throwMin: 2.37, throwMax: 3.79, fixed: false, shiftV: [-66, 66], shiftH: [-24, 24], name: 'Long Throw Zoom' },
        'ET-D75LE40': { throwMin: 3.71, throwMax: 6.01, fixed: false, shiftV: [-66, 66], shiftH: [-24, 24], name: 'Ultra Long Throw Zoom' },
        'ET-D75LE50': { throwMin: 0.75, throwMax: 0.93, fixed: false, shiftV: [-44, 44], shiftH: [-15, 15], name: 'Short Zoom' },
        'ET-D75LE90': { throwMin: 0.36, throwMax: 0.36, fixed: true, shiftV: [68, 84], shiftH: [-12, 16], name: 'Ultra Short Throw' },
        'ET-D75LE95': { throwMin: 0.80, throwMax: 0.80, fixed: true, shiftV: [71, 93], shiftH: [-14, 14], name: 'Rear Projection' },
        // Epson lenses
        'ELPLX02S': { throwMin: 0.35, throwMax: 0.35, fixed: true, shiftV: [-50, 50], shiftH: [-18, 18], name: 'UST Zero Offset' },
        'ELPLU03S': { throwMin: 0.36, throwMax: 0.36, fixed: true, shiftV: [-96, 96], shiftH: [-47, 47], name: 'UST' },
        'ELPLW08': { throwMin: 0.65, throwMax: 0.78, fixed: false, shiftV: [-96, 96], shiftH: [-47, 47], name: 'Wide Zoom' },
        'ELPLM15': { throwMin: 1.44, throwMax: 2.32, fixed: false, shiftV: [-96, 96], shiftH: [-47, 47], name: 'Middle Throw' },
        'ELPLL08': { throwMin: 2.22, throwMax: 3.61, fixed: false, shiftV: [-96, 96], shiftH: [-47, 47], name: 'Long Throw' },
        // Epson fixed short-throw lenses
        'FIXED-ST': { throwMin: 0.80, throwMax: 0.80, fixed: true, shiftV: [-50, 50], shiftH: [-20, 20], name: 'Fixed Short Throw 0.80:1' },
        'SHORT-ZOOM': { throwMin: 0.50, throwMax: 0.70, fixed: false, shiftV: [-50, 50], shiftH: [-20, 20], name: 'Short Throw Zoom 0.5-0.7:1' },
        // Barco lenses
        'R9801814': { throwMin: 0.36, throwMax: 0.36, fixed: true, shiftV: [-100, 100], shiftH: [-30, 30], name: 'UST' },
        'R9801815': { throwMin: 0.75, throwMax: 0.93, fixed: false, shiftV: [-100, 100], shiftH: [-30, 30], name: 'Short Zoom' },
        'R9801816': { throwMin: 1.13, throwMax: 1.73, fixed: false, shiftV: [-100, 100], shiftH: [-30, 30], name: 'Standard Zoom' },
        'R9801817': { throwMin: 1.73, throwMax: 2.89, fixed: false, shiftV: [-100, 100], shiftH: [-30, 30], name: 'Long Zoom' },
        'R9801818': { throwMin: 2.90, throwMax: 5.50, fixed: false, shiftV: [-100, 100], shiftH: [-30, 30], name: 'Ultra Long Zoom' },
        // Optoma lenses
        'BX-CTA21': { throwMin: 0.36, throwMax: 0.36, fixed: true, shiftV: [-50, 50], shiftH: [-15, 15], name: 'UST' },
        'BX-CTA22': { throwMin: 0.75, throwMax: 0.95, fixed: false, shiftV: [-60, 60], shiftH: [-20, 20], name: 'Short Zoom' },
        'BX-CTA23': { throwMin: 1.22, throwMax: 1.53, fixed: false, shiftV: [-60, 60], shiftH: [-20, 20], name: 'Standard Zoom' },
        'BX-CTA24': { throwMin: 1.52, throwMax: 2.92, fixed: false, shiftV: [-60, 60], shiftH: [-20, 20], name: 'Long Zoom' }
    };


    // ========== BARCO PROJECTOR DATABASE ==========
    const BARCO_DATABASE = {
        'UDX-4K32': {
            name: 'UDX-4K32',
            brand: 'Barco',
            lumens: 31000,
            resolution: '4K-UHD (3840√ó2160)',
            resolutionPixels: [3840, 2160],
            aspect: 16/9,
            chipSize: '0.9"',
            type: '3-Chip DLP',
            contrast: '2,000:1',
            weight: 70.0,
            dimensions: '590√ó370√ó790 mm',
            defaultLens: 'R9801816',
            compatibleLenses: ['R9801814', 'R9801815', 'R9801816', 'R9801817', 'R9801818']
        },
        'UDX-4K26': {
            name: 'UDX-4K26',
            brand: 'Barco',
            lumens: 26000,
            resolution: '4K-UHD (3840√ó2160)',
            resolutionPixels: [3840, 2160],
            aspect: 16/9,
            chipSize: '0.9"',
            type: '3-Chip DLP',
            contrast: '2,000:1',
            weight: 70.0,
            dimensions: '590√ó370√ó790 mm',
            defaultLens: 'R9801816',
            compatibleLenses: ['R9801814', 'R9801815', 'R9801816', 'R9801817', 'R9801818']
        },
        'UDX-W32': {
            name: 'UDX-W32',
            brand: 'Barco',
            lumens: 31000,
            resolution: 'WUXGA (1920√ó1200)',
            resolutionPixels: [1920, 1200],
            aspect: 16/10,
            chipSize: '0.96"',
            type: '3-Chip DLP',
            contrast: '2,000:1',
            weight: 70.0,
            dimensions: '590√ó370√ó790 mm',
            defaultLens: 'R9801816',
            compatibleLenses: ['R9801814', 'R9801815', 'R9801816', 'R9801817', 'R9801818']
        },
        'G62-W11': {
            name: 'G62-W11',
            brand: 'Barco',
            lumens: 11000,
            resolution: 'WUXGA (1920√ó1200)',
            resolutionPixels: [1920, 1200],
            aspect: 16/10,
            chipSize: '0.67"',
            type: '1-Chip DLP',
            contrast: '100,000:1',
            weight: 22.4,
            dimensions: '491√ó178√ó535 mm',
            defaultLens: 'R9801816',
            compatibleLenses: ['R9801815', 'R9801816', 'R9801817', 'R9801818']
        },
        'G62-W14': {
            name: 'G62-W14',
            brand: 'Barco',
            lumens: 14000,
            resolution: 'WUXGA (1920√ó1200)',
            resolutionPixels: [1920, 1200],
            aspect: 16/10,
            chipSize: '0.67"',
            type: '1-Chip DLP',
            contrast: '100,000:1',
            weight: 22.4,
            dimensions: '491√ó178√ó535 mm',
            defaultLens: 'R9801816',
            compatibleLenses: ['R9801815', 'R9801816', 'R9801817', 'R9801818']
        }
    };

    // ========== OPTOMA PROJECTOR DATABASE ==========
    const OPTOMA_DATABASE = {
        'ZU2200': {
            name: 'ZU2200',
            brand: 'Optoma',
            lumens: 22000,
            resolution: 'WUXGA (1920√ó1200)',
            resolutionPixels: [1920, 1200],
            aspect: 16/10,
            chipSize: '0.67"',
            type: '1-Chip DLP',
            contrast: '2,000,000:1',
            weight: 39.7,
            dimensions: '568√ó233√ó690 mm',
            defaultLens: 'BX-CTA23',
            compatibleLenses: ['BX-CTA21', 'BX-CTA22', 'BX-CTA23', 'BX-CTA24']
        },
        'ZU1700': {
            name: 'ZU1700',
            brand: 'Optoma',
            lumens: 17000,
            resolution: 'WUXGA (1920√ó1200)',
            resolutionPixels: [1920, 1200],
            aspect: 16/10,
            chipSize: '0.67"',
            type: '1-Chip DLP',
            contrast: '2,000,000:1',
            weight: 35.0,
            dimensions: '550√ó220√ó600 mm',
            defaultLens: 'BX-CTA23',
            compatibleLenses: ['BX-CTA21', 'BX-CTA22', 'BX-CTA23', 'BX-CTA24']
        },
        'ZU1300': {
            name: 'ZU1300',
            brand: 'Optoma',
            lumens: 13000,
            resolution: 'WUXGA (1920√ó1200)',
            resolutionPixels: [1920, 1200],
            aspect: 16/10,
            chipSize: '0.67"',
            type: '1-Chip DLP',
            contrast: '2,000,000:1',
            weight: 24.0,
            dimensions: '468√ó183√ó540 mm',
            defaultLens: 'BX-CTA23',
            compatibleLenses: ['BX-CTA21', 'BX-CTA22', 'BX-CTA23', 'BX-CTA24']
        },
        'ProScene ZU920T': {
            name: 'ProScene ZU920T',
            brand: 'Optoma',
            lumens: 9200,
            resolution: 'WUXGA (1920√ó1200)',
            resolutionPixels: [1920, 1200],
            aspect: 16/10,
            chipSize: '0.67"',
            type: '1-Chip DLP',
            contrast: '3,000,000:1',
            weight: 14.5,
            dimensions: '455√ó149√ó345 mm',
            defaultLens: 'BX-CTA23',
            compatibleLenses: ['BX-CTA22', 'BX-CTA23', 'BX-CTA24']
        },
        'ProScene ZU725T': {
            name: 'ProScene ZU725T',
            brand: 'Optoma',
            lumens: 7500,
            resolution: 'WUXGA (1920√ó1200)',
            resolutionPixels: [1920, 1200],
            aspect: 16/10,
            chipSize: '0.67"',
            type: '1-Chip DLP',
            contrast: '3,000,000:1',
            weight: 14.5,
            dimensions: '455√ó149√ó345 mm',
            defaultLens: 'BX-CTA23',
            compatibleLenses: ['BX-CTA22', 'BX-CTA23', 'BX-CTA24']
        }
    };

    // Merge all databases (EPSON already merged into PROJECTOR_DATABASE above)
    Object.assign(PROJECTOR_DATABASE, BARCO_DATABASE, OPTOMA_DATABASE);

    // ========== MULTI-PROJECTOR SYSTEM ==========
    // Array to store all projector instances
    let projectors = [];
    let activeProjector = null;
    let projectorIdCounter = 0;

    // Create a new projector instance object
    function createProjectorInstance(modelId, position = new THREE.Vector3(0, 0, 0)) {
        const config = PROJECTOR_DATABASE[modelId] || PROJECTOR_DATABASE['PT-RQ25K'];
        const defaultLens = LENSES[config.defaultLens] || LENSES['ET-D3LES20'];
        
        const instance = {
            id: ++projectorIdCounter,
            modelId: modelId,
            config: config,
            lumens: config.lumens,
            
            // Lens state
            currentLens: defaultLens,
            currentLensId: config.defaultLens,
            throwRatio: defaultLens.throwMin,
            
            // Position state
            projDistance: 10,
            lensShiftV: 0,
            lensShiftH: 0,
            targetLocked: false,
            projectorLockedToTarget: false, // NEW: Lock projector position to target
            userMovedTarget: false,
            
            // Quality state
            frustumFar: 100.0,
            shadowSoftness: 1.0,
            shadowBias: 0.003,
            projectionIntensity: 1.0, // Start at full intensity
            projectorLumens: 25000, // Panasonic PT-RQ25K native lumens
            stackMultiplier: 1, // Will be updated by Stack System
            stackCount: 0,
            stackOffsetX: 0,
            stackOffsetY: 0,
            stackOffsetZ: 0,  // Default to 0 for stacking on same position
            stackAutoLumens: true,
            stackVisible: true,
            stackPowered: true,
            dummyProjectors: [],
            
            // Keystone state (global + corners with X/Y)
            keystoneV: 0, keystoneH: 0,
            keystoneTLX: 0, keystoneTLY: 0,
            keystoneTRX: 0, keystoneTRY: 0,
            keystoneBLX: 0, keystoneBLY: 0,
            keystoneBRX: 0, keystoneBRY: 0,
            
            // Soft Edge state
            softEdgeL: 0, softEdgeR: 0, softEdgeT: 0, softEdgeB: 0,
            softEdgeGamma: 2.2,
            
            // Corner Pin state
            cornerPinTLX: 0, cornerPinTLY: 0,
            cornerPinTRX: 0, cornerPinTRY: 0,
            cornerPinBLX: 0, cornerPinBLY: 0,
            cornerPinBRX: 0, cornerPinBRY: 0,
            
            // Texture
            projectionTexture: null,
            
            // Three.js objects (will be set by createProjectorObjects)
            group: null,
            mesh: null,
            camera: null,
            helper: null,
            shadowLight: null,
            target: null,
            depthRenderTarget: null,
            depthCamera: null,
            
            // Measurement sprites
            spriteWidth: null,
            spriteHeight: null,
            spriteTR: null,
            spriteInfo: null
        };
        
        return instance;
    }

    // Global state
    let showMeasurements = true;
    let snapPoint = 'c';
    let useHighQualityPCF = true;

    // ========== UNDO/REDO HISTORY SYSTEM ==========
    const historyStack = [];
    const redoStack = [];
    const MAX_HISTORY = 50;
    let isUndoRedoAction = false;
    let transformStartState = null;

    function updateHistoryButtons() {
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        if (undoBtn) undoBtn.disabled = historyStack.length === 0;
        if (redoBtn) redoBtn.disabled = redoStack.length === 0;
    }

    function pushHistory(action) {
        if (isUndoRedoAction) return;
        historyStack.push(action);
        if (historyStack.length > MAX_HISTORY) {
            historyStack.shift();
        }
        redoStack.length = 0; // Clear redo on new action
        updateHistoryButtons();
    }

    function historyUndo() {
        if (historyStack.length === 0) return;
        isUndoRedoAction = true;
        const action = historyStack.pop();
        
        try {
            switch (action.type) {
                case 'transform':
                    if (action.object && action.object.parent) {
                        // Save current state for redo
                        const redoAction = {
                            type: 'transform',
                            object: action.object,
                            position: action.object.position.clone(),
                            rotation: action.object.rotation.clone(),
                            scale: action.object.scale.clone()
                        };
                        redoStack.push(redoAction);
                        
                        // Restore previous state
                        action.object.position.copy(action.position);
                        action.object.rotation.copy(action.rotation);
                        action.object.scale.copy(action.scale);
                        action.object.updateMatrixWorld(true);
                        updateTransformInputs();
                        updateAll();
                    }
                    break;
                    
                case 'create_object':
                    // Undo: delete the created object
                    if (action.object && action.object.parent) {
                        // Push to redo to recreate it
                        redoStack.push({
                            type: 'create_object',
                            object: action.object,
                            objectType: action.objectType
                        });
                        scene.remove(action.object);
                        const pIdx = projectedObjects.indexOf(action.object);
                        if (pIdx > -1) projectedObjects.splice(pIdx, 1);
                        const sIdx = selectableObjects.indexOf(action.object);
                        if (sIdx > -1) selectableObjects.splice(sIdx, 1);
                        if (selectedObject === action.object) selectObject(null);
                        populateSceneHierarchy();
                    }
                    break;
                    
                case 'delete_object':
                    // Undo: recreate the deleted object
                    if (action.object) {
                        // Push to redo to delete it again
                        redoStack.push({
                            type: 'delete_object',
                            object: action.object,
                            objectType: action.objectType
                        });
                        scene.add(action.object);
                        if (action.objectType !== 'projector') {
                            projectedObjects.push(action.object);
                        }
                        selectableObjects.push(action.object);
                        populateSceneHierarchy();
                    }
                    break;
                    
                case 'create_projector':
                    if (action.projectorId) {
                        const proj = projectors.find(p => p.id === action.projectorId);
                        if (proj) {
                            redoStack.push({
                                type: 'delete_projector',
                                projectorData: cloneProjectorState(proj),
                                projectorId: proj.id
                            });
                            deleteProjectorInternal(proj.id);
                        }
                    }
                    break;
                    
                case 'delete_projector':
                    if (action.projectorData) {
                        const newProj = restoreProjector(action.projectorData);
                        redoStack.push({
                            type: 'create_projector',
                            projectorId: newProj.id
                        });
                    }
                    break;
            }
        } catch (e) {
            console.error('Undo error:', e);
        }
        
        isUndoRedoAction = false;
        updateHistoryButtons();
        updateSceneHierarchy();
    }

    function historyRedo() {
        if (redoStack.length === 0) return;
        isUndoRedoAction = true;
        const action = redoStack.pop();
        
        try {
            switch (action.type) {
                case 'transform':
                    if (action.object && action.object.parent) {
                        historyStack.push({
                            type: 'transform',
                            object: action.object,
                            position: action.object.position.clone(),
                            rotation: action.object.rotation.clone(),
                            scale: action.object.scale.clone()
                        });
                        
                        action.object.position.copy(action.position);
                        action.object.rotation.copy(action.rotation);
                        action.object.scale.copy(action.scale);
                        action.object.updateMatrixWorld(true);
                        updateTransformInputs();
                        updateAll();
                    }
                    break;
                    
                case 'create_object':
                    // Redo: recreate object
                    if (action.object) {
                        historyStack.push({
                            type: 'delete_object',
                            object: action.object,
                            objectType: action.objectType
                        });
                        scene.add(action.object);
                        if (action.objectType !== 'projector') {
                            projectedObjects.push(action.object);
                        }
                        selectableObjects.push(action.object);
                        populateSceneHierarchy();
                    }
                    break;
                    
                case 'delete_object':
                    // Redo: delete object again
                    if (action.object && action.object.parent) {
                        historyStack.push({
                            type: 'create_object',
                            object: action.object,
                            objectType: action.objectType
                        });
                        scene.remove(action.object);
                        const pIdx = projectedObjects.indexOf(action.object);
                        if (pIdx > -1) projectedObjects.splice(pIdx, 1);
                        const sIdx = selectableObjects.indexOf(action.object);
                        if (sIdx > -1) selectableObjects.splice(sIdx, 1);
                        if (selectedObject === action.object) selectObject(null);
                    }
                    break;
                    
                case 'create_projector':
                    if (action.projectorData) {
                        const newProj = restoreProjector(action.projectorData);
                        historyStack.push({
                            type: 'delete_projector',
                            projectorData: action.projectorData,
                            projectorId: newProj.id
                        });
                    }
                    break;
                    
                case 'delete_projector':
                    if (action.projectorId) {
                        const proj = projectors.find(p => p.id === action.projectorId);
                        if (proj) {
                            historyStack.push({
                                type: 'create_projector',
                                projectorId: proj.id
                            });
                            deleteProjectorInternal(proj.id);
                        }
                    }
                    break;
            }
        } catch (e) {
            console.error('Redo error:', e);
        }
        
        isUndoRedoAction = false;
        updateHistoryButtons();
        updateSceneHierarchy();
    }

    function cloneProjectorState(proj) {
        return {
            modelId: proj.modelId,
            position: proj.group ? proj.group.position.clone() : new THREE.Vector3(),
            rotation: proj.group ? proj.group.rotation.clone() : new THREE.Euler(),
            throwRatio: proj.throwRatio,
            lensShiftV: proj.lensShiftV,
            lensShiftH: proj.lensShiftH,
            currentLensId: proj.currentLensId,
            keystoneV: proj.keystoneV,
            keystoneH: proj.keystoneH,
            softEdgeL: proj.softEdgeL,
            softEdgeR: proj.softEdgeR,
            softEdgeT: proj.softEdgeT,
            softEdgeB: proj.softEdgeB
        };
    }

    function restoreProjector(data) {
        // Create new projector with saved state
        const newProj = createAndAddProjector(data.modelId, data.currentLensId);
        if (newProj && newProj.group) {
            newProj.group.position.copy(data.position);
            newProj.group.rotation.copy(data.rotation);
            newProj.throwRatio = data.throwRatio;
            newProj.lensShiftV = data.lensShiftV;
            newProj.lensShiftH = data.lensShiftH;
            newProj.keystoneV = data.keystoneV;
            newProj.keystoneH = data.keystoneH;
            newProj.softEdgeL = data.softEdgeL;
            newProj.softEdgeR = data.softEdgeR;
            newProj.softEdgeT = data.softEdgeT;
            newProj.softEdgeB = data.softEdgeB;
        }
        updateProjectorCount(); populateProjectorsPanel(); populateSceneHierarchy(); // Update modern UI
        populateScenePanel(); // Update scene panel
        return newProj;
    }

    function deleteProjectorInternal(projId) {
        console.log('üóëÔ∏è Deleting projector:', projId);
        const projIdx = projectors.findIndex(p => p.id === projId);
        if (projIdx === -1) {
            console.error('‚ùå Projector not found:', projId);
            return;
        }
        
        const proj = projectors[projIdx];
        console.log('üì¶ Projector object:', proj);
        
        // Remove all visual elements from scene
        if (proj.group) {
            console.log('‚úÖ Removing group');
            scene.remove(proj.group);
        }
        if (proj.helper) {
            console.log('‚úÖ Removing helper');
            scene.remove(proj.helper);
        } else {
            console.warn('‚ö†Ô∏è No helper found!');
        }
        if (proj.frustumHelper) {
            console.log('‚úÖ Removing frustumHelper');
            scene.remove(proj.frustumHelper);
        }
        if (proj.target) {
            console.log('‚úÖ Removing target');
            scene.remove(proj.target);
        }
        
        // Remove mesh from selectable objects
        if (proj.mesh) {
            const meshIdx = selectableObjects.indexOf(proj.mesh);
            if (meshIdx > -1) selectableObjects.splice(meshIdx, 1);
        }
        
        // Remove shadow light and helpers
        if (proj.shadowLight) {
            console.log('‚úÖ Removing shadowLight');
            scene.remove(proj.shadowLight);
            if (proj.shadowLight.target) scene.remove(proj.shadowLight.target);
        }
        
        // Remove measurement sprites
        if (proj.spriteWidth) {
            console.log('‚úÖ Removing spriteWidth');
            scene.remove(proj.spriteWidth);
        }
        if (proj.spriteHeight) {
            console.log('‚úÖ Removing spriteHeight');
            scene.remove(proj.spriteHeight);
        }
        if (proj.spriteTR) {
            console.log('‚úÖ Removing spriteTR');
            scene.remove(proj.spriteTR);
        }
        if (proj.spriteInfo) {
            console.log('‚úÖ Removing spriteInfo');
            scene.remove(proj.spriteInfo);
        }
        
        // Dispose of depth render target
        if (proj.depthRenderTarget) {
            proj.depthRenderTarget.dispose();
        }
        
        // Remove from projectors array
        projectors.splice(projIdx, 1);
        console.log('‚úÖ Projector removed. Remaining:', projectors.length);
        
        // Update active projector if needed
        if (activeProjector && activeProjector.id === projId) {
            activeProjector = projectors.length > 0 ? projectors[0] : null;
            if (activeProjector) syncFromActiveProjector();
        }
        
        updateSceneHierarchy();
        updateProjectorCount(); populateProjectorsPanel(); populateSceneHierarchy(); // Update modern UI
        populateScenePanel(); // Update scene panel
        updateProjectionMatrix();
    }

    // Make functions globally accessible
    window.historyUndo = historyUndo;
    window.historyRedo = historyRedo;

    // Core
    let scene, camera, renderer, controls, transformControls;
    let raycaster, mouse, selectedObject = null;

    // Legacy compatibility - these now point to active projector's objects
    let projectorGroup, projectorMesh, projectorCamera, projectorHelper, shadowLight;
    let targetMesh;
    let projectionTexture = null;
    let depthRenderTarget, depthMaterial, depthCamera;
    let spriteWidth, spriteHeight, spriteTR, spriteInfo;
    
    // Default placeholder textures for shadow maps and projections
    let defaultShadowTexture = null;
    let defaultProjectionTexture = null;

    // Current projector state variables (synced with active projector)
    let currentLens, throwRatio, frustumFar, projDistance;
    let lensShiftV = 0, lensShiftH = 0;
    let targetLocked = false, userMovedTarget = false;
    let shadowSoftness = 1.0, shadowBias = 0.003, projectionIntensity = 1.0;
    
    // ===== PHOTOMETRIC ANALYSIS VARIABLES =====
    let photometricMode = false;
    let ambientLightLux = 0;          // Lumi√®re ambiante en lux
    let directionalLightLux = 0;      // Lumi√®re directionnelle en lux
    let materialGain = 1.0;           // Gain du mat√©riau (0.1 √† 2.0)
    let photometricScaleMax = 1000;   // √âchelle max en lux
    let photometricScaleLog = false;  // Mode logarithmique
    let photometricShaderLog = false; // Shader perception log
    let keystoneV = 0, keystoneH = 0;
    let keystoneBypassed = false;
    let softEdgeBypassed = false;
    let stackBypassed = false;
    // Keystone corners with separate X/Y control
    let keystoneTLX = 0, keystoneTLY = 0;
    let keystoneTRX = 0, keystoneTRY = 0;
    let keystoneBLX = 0, keystoneBLY = 0;
    let keystoneBRX = 0, keystoneBRY = 0;
    
    // Corner Pin variables (homography-based perspective correction)
    let cornerPinTLX = -6, cornerPinTLY = 6;   // Slider 0 ‚Üí Edges
    let cornerPinTRX = 6, cornerPinTRY = 6;    // Slider 0 ‚Üí Edges
    let cornerPinBLX = -6, cornerPinBLY = -6;  // Slider 0 ‚Üí Edges
    let cornerPinBRX = 6, cornerPinBRY = -6;   // Slider 0 ‚Üí Edges
    
    // Corner Pin values object for keyboard access
    const cornerPinValues = {
        tl: { get x() { return cornerPinTLX; }, set x(v) { cornerPinTLX = v; }, get y() { return cornerPinTLY; }, set y(v) { cornerPinTLY = v; } },
        tr: { get x() { return cornerPinTRX; }, set x(v) { cornerPinTRX = v; }, get y() { return cornerPinTRY; }, set y(v) { cornerPinTRY = v; } },
        bl: { get x() { return cornerPinBLX; }, set x(v) { cornerPinBLX = v; }, get y() { return cornerPinBLY; }, set y(v) { cornerPinBLY = v; } },
        br: { get x() { return cornerPinBRX; }, set x(v) { cornerPinBRX = v; }, get y() { return cornerPinBRY; }, set y(v) { cornerPinBRY = v; } }
    };
    
    let softEdgeL = 0, softEdgeR = 0, softEdgeT = 0, softEdgeB = 0;
    let softEdgeGamma = 2.2;
    let LUMENS = 20000;
    let currentProjectorModel = 'PT-RQ25K';
    let currentProjectorConfig = PROJECTOR_DATABASE['PT-RQ25K'];

    let projectedObjects = [];
    let selectableObjects = [];

    // ========== 3D MODEL LOADER STATE ==========
    let modelPreviewScene, modelPreviewCamera, modelPreviewRenderer, modelPreviewControls;
    let pendingModel = null;
    let selectedAxis = 'y';
    let selectedPivot = 'floor';

    
    // Calculator functions
    
    window.toggleProjectorLockToTarget = function() {
        if (!activeProjector) {
            console.log('‚ö†Ô∏è No active projector');
            return;
        }
        
        // Toggle state for active projector only
        activeProjector.projectorLockedToTarget = !activeProjector.projectorLockedToTarget;
        
        console.log(`üìç Projector #${activeProjector.id} position lock: ${activeProjector.projectorLockedToTarget ? 'LOCKED' : 'UNLOCKED'}`);
        
        // Sync checkbox in panel
        const checkbox = document.getElementById('projector-locked-modern');
        if (checkbox) checkbox.checked = activeProjector.projectorLockedToTarget;
        
        // Update button appearance
        updateProjectorLockButton();
    };
    
    window.toggleProjectorLockFromPanel = function() {
        if (!activeProjector) return;
        
        const checkbox = document.getElementById('projector-locked-modern');
        if (!checkbox) return;
        
        // Get state from checkbox
        activeProjector.projectorLockedToTarget = checkbox.checked;
        
        console.log(`üìç Projector #${activeProjector.id} position lock: ${activeProjector.projectorLockedToTarget ? 'LOCKED' : 'UNLOCKED'}`);
        
        // Update button appearance
        updateProjectorLockButton();
    };
    
    function updateProjectorLockButton() {
        const btn = document.getElementById('lock-projector-btn-top');
        if (!btn) return;
        
        const isLocked = activeProjector && activeProjector.projectorLockedToTarget;
        
        if (isLocked) {
            btn.style.cssText = 'margin-left: 6px; padding: 6px 12px; background: rgba(13,148,136,0.2); border: 1px solid #0d9488; border-radius: 4px; color: #0d9488; cursor: pointer; font-size: 12px; font-weight: 600;';
            btn.innerHTML = 'üìç Locked';
        } else {
            btn.style.cssText = 'margin-left: 6px; padding: 6px 12px; background: rgba(255,107,107,0.1); border: 1px solid #ff6b6b; border-radius: 4px; color: #ff6b6b; cursor: pointer; font-size: 12px; font-weight: 600;';
            btn.innerHTML = 'üìç Position Lock';
        }
    }
    
    // Use existing undo/redo system
    window.undo = function() {
        console.log('‚Ü∂ Undo');
        historyUndo(); // Correct function name
    };
    
    window.redo = function() {
        console.log('‚Ü∑ Redo');
        historyRedo(); // Correct function name
    };
    
    // Grid toggle
    let gridVisible = true;
    let gridHelper = null;
    
    window.toggleGrid = function() {
        if (!gridHelper) {
            // Create LARGE grid helper for monuments (500m x 500m, every 10m)
            gridHelper = new THREE.GridHelper(500, 50, 0x444444, 0x222222);
            gridHelper.userData.noProjection = true;
            scene.add(gridHelper);
        }
        
        gridVisible = !gridVisible;
        gridHelper.visible = gridVisible;
        
        const btn = document.getElementById('grid-btn');
        if (btn) {
            if (gridVisible) {
                btn.style.cssText = 'margin-left: 12px; padding: 6px 10px; background: rgba(13,148,136,0.1); border: 1px solid #0d9488; border-radius: 4px; color: #0d9488; cursor: pointer; font-size: 11px; font-weight: 600;';
            } else {
                btn.style.cssText = 'margin-left: 12px; padding: 6px 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #888; cursor: pointer; font-size: 11px; font-weight: 600;';
            }
        }
        
        console.log(`üî≤ Grid: ${gridVisible ? 'ON (500m x 500m)' : 'OFF'}`);
    };
    
    // Measurements toggle
    window.toggleMeasurements = function() {
        showMeasurements = !showMeasurements;
        
        // Update measurement sprites visibility
        if (spriteWidth) spriteWidth.visible = showMeasurements;
        if (spriteHeight) spriteHeight.visible = showMeasurements;
        if (spriteTR) spriteTR.visible = showMeasurements;
        if (spriteInfo) spriteInfo.visible = showMeasurements;
        
        const btn = document.getElementById('measure-btn');
        if (btn) {
            if (showMeasurements) {
                btn.style.cssText = 'margin-left: 4px; padding: 6px 10px; background: rgba(13,148,136,0.1); border: 1px solid #0d9488; border-radius: 4px; color: #0d9488; cursor: pointer; font-size: 11px; font-weight: 600;';
            } else {
                btn.style.cssText = 'margin-left: 4px; padding: 6px 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #888; cursor: pointer; font-size: 11px; font-weight: 600;';
            }
        }
        
        console.log(`üìè Measurements: ${showMeasurements ? 'ON' : 'OFF'}`);
    };
    
    // Target selector and lock aim functions
    
    window.changeProjectorTarget = function() { 
        // Removed - using simple default target only
    };
    
    window.toggleTargetLockForProjector = function() {
        // Removed - using simple toggleTargetLock() instead
        toggleTargetLock();
    };
    
    function updateLockAimButton() {
        const btn = document.getElementById('lock-aim-btn-panel');
        if (!btn || !activeProjector) return;
        
        if (activeProjector.targetLocked) {
            btn.style.cssText = 'width: 100%; padding: 10px; background: rgba(13,148,136,0.2); border: 1px solid #0d9488; border-radius: 6px; color: #0d9488; cursor: pointer; font-size: 12px; font-weight: 600;';
            btn.textContent = 'üéØ Lock Aim: ON';
        } else {
            btn.style.cssText = 'width: 100%; padding: 10px; background: rgba(255,107,107,0.1); border: 1px solid #ff6b6b; border-radius: 6px; color: #ff6b6b; cursor: pointer; font-size: 12px; font-weight: 600;';
            btn.textContent = 'üéØ Lock Aim: OFF';
        }
    }
    
    // Bypass toggle functions
    window.toggleKeystoneBypass = function() {
        keystoneBypassed = !keystoneBypassed;
        const btn = document.getElementById('keystone-bypass-btn');
        if (keystoneBypassed) {
            btn.style.background = 'rgba(13,148,136,0.2)';
            btn.style.borderColor = '#0d9488';
            btn.style.color = '#0d9488';
            btn.textContent = 'ACTIVE';
            console.log('üî≤ Keystone BYPASSED');
        } else {
            btn.style.background = 'rgba(255,107,107,0.1)';
            btn.style.borderColor = '#ff6b6b';
            btn.style.color = '#ff6b6b';
            btn.textContent = 'BYPASS';
            console.log('üî≤ Keystone ACTIVE');
        }
        updateProjectionMatrix();
    };
    
    window.toggleSoftEdgeBypass = function() {
        softEdgeBypassed = !softEdgeBypassed;
        const btn = document.getElementById('softedge-bypass-btn');
        if (softEdgeBypassed) {
            btn.style.background = 'rgba(13,148,136,0.2)';
            btn.style.borderColor = '#0d9488';
            btn.style.color = '#0d9488';
            btn.textContent = 'ACTIVE';
            console.log('üå´Ô∏è Soft Edge BYPASSED');
        } else {
            btn.style.background = 'rgba(255,107,107,0.1)';
            btn.style.borderColor = '#ff6b6b';
            btn.style.color = '#ff6b6b';
            btn.textContent = 'BYPASS';
            console.log('üå´Ô∏è Soft Edge ACTIVE');
        }
        updateProjectionMatrix();
    };
    
    window.toggleStackBypass = function() {
        stackBypassed = !stackBypassed;
        const btn = document.getElementById('stack-bypass-btn');
        if (stackBypassed) {
            btn.style.background = 'rgba(13,148,136,0.2)';
            btn.style.borderColor = '#0d9488';
            btn.style.color = '#0d9488';
            btn.textContent = 'ACTIVE';
            console.log('üìö Stack BYPASSED (dummies hidden)');
            // Hide all dummy projectors
            if (activeProjector && activeProjector.dummyProjectors) {
                activeProjector.dummyProjectors.forEach(dummy => {
                    dummy.mesh.visible = false;
                    dummy.helper.visible = false;
                    if (dummy.light) dummy.light.visible = false;
                });
            }
        } else {
            btn.style.background = 'rgba(255,107,107,0.1)';
            btn.style.borderColor = '#ff6b6b';
            btn.style.color = '#ff6b6b';
            btn.textContent = 'BYPASS';
            console.log('üìö Stack ACTIVE (dummies visible)');
            // Show all dummy projectors if settings allow
            if (activeProjector && activeProjector.dummyProjectors) {
                const visible = document.getElementById('stack-visible').checked;
                activeProjector.dummyProjectors.forEach(dummy => {
                    dummy.mesh.visible = visible;
                    dummy.helper.visible = visible;
                    if (dummy.light) dummy.light.visible = visible;
                });
            }
        }
        updateProjectionMatrix();
    };
    
    function init() {
        // Create default shadow texture (1x1 white = max depth = no shadow)
        // Use UnsignedByteType for broader compatibility
        const data = new Uint8Array([255, 255, 255, 255]);
        defaultShadowTexture = new THREE.DataTexture(data, 1, 1, THREE.RGBAFormat, THREE.UnsignedByteType);
        defaultShadowTexture.minFilter = THREE.NearestFilter;
        defaultShadowTexture.magFilter = THREE.NearestFilter;
        defaultShadowTexture.needsUpdate = true;
        
        // Also create a default projection texture (1x1 white)
        defaultProjectionTexture = new THREE.DataTexture(data, 1, 1, THREE.RGBAFormat, THREE.UnsignedByteType);
        defaultProjectionTexture.minFilter = THREE.NearestFilter;
        defaultProjectionTexture.magFilter = THREE.NearestFilter;
        defaultProjectionTexture.needsUpdate = true;
        
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(6,4,12);
        camera.lookAt(0,0,-5);
        // Enable all layers so camera can see helper on layer 1
        camera.layers.enableAll();

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('container').appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        transformControls = new THREE.TransformControls(camera, renderer.domElement);
        transformControls.setSize(0.75);
        transformControls.setMode('translate');
        
        // Track if we just finished dragging to prevent deselection on click
        let justFinishedDragging = false;
        transformControls.addEventListener('dragging-changed', e => {
            controls.enabled = !e.value;
            if (e.value) {
                // Starting drag - save initial state for undo
                if (transformControls.object) {
                    transformStartState = {
                        object: transformControls.object,
                        position: transformControls.object.position.clone(),
                        rotation: transformControls.object.rotation.clone(),
                        scale: transformControls.object.scale.clone()
                    };
                }
            } else {
                // Just finished dragging - record history if state changed
                if (transformStartState && transformControls.object) {
                    const obj = transformControls.object;
                    const posChanged = !obj.position.equals(transformStartState.position);
                    const rotChanged = !obj.rotation.equals(transformStartState.rotation);
                    const scaleChanged = !obj.scale.equals(transformStartState.scale);
                    
                    if (posChanged || rotChanged || scaleChanged) {
                        pushHistory({
                            type: 'transform',
                            object: transformStartState.object,
                            position: transformStartState.position,
                            rotation: transformStartState.rotation,
                            scale: transformStartState.scale
                        });
                    }
                }
                transformStartState = null;
                justFinishedDragging = true;
                setTimeout(() => { justFinishedDragging = false; }, 100);
                
                // Update properties panel after drag
                updatePropertiesPanel();
            }
        });
        transformControls.addEventListener('objectChange', onTransformChange);
        transformControls.addEventListener('change', updateTransformInputs);
        scene.add(transformControls);
        
        // Make justFinishedDragging accessible to onClick
        window._justFinishedDragging = () => justFinishedDragging;

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        const ambientLightObj = new THREE.AmbientLight(0xffffff, 0.1); // Start low so controls are visible
        scene.add(ambientLightObj);
        
        const directionalLightObj = new THREE.DirectionalLight(0xffffff, 0.5); // Lower initial
        directionalLightObj.position.set(5,10,5);
        scene.add(directionalLightObj);
        
        const backLight = new THREE.DirectionalLight(0xffffff, 0.2); // Lower back light
        backLight.position.set(-5, 5, -5);
        scene.add(backLight);
        
        // Store references globally for brightness controls
        window.ambientLightObj = ambientLightObj;
        window.directionalLightObj = directionalLightObj;

        const grid = new THREE.GridHelper(30,30,0x444444,0x222222);
        grid.userData.noProjection = true;
        scene.add(grid);

        const axes = new THREE.AxesHelper(2);
        axes.userData.noProjection = true;
        scene.add(axes);

        // Scene starts empty - no default projector
        // User creates projectors via Create Projector modal
        createDepthRenderer();
        createMeasurementSprites();

        // Scene starts empty - no default wall per user request

        window.addEventListener('resize', onResize);
        renderer.domElement.addEventListener('click', onClick);
        renderer.domElement.addEventListener('contextmenu', onRightClick);
        window.addEventListener('keydown', onKeyDown);
        document.addEventListener('click', hidePrimitivePopup);

        changeLens();
        updateAll();

        // Initialize projector menu
        initProjectorMenu();

        // Initialize floating window drag
        initFloatingWindowDrag();
        
        // Initialize 15¬∞ rotation snapping with Shift
        initRotationSnapping();
        
        // Initialize Corner Pin visual editor
        initCornerPinVisual();
        
        // IMPORTANT: Sync sliders with default values (full frame)
        updateKeystoneCorners();
        
        // Initialize Custom Screen Modal
        const customScreenInput = document.getElementById('custom-screen-width');
        if (customScreenInput) {
            customScreenInput.addEventListener('input', updateScreenPreview);
            customScreenInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    createCustomScreen();
                }
            });
        }

        setTimeout(() => updateAllBaseColors(), 100);
        
        // Initialize modern interface
        initModernInterface();
        
        // Initialize brightness system (after lights are created)
        initBrightnessSystem();

        animate();
    }

    // ========== PROJECTOR MODAL FUNCTIONS ==========
    let selectedProjectorModel = 'PT-RQ25K';
    let selectedLensForNewProjector = 'ET-D3LES20';
    let selectedBrand = 'panasonic';
    
    function initProjectorMenu() {
        // Populate the projector modal grids
        populateProjectorModal();
    }
    
    window.selectBrand = function(brand) {
        selectedBrand = brand;
        document.querySelectorAll('.brand-tab').forEach(tab => tab.classList.remove('active'));
        document.querySelector(`[data-brand="${brand}"]`)?.classList.add('active');
        document.querySelectorAll('.brand-grid').forEach(grid => grid.classList.remove('active'));
        document.getElementById(`brand-${brand}`)?.classList.add('active');
        populateProjectorModal();
    };
    
    function populateProjectorModal() {
        const lensGrid = document.getElementById('lens-selection-grid');
        
        // Populate Panasonic grids
        const pana4k = document.getElementById('projector-panasonic-4k');
        const panaWuxga = document.getElementById('projector-panasonic-wuxga');
        if (pana4k) {
            pana4k.innerHTML = '';
            ['PT-RQ13K', 'PT-RQ18K', 'PT-RQ25K', 'PT-RQ35K'].forEach(model => {
                pana4k.appendChild(createProjectorCard(model));
            });
        }
        if (panaWuxga) {
            panaWuxga.innerHTML = '';
            ['PT-RZ17K', 'PT-RZ24K', 'PT-RZ34K'].forEach(model => {
                panaWuxga.appendChild(createProjectorCard(model));
            });
        }
        
        // Populate Epson grids
        const epson4k = document.getElementById('projector-epson-4k');
        const epsonWuxga = document.getElementById('projector-epson-wuxga');
        const epsonShortThrow = document.getElementById('projector-epson-shortthrow');
        if (epson4k) {
            epson4k.innerHTML = '';
            ['EB-PQ2200B'].forEach(model => {
                epson4k.appendChild(createProjectorCard(model));
            });
        }
        if (epsonWuxga) {
            epsonWuxga.innerHTML = '';
            ['EB-PU2220B', 'EB-PU2120W', 'EB-L30000U'].forEach(model => {
                epsonWuxga.appendChild(createProjectorCard(model));
            });
        }
        if (epsonShortThrow) {
            epsonShortThrow.innerHTML = '';
            ['EB-L630SU', 'PowerLite L690SE', 'PowerLite L695SE'].forEach(model => {
                epsonShortThrow.appendChild(createProjectorCard(model));
            });
        }
        
        // Populate Barco grids
        const barcoUdx = document.getElementById('projector-barco-udx');
        const barcoG = document.getElementById('projector-barco-g');
        if (barcoUdx) {
            barcoUdx.innerHTML = '';
            ['UDX-4K32', 'UDX-4K26', 'UDX-W32'].forEach(model => {
                barcoUdx.appendChild(createProjectorCard(model));
            });
        }
        if (barcoG) {
            barcoG.innerHTML = '';
            ['G62-W11', 'G62-W14'].forEach(model => {
                barcoG.appendChild(createProjectorCard(model));
            });
        }
        
        // Populate Optoma grids
        const optomaProscene = document.getElementById('projector-optoma-proscene');
        const optomaZu = document.getElementById('projector-optoma-zu');
        if (optomaProscene) {
            optomaProscene.innerHTML = '';
            ['ProScene ZU920T', 'ProScene ZU725T'].forEach(model => {
                optomaZu.appendChild(createProjectorCard(model));
            });
        }
        if (optomaZu) {
            optomaZu.innerHTML = '';
            ['ZU2200', 'ZU1700', 'ZU1300'].forEach(model => {
                optomaZu.appendChild(createProjectorCard(model));
            });
        }
        
        // Update lens grid based on selected projector
        updateLensGridForModel(selectedProjectorModel);
    }
    
    function createProjectorCard(model) {
        const config = PROJECTOR_DATABASE[model];
        if (!config) return document.createElement('div');
        
        const card = document.createElement('div');
        card.className = 'projector-card' + (model === selectedProjectorModel ? ' selected' : '');
        card.onclick = () => selectProjectorModel(model);
        card.innerHTML = `
            <div class="projector-card-icon">üìΩÔ∏è</div>
            <div class="projector-card-name">${model}</div>
            <div class="projector-card-specs">${config.lumens.toLocaleString()} lm ‚Ä¢ ${config.resolution.split(' ')[0]}</div>
        `;
        return card;
    }

    // Toggle functions for menu
    window.toggleFrustumFromMenu = function() {
        const checkbox = document.getElementById('show-frustum');
        if (checkbox) checkbox.checked = !checkbox.checked;
        toggleFrustum();
    };
    
    window.toggleMeasurementsFromMenu = function() {
        const checkbox = document.getElementById('show-measurements');
        if (checkbox) checkbox.checked = !checkbox.checked;
        toggleMeasurements();
    };

    // Scene parameters global shadow settings
    window.updateSceneShadowQuality = function() {
        const softness = parseFloat(document.getElementById('scene-shadow-softness')?.value || 1.0);
        const bias = parseFloat(document.getElementById('scene-shadow-bias')?.value || 0.003);
        const hqPcf = document.getElementById('scene-hq-pcf')?.checked ?? true;
        
        document.getElementById('scene-shadow-softness-val').textContent = softness.toFixed(1);
        document.getElementById('scene-shadow-bias-val').textContent = bias.toFixed(4);
        
        // Apply to ALL projectors
        projectors.forEach(proj => {
            proj.shadowSoftness = softness;
            proj.shadowBias = bias;
        });
        shadowSoftness = softness;
        shadowBias = bias;
        useHighQualityPCF = hqPcf;
        
        updateProjectionMatrix();
        updateSceneInfo();
    };
    
    function updateSceneInfo() {
        const countEl = document.getElementById('scene-projector-count');
        const objEl = document.getElementById('scene-object-count');
        if (countEl) countEl.textContent = projectors.length;
        if (objEl) objEl.textContent = projectedObjects.filter(o => o.userData?.type === 'object').length;
    }

    // Photometric analysis
    window.updatePhotometrics = function() {
        if (!activeProjector) return;
        
        const screenGain = parseFloat(document.getElementById('screen-gain')?.value || 1.0);
        const ambientLight = parseFloat(document.getElementById('ambient-light')?.value || 0);
        
        document.getElementById('screen-gain-val').textContent = screenGain.toFixed(1);
        document.getElementById('ambient-light-val').textContent = ambientLight;
        
        const dist = projDistance;
        const width = dist / throwRatio;
        const height = width / ASPECT;
        const area = width * height;
        const lux = (LUMENS * screenGain) / area;
        const contrastRatio = lux / Math.max(ambientLight, 0.1);
        
        document.getElementById('photo-lux').textContent = lux.toFixed(0);
        document.getElementById('photo-lumens').textContent = LUMENS.toLocaleString();
        document.getElementById('photo-coverage').textContent = area.toFixed(1);
        document.getElementById('photo-ratio').textContent = throwRatio.toFixed(2);
        
        // Recommendations
        let rec = '';
        if (lux < 500) rec = '‚ö†Ô∏è Luminosit√© faible - envisager un projecteur plus puissant';
        else if (lux > 3000) rec = '‚úì Excellente luminosit√© pour environnement √©clair√©';
        else rec = '‚úì Luminosit√© ad√©quate';
        if (ambientLight > 100 && contrastRatio < 10) rec += '\n‚ö†Ô∏è Contraste insuffisant avec lumi√®re ambiante';
        document.getElementById('photo-recommendations').textContent = rec;
    };

    // PDF/Export functions
    window.renderViewportSnapshot = function() {
        renderer.render(scene, camera);
        const dataUrl = renderer.domElement.toDataURL('image/png');
        const link = document.createElement('a');
        link.download = 'viewport-snapshot.png';
        link.href = dataUrl;
        link.click();
    };
    
    window.generatePDFReport = function() {
        const title = document.getElementById('export-title')?.value || 'Projection Setup';
        const notes = document.getElementById('export-notes')?.value || '';
        
        // Generate HTML report that can be printed as PDF
        const reportWindow = window.open('', '_blank');
        
        // Check if popup was blocked
        if (!reportWindow) {
            alert('‚ö†Ô∏è Le popup a √©t√© bloqu√© par votre navigateur.\nVeuillez autoriser les popups pour g√©n√©rer le PDF.');
            return;
        }
        
        reportWindow.document.write(`
            <!DOCTYPE html>
            <html>
            <head><title>${title}</title>
            <style>
                body { font-family: Arial, sans-serif; padding: 40px; }
                h1 { color: #0d9488; }
                table { width: 100%; border-collapse: collapse; margin: 20px 0; }
                th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                th { background: #0d9488; color: white; }
                .notes { background: #f5f5f5; padding: 15px; border-radius: 8px; margin: 20px 0; }
            </style>
            </head>
            <body>
            <h1>${title}</h1>
            <p>Date: ${new Date().toLocaleDateString()}</p>
            <h2>Projecteurs (${projectors.length})</h2>
            <table>
                <tr><th>ID</th><th>Mod√®le</th><th>Marque</th><th>Lumens</th><th>R√©solution</th><th>Optique</th></tr>
                ${projectors.map(p => `<tr><td>#${p.id}</td><td>${p.config.name}</td><td>${p.config.brand}</td><td>${p.config.lumens.toLocaleString()}</td><td>${p.config.resolution}</td><td>${p.currentLensId}</td></tr>`).join('')}
            </table>
            ${notes ? `<div class="notes"><h3>Notes</h3><p>${notes}</p></div>` : ''}
            <p style="color:#888; font-size:12px;">G√©n√©r√© par Projector Studio</p>
            </body></html>
        `);
        reportWindow.document.close();
        reportWindow.print();
    };
    
    window.selectProjectorModel = function(model) {
        selectedProjectorModel = model;
        // Update card selection
        document.querySelectorAll('.projector-card').forEach(card => {
            card.classList.remove('selected');
        });
        event.currentTarget.classList.add('selected');
        // Update lens options
        updateLensGridForModel(model);
    };
    
    function updateLensGridForModel(modelId) {
        const lensGrid = document.getElementById('lens-selection-grid');
        if (!lensGrid) return;
        
        const config = PROJECTOR_DATABASE[modelId];
        if (!config) return;
        
        lensGrid.innerHTML = '';
        
        config.compatibleLenses.forEach(lensId => {
            const lens = LENSES[lensId];
            if (lens) {
                const throwStr = lens.fixed ? `${lens.throwMin}:1 (fixe)` : `${lens.throwMin}-${lens.throwMax}:1`;
                const option = document.createElement('div');
                option.className = 'lens-option' + (lensId === selectedLensForNewProjector ? ' selected' : '');
                option.onclick = () => selectLensForNewProjector(lensId);
                option.innerHTML = `
                    <div class="lens-option-name">${lensId}</div>
                    <div class="lens-option-throw">${throwStr}</div>
                `;
                lensGrid.appendChild(option);
            }
        });
        
        // Auto-select default lens if current selection is not compatible
        if (!config.compatibleLenses.includes(selectedLensForNewProjector)) {
            selectedLensForNewProjector = config.defaultLens;
            updateLensGridForModel(modelId);
        }
    }
    
    window.selectLensForNewProjector = function(lensId) {
        selectedLensForNewProjector = lensId;
        document.querySelectorAll('.lens-option').forEach(opt => {
            opt.classList.remove('selected');
        });
        event.currentTarget.classList.add('selected');
    };
    
    window.openProjectorModal = function() {
        populateProjectorModal();
        document.getElementById('projector-modal').classList.add('show');
    };
    
    window.closeProjectorModal = function() {
        document.getElementById('projector-modal').classList.remove('show');
    };
    
    window.confirmProjectorCreation = function() {
        // Create new projector with selected model and lens
        const instance = createProjectorInstance(selectedProjectorModel);
        instance.currentLensId = selectedLensForNewProjector;
        instance.currentLens = LENSES[selectedLensForNewProjector];
        instance.throwRatio = instance.currentLens.throwMin;
        
        // New projectors should NOT be locked to target by default
        instance.targetLocked = false;
        instance.userMovedTarget = false;
        
        // Calculate spawn position (offset from existing projectors)
        const offset = projectors.length * 3;
        const spawnPos = new THREE.Vector3(offset, 0, 0);
        
        // Create Three.js objects
        createProjectorObjects(instance, spawnPos);
        
        // Add to projectors array
        projectors.push(instance);
        
        // AUTO-LOAD UV GRID for easy calibration
        loadUVGridForProjector(instance);
        
        // Record for undo
        pushHistory({
            type: 'create_projector',
            projectorId: instance.id
        });
        
        // Set as active and select it
        setActiveProjector(instance);
        selectObject(instance.mesh);
        
        // CRITICAL: Ensure the new projector is definitely unlocked after all syncs
        // This prevents any state contamination from previous projectors
        instance.targetLocked = false;
        instance.userMovedTarget = false;
        targetLocked = false;
        userMovedTarget = false;
        
        // Update UI checkbox to reflect unlocked state
        const targetLockedEl = document.getElementById('target-locked');
        if (targetLockedEl) targetLockedEl.checked = false;
        
        console.log(`Created new projector: ${selectedProjectorModel} #${instance.id} with lens ${selectedLensForNewProjector}, targetLocked=${instance.targetLocked}`);
        
        updateSceneHierarchy();
        updateProjectorCount(); // Update modern UI projector count
        populateScenePanel(); // Update scene objects panel
        closeProjectorModal();
    };
    
    // Helper function to create projector (used by undo/redo)
    function createAndAddProjector(modelId, lensId) {
        const instance = createProjectorInstance(modelId);
        instance.currentLensId = lensId || PROJECTOR_DATABASE[modelId]?.defaultLens || 'ET-D3LES20';
        instance.currentLens = LENSES[instance.currentLensId];
        instance.throwRatio = instance.currentLens.throwMin;
        instance.targetLocked = false;
        instance.userMovedTarget = false;
        
        const offset = projectors.length * 3;
        const spawnPos = new THREE.Vector3(offset, 0, 0);
        createProjectorObjects(instance, spawnPos);
        projectors.push(instance);
        setActiveProjector(instance);
        updateSceneHierarchy();
        return instance;
    }
    
    window.openPrimitivePopup = function(event) {
        event.stopPropagation();
        const popup = document.getElementById('primitive-popup');
        if (!popup) return;
        
        // Position popup near the clicked button
        const rect = event.target.getBoundingClientRect();
        popup.style.left = rect.left + 'px';
        popup.style.top = (rect.bottom + 5) + 'px';
        popup.classList.add('visible');
    };

    // Sync global state from active projector
    function syncFromActiveProjector() {
        if (!activeProjector) return;
        
        projectorGroup = activeProjector.group;
        projectorMesh = activeProjector.mesh;
        projectorCamera = activeProjector.camera;
        projectorHelper = activeProjector.helper;
        shadowLight = activeProjector.shadowLight;
        targetMesh = activeProjector.target;
        depthRenderTarget = activeProjector.depthRenderTarget;
        depthCamera = activeProjector.depthCamera;
        projectionTexture = activeProjector.projectionTexture;
        
        spriteWidth = activeProjector.spriteWidth;
        spriteHeight = activeProjector.spriteHeight;
        spriteTR = activeProjector.spriteTR;
        spriteInfo = activeProjector.spriteInfo;
        
        currentLens = activeProjector.currentLens;
        throwRatio = activeProjector.throwRatio;
        frustumFar = activeProjector.frustumFar;
        projDistance = activeProjector.projDistance;
        lensShiftV = activeProjector.lensShiftV;
        lensShiftH = activeProjector.lensShiftH;
        targetLocked = activeProjector.targetLocked;
        userMovedTarget = activeProjector.userMovedTarget;
        shadowSoftness = activeProjector.shadowSoftness;
        shadowBias = activeProjector.shadowBias;
        projectionIntensity = activeProjector.projectionIntensity;
        LUMENS = activeProjector.lumens;
        
        // Sync checkbox for projector position lock
        const projLockedCheck = document.getElementById('projector-locked-modern');
        if (projLockedCheck) projLockedCheck.checked = activeProjector.projectorLockedToTarget || false;
        
        keystoneV = activeProjector.keystoneV;
        keystoneH = activeProjector.keystoneH;
        keystoneTLX = activeProjector.keystoneTLX || 0;
        keystoneTLY = activeProjector.keystoneTLY || 0;
        keystoneTRX = activeProjector.keystoneTRX || 0;
        keystoneTRY = activeProjector.keystoneTRY || 0;
        keystoneBLX = activeProjector.keystoneBLX || 0;
        keystoneBLY = activeProjector.keystoneBLY || 0;
        keystoneBRX = activeProjector.keystoneBRX || 0;
        keystoneBRY = activeProjector.keystoneBRY || 0;
        
        softEdgeL = activeProjector.softEdgeL;
        softEdgeR = activeProjector.softEdgeR;
        softEdgeT = activeProjector.softEdgeT;
        softEdgeB = activeProjector.softEdgeB;
        softEdgeGamma = activeProjector.softEdgeGamma;
        
        // Sync Corner Pin values (with defaults if not set)
        cornerPinTLX = activeProjector.cornerPinTLX || 0;
        cornerPinTLY = activeProjector.cornerPinTLY || 0;
        cornerPinTRX = activeProjector.cornerPinTRX || 0;
        cornerPinTRY = activeProjector.cornerPinTRY || 0;
        cornerPinBLX = activeProjector.cornerPinBLX || 0;
        cornerPinBLY = activeProjector.cornerPinBLY || 0;
        cornerPinBRX = activeProjector.cornerPinBRX || 0;
        cornerPinBRY = activeProjector.cornerPinBRY || 0;
        
        currentProjectorModel = activeProjector.modelId;
        currentProjectorConfig = activeProjector.config;
        
        // Update UI sliders for keystone corners
        if (document.getElementById('keystone-tl-x')) {
            document.getElementById('keystone-tl-x').value = keystoneTLX;
            document.getElementById('keystone-tl-y').value = keystoneTLY;
            document.getElementById('keystone-tr-x').value = keystoneTRX;
            document.getElementById('keystone-tr-y').value = keystoneTRY;
            document.getElementById('keystone-bl-x').value = keystoneBLX;
            document.getElementById('keystone-bl-y').value = keystoneBLY;
            document.getElementById('keystone-br-x').value = keystoneBRX;
            document.getElementById('keystone-br-y').value = keystoneBRY;
            
            document.getElementById('keystone-tl-x-val').textContent = keystoneTLX;
            document.getElementById('keystone-tl-y-val').textContent = keystoneTLY;
            document.getElementById('keystone-tr-x-val').textContent = keystoneTRX;
            document.getElementById('keystone-tr-y-val').textContent = keystoneTRY;
            document.getElementById('keystone-bl-x-val').textContent = keystoneBLX;
            document.getElementById('keystone-bl-y-val').textContent = keystoneBLY;
            document.getElementById('keystone-br-x-val').textContent = keystoneBRX;
            document.getElementById('keystone-br-y-val').textContent = keystoneBRY;
        }
    }
    
    // Sync global state to active projector
    function syncToActiveProjector() {
        if (!activeProjector) return;
        
        activeProjector.throwRatio = throwRatio;
        activeProjector.frustumFar = frustumFar;
        activeProjector.projDistance = projDistance;
        activeProjector.lensShiftV = lensShiftV;
        activeProjector.lensShiftH = lensShiftH;
        activeProjector.targetLocked = targetLocked;
        activeProjector.userMovedTarget = userMovedTarget;
        activeProjector.shadowSoftness = shadowSoftness;
        activeProjector.shadowBias = shadowBias;
        activeProjector.projectionIntensity = projectionIntensity;
        activeProjector.projectionTexture = projectionTexture;
        
        activeProjector.keystoneV = keystoneV;
        activeProjector.keystoneH = keystoneH;
        activeProjector.keystoneTLX = keystoneTLX;
        activeProjector.keystoneTLY = keystoneTLY;
        activeProjector.keystoneTRX = keystoneTRX;
        activeProjector.keystoneTRY = keystoneTRY;
        activeProjector.keystoneBLX = keystoneBLX;
        activeProjector.keystoneBLY = keystoneBLY;
        activeProjector.keystoneBRX = keystoneBRX;
        activeProjector.keystoneBRY = keystoneBRY;
        
        activeProjector.softEdgeL = softEdgeL;
        activeProjector.softEdgeR = softEdgeR;
        activeProjector.softEdgeT = softEdgeT;
        activeProjector.softEdgeB = softEdgeB;
        activeProjector.softEdgeGamma = softEdgeGamma;
        
        // Sync Corner Pin values
        activeProjector.cornerPinTLX = cornerPinTLX;
        activeProjector.cornerPinTLY = cornerPinTLY;
        activeProjector.cornerPinTRX = cornerPinTRX;
        activeProjector.cornerPinTRY = cornerPinTRY;
        activeProjector.cornerPinBLX = cornerPinBLX;
        activeProjector.cornerPinBLY = cornerPinBLY;
        activeProjector.cornerPinBRX = cornerPinBRX;
        activeProjector.cornerPinBRY = cornerPinBRY;
        
        activeProjector.currentLens = currentLens;
    }

    // Switch active projector
    function setActiveProjector(projector) {
        // Save current state to old projector
        syncToActiveProjector();
        
        // Set new active projector
        activeProjector = projector;
        
        // Load state from new projector
        syncFromActiveProjector();
        
        // Update UI
        updateProjectorUI();
        updateAll();
    }
    
    // Update UI to reflect active projector
    function updateProjectorUI() {
        if (!activeProjector) return;
        
        const config = activeProjector.config;
        
        const brandEl = document.getElementById('proj-brand');
        const nameEl = document.getElementById('proj-model-name');
        const specsEl = document.getElementById('proj-specs');
        
        if (brandEl) brandEl.textContent = config.brand;
        if (nameEl) nameEl.textContent = config.name + ' #' + activeProjector.id;
        
        // Update target selector and lock aim button
        
        updateLockAimButton();
        
        // Update lock buttons state (old ones, kept for compatibility)
        updateLockTargetButton();
        updateProjectorLockButton();
        if (specsEl) specsEl.textContent = `${config.lumens.toLocaleString()} lm ‚Ä¢ ${config.resolution.split(' ')[0]} ‚Ä¢ 16:10`;
        
        // Update lens selector
        updateLensSelector(config.compatibleLenses, activeProjector.currentLensId);
        
        // Update all slider values
        const zoomEl = document.getElementById('zoom');
        if (zoomEl) {
            zoomEl.min = activeProjector.currentLens.throwMin;
            zoomEl.max = activeProjector.currentLens.throwMax;
            zoomEl.value = throwRatio;
            zoomEl.disabled = !!activeProjector.currentLens.fixed;
        }
        
        const shiftVEl = document.getElementById('shift-v');
        if (shiftVEl) {
            shiftVEl.min = activeProjector.currentLens.shiftV[0];
            shiftVEl.max = activeProjector.currentLens.shiftV[1];
            shiftVEl.value = lensShiftV;
        }
        
        const shiftHEl = document.getElementById('shift-h');
        if (shiftHEl) {
            shiftHEl.min = activeProjector.currentLens.shiftH[0];
            shiftHEl.max = activeProjector.currentLens.shiftH[1];
            shiftHEl.value = lensShiftH;
        }
        
        // Update keystone sliders
        const keystoneVEl = document.getElementById('keystone-v');
        const keystoneHEl = document.getElementById('keystone-h');
        const keystoneTLEl = document.getElementById('keystone-tl');
        const keystoneTREl = document.getElementById('keystone-tr');
        const keystoneBLEl = document.getElementById('keystone-bl');
        const keystoneBREl = document.getElementById('keystone-br');
        
        if (keystoneVEl) keystoneVEl.value = keystoneV;
        if (keystoneHEl) keystoneHEl.value = keystoneH;
        if (keystoneTLEl) keystoneTLEl.value = keystoneTL;
        if (keystoneTREl) keystoneTREl.value = keystoneTR;
        if (keystoneBLEl) keystoneBLEl.value = keystoneBL;
        if (keystoneBREl) keystoneBREl.value = keystoneBR;
        
        // Update keystone value displays
        const keystoneVVal = document.getElementById('keystone-v-val');
        const keystoneHVal = document.getElementById('keystone-h-val');
        const keystoneTLVal = document.getElementById('keystone-tl-val');
        const keystoneTRVal = document.getElementById('keystone-tr-val');
        const keystoneBLVal = document.getElementById('keystone-bl-val');
        const keystoneBRVal = document.getElementById('keystone-br-val');
        
        if (keystoneVVal) keystoneVVal.textContent = keystoneV;
        if (keystoneHVal) keystoneHVal.textContent = keystoneH;
        if (keystoneTLVal) keystoneTLVal.textContent = keystoneTL;
        if (keystoneTRVal) keystoneTRVal.textContent = keystoneTR;
        if (keystoneBLVal) keystoneBLVal.textContent = keystoneBL;
        if (keystoneBRVal) keystoneBRVal.textContent = keystoneBR;
        
        // Update soft edge sliders
        const softEdgeLEl = document.getElementById('softedge-l');
        const softEdgeREl = document.getElementById('softedge-r');
        const softEdgeTEl = document.getElementById('softedge-t');
        const softEdgeBEl = document.getElementById('softedge-b');
        const softEdgeGammaEl = document.getElementById('softedge-gamma');
        
        if (softEdgeLEl) softEdgeLEl.value = softEdgeL;
        if (softEdgeREl) softEdgeREl.value = softEdgeR;
        if (softEdgeTEl) softEdgeTEl.value = softEdgeT;
        if (softEdgeBEl) softEdgeBEl.value = softEdgeB;
        if (softEdgeGammaEl) softEdgeGammaEl.value = softEdgeGamma;
        
        // Update soft edge value displays
        const softEdgeLVal = document.getElementById('softedge-l-val');
        const softEdgeRVal = document.getElementById('softedge-r-val');
        const softEdgeTVal = document.getElementById('softedge-t-val');
        const softEdgeBVal = document.getElementById('softedge-b-val');
        const softEdgeGammaVal = document.getElementById('softedge-gamma-val');
        
        if (softEdgeLVal) softEdgeLVal.textContent = softEdgeL + '%';
        if (softEdgeRVal) softEdgeRVal.textContent = softEdgeR + '%';
        if (softEdgeTVal) softEdgeTVal.textContent = softEdgeT + '%';
        if (softEdgeBVal) softEdgeBVal.textContent = softEdgeB + '%';
        if (softEdgeGammaVal) softEdgeGammaVal.textContent = softEdgeGamma.toFixed(1);
        
        // Update target lock checkbox
        const targetLockedEl = document.getElementById('target-locked');
        if (targetLockedEl) targetLockedEl.checked = targetLocked;
    }

    window.switchProjectorModel = function(modelId) {
        // CREATE a new projector instead of just switching model
        createNewProjector(modelId);
    };
    
    // Create a new projector and add it to the scene
    window.createNewProjector = function(modelId) {
        const config = PROJECTOR_DATABASE[modelId];
        if (!config) {
            console.error('Unknown projector model:', modelId);
            return null;
        }
        
        // Create instance data
        const instance = createProjectorInstance(modelId);
        
        // New projectors should NOT be locked to target by default
        instance.targetLocked = false;
        instance.userMovedTarget = false;
        
        // Calculate spawn position (offset from existing projectors)
        const offset = projectors.length * 3;
        const spawnPos = new THREE.Vector3(offset, 0, 0);
        
        // Create Three.js objects for this projector
        createProjectorObjects(instance, spawnPos);
        
        // Add to projectors array
        projectors.push(instance);
        
        // Set as active and select it
        setActiveProjector(instance);
        selectObject(instance.mesh);
        
        // CRITICAL: Ensure the new projector is definitely unlocked after all syncs
        // This prevents any state contamination from previous projectors
        instance.targetLocked = false;
        instance.userMovedTarget = false;
        targetLocked = false;
        userMovedTarget = false;
        
        // Update UI checkbox to reflect unlocked state
        const targetLockedEl = document.getElementById('target-locked');
        if (targetLockedEl) targetLockedEl.checked = false;
        
        console.log(`Created new projector: ${modelId} #${instance.id}, targetLocked=${instance.targetLocked}`);
        return instance;
    };

    // Camera view presets
    window.setCameraView = function(view) {
        console.log('üé• Changing camera view to:', view);
        
        // Always center at world origin (0, 0, 0)
        const targetPos = new THREE.Vector3(0, 0, 0);
        const distance = 20;
        
        switch(view) {
            case 'top':
                camera.position.set(0, distance, 0);
                camera.up.set(0, 0, -1);
                break;
            case 'bottom':
                camera.position.set(0, -distance, 0);
                camera.up.set(0, 0, 1);
                break;
            case 'front':
                camera.position.set(0, 0, distance);
                camera.up.set(0, 1, 0);
                break;
            case 'left':
                camera.position.set(-distance, 0, 0);
                camera.up.set(0, 1, 0);
                break;
            case 'right':
                camera.position.set(distance, 0, 0);
                camera.up.set(0, 1, 0);
                break;
            case 'back':
                camera.position.set(0, 0, -distance);
                camera.up.set(0, 1, 0);
                break;
            case 'perspective':
            default:
                camera.position.set(8, 6, 8);
                camera.up.set(0, 1, 0);
                break;
        }
        
        // Look at and center on world origin
        camera.lookAt(targetPos);
        controls.target.copy(targetPos);
        controls.update();
        
        console.log('‚úì Camera view changed, centered at (0,0,0)');
    };

    function updateLensSelector(compatibleLenses, defaultLens) {
        const lensSelect = document.getElementById('lens-select');
        if (!lensSelect) return;
        
        lensSelect.innerHTML = '';
        
        compatibleLenses.forEach(lensId => {
            const lens = LENSES[lensId];
            if (lens) {
                const option = document.createElement('option');
                option.value = lensId;
                const throwStr = lens.fixed ? `${lens.throwMin}:1` : `${lens.throwMin}-${lens.throwMax}:1`;
                option.textContent = `${lensId} (${throwStr})`;
                if (lensId === defaultLens) {
                    option.selected = true;
                }
                lensSelect.appendChild(option);
            }
        });
        
        // Trigger lens change to update UI
        changeLens();
    }

    // Create Three.js objects for a projector instance
    function createProjectorObjects(instance, position = new THREE.Vector3(0, 0, 0)) {
        const config = instance.config;
        const defaultThrow = instance.throwRatio;
        
        // Create group
        const group = new THREE.Group();
        group.position.copy(position);
        scene.add(group);
        instance.group = group;

        // Create projector mesh
        const s = 0.0015;
        const geo = new THREE.BoxGeometry(550*s, 220*s, 570*s);
        // Different colors for different projectors
        const colors = [0x1a1a1a, 0x2a1a1a, 0x1a2a1a, 0x1a1a2a, 0x2a2a1a];
        const colorIndex = (instance.id - 1) % colors.length;
        const mat = new THREE.MeshStandardMaterial({ color: colors[colorIndex], metalness:0.8, roughness:0.2 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.z = 570*s/2;
        mesh.userData = { 
            type:'projector', 
            name: config.name + ' #' + instance.id, 
            isProjector: true, 
            noProjection: true,
            projectorInstance: instance
        };
        mesh.castShadow = false;
        mesh.receiveShadow = false;
        group.add(mesh);
        selectableObjects.push(mesh);
        instance.mesh = mesh;

        // Create lens visual
        const lensGeo = new THREE.CylinderGeometry(0.08,0.10,0.04,32);
        const lensColors = [0x00ffff, 0xff00ff, 0xffff00, 0x00ff00, 0xff8800];
        const lensMat = new THREE.MeshBasicMaterial({ color: lensColors[colorIndex] });
        const lens = new THREE.Mesh(lensGeo, lensMat);
        lens.rotation.x = Math.PI/2;
        lens.position.z = -570*s/2 - 0.02;
        lens.castShadow = false;
        lens.receiveShadow = false;
        mesh.add(lens);

        // Create projector camera
        const projCam = new THREE.PerspectiveCamera(throwToFOV(defaultThrow), ASPECT, 0.1, PROJECTOR_CAMERA_FAR);
        group.add(projCam);
        instance.camera = projCam;

        // Create spotlight for shadow map generation
        const light = new THREE.SpotLight(0xffffff, 0.001);
        light.angle = THREE.MathUtils.degToRad(throwToFOV(defaultThrow) / 2);
        light.penumbra = 0;
        light.decay = 0;
        light.distance = 0;
        light.castShadow = true;
        light.shadow.mapSize.width = 2048;
        light.shadow.mapSize.height = 2048;
        light.shadow.camera.near = 0.1;
        light.shadow.camera.far = instance.frustumFar;
        light.shadow.camera.aspect = ASPECT;
        light.shadow.radius = 2;
        light.shadow.bias = -0.0001;
        light.position.set(0,0,0);
        group.add(light);
        instance.shadowLight = light;

        // Create shadow target
        const shadowTarget = new THREE.Object3D();
        shadowTarget.position.set(0,0,-instance.projDistance);
        group.add(shadowTarget);
        light.target = shadowTarget;
        mesh.userData.shadowTarget = shadowTarget;

        // Create frustum helper
        const helper = createOffAxisFrustumHelperForInstance(instance);
        helper.visible = true;
        helper.layers.set(1);
        helper.traverse(child => {
            child.layers.set(1);
            child.castShadow = false;
            child.receiveShadow = false;
        });
        scene.add(helper);
        instance.helper = helper;

        // Create target mesh
        const tGeo = new THREE.SphereGeometry(0.15, 32, 32);
        const targetColors = [0xffff00, 0xff00ff, 0x00ffff, 0xff8800, 0x88ff00];
        const tMat = new THREE.MeshBasicMaterial({ color: targetColors[colorIndex] });
        const target = new THREE.Mesh(tGeo, tMat);
        target.position.set(position.x, position.y, position.z - instance.projDistance);
        target.castShadow = false;
        target.receiveShadow = false;
        target.userData = { 
            type:'target', 
            name:'Target #' + instance.id, 
            isTarget: true,
            projectorInstance: instance
        };
        scene.add(target);
        selectableObjects.push(target);
        instance.target = target;
        mesh.userData.target = target;

        // Create depth render target for this projector
        const depthRT = new THREE.WebGLRenderTarget(2048, 2048, {
            minFilter: THREE.NearestFilter,
            magFilter: THREE.NearestFilter,
            format: THREE.RGBAFormat,
            type: THREE.FloatType
        });
        instance.depthRenderTarget = depthRT;

        // Create depth camera
        const dCam = new THREE.PerspectiveCamera(throwToFOV(defaultThrow), ASPECT, 0.1, instance.frustumFar);
        instance.depthCamera = dCam;

        // Create measurement sprites for this projector
        instance.spriteWidth = createTextSprite('0.00 m');
        instance.spriteHeight = createTextSprite('0.00 m');
        instance.spriteTR = createTextSprite('tr: 0.00');
        instance.spriteInfo = createTextSprite('P' + instance.id + '\n0 lx');
        scene.add(instance.spriteWidth);
        scene.add(instance.spriteHeight);
        scene.add(instance.spriteTR);
        scene.add(instance.spriteInfo);
    }

    // Create frustum helper for a specific instance
    function createOffAxisFrustumHelperForInstance(instance) {
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(24 * 3);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const helperColors = [0xffaa00, 0xff00aa, 0xaaff00, 0x00aaff, 0xaa00ff];
        const colorIndex = (instance.id - 1) % helperColors.length;
        
        const material = new THREE.LineBasicMaterial({ 
            color: helperColors[colorIndex],
            depthTest: true,
            depthWrite: false
        });
        
        const helper = new THREE.LineSegments(geometry, material);
        helper.matrixAutoUpdate = false;
        helper.userData.projectorInstance = instance;
        
        helper.update = function() {
            updateOffAxisFrustumHelperForInstance(helper, instance);
        };
        
        return helper;
    }

    // Legacy createProjector - creates first projector using new system
    function createProjector() {
        const instance = createProjectorInstance('PT-RQ25K');
        createProjectorObjects(instance, new THREE.Vector3(0, 0, 0));
        projectors.push(instance);
        setActiveProjector(instance);
    }

    // Custom depth rendering for accurate occlusion
    function createDepthRenderer() {
        // Create render target for custom depth map
        depthRenderTarget = new THREE.WebGLRenderTarget(2048, 2048, {
            minFilter: THREE.NearestFilter,
            magFilter: THREE.NearestFilter,
            format: THREE.RGBAFormat,
            type: THREE.FloatType
        });

        // Depth camera that mirrors the projector camera
        depthCamera = new THREE.PerspectiveCamera(throwToFOV(throwRatio), ASPECT, 0.1, frustumFar);

        // Constant far for depth map - must capture ALL scene geometry
        const DEPTH_MAP_FAR = 200;

        // Custom depth material that writes linear depth
        depthMaterial = new THREE.ShaderMaterial({
            vertexShader: `
                varying float vDepth;
                uniform float cameraNear;
                uniform float cameraFar;
                
                void main() {
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    // Linear depth normalized to [0, 1]
                    vDepth = (-mvPosition.z - cameraNear) / (cameraFar - cameraNear);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                varying float vDepth;
                
                void main() {
                    // Store linear depth in red channel
                    gl_FragColor = vec4(vDepth, vDepth, vDepth, 1.0);
                }
            `,
            uniforms: {
                cameraNear: { value: 0.1 },
                cameraFar: { value: DEPTH_MAP_FAR }
            }
        });
        
        // Store constant for later use
        window.DEPTH_MAP_FAR = DEPTH_MAP_FAR;
    }

    // Render depth pass from projector's point of view
    function renderDepthPass() {
        if (!depthCamera || !depthRenderTarget || !depthMaterial) return;

        // Use constant far to capture ALL scene geometry
        const DEPTH_FAR = window.DEPTH_MAP_FAR || 200;

        // Update depth camera to match projector position/rotation
        // IMPORTANT: Do NOT apply lens shift to depth camera!
        // Shadows are based on physical light rays, not the shifted projection.
        // Lens shift only affects UV mapping (where the image appears), not shadow geometry.
        depthCamera.position.copy(projectorGroup.position);
        depthCamera.quaternion.copy(projectorGroup.quaternion);
        depthCamera.fov = throwToFOV(throwRatio);
        depthCamera.aspect = ASPECT;
        depthCamera.near = 0.1;
        depthCamera.far = DEPTH_FAR;
        depthCamera.updateProjectionMatrix();
        // NO lens shift here - shadows stay fixed
        depthCamera.updateMatrixWorld(true);

        // Update depth material uniforms
        depthMaterial.uniforms.cameraNear.value = depthCamera.near;
        depthMaterial.uniforms.cameraFar.value = DEPTH_FAR;

        // Store original materials and replace with depth material
        const originalMaterials = new Map();
        const originalVisibility = new Map();
        
        scene.traverse(obj => {
            if (obj.isMesh) {
                originalMaterials.set(obj, obj.material);
                originalVisibility.set(obj, obj.visible);
                
                // Only render objects that should cast shadows (not helpers, labels, etc.)
                if (obj.userData.noProjection || obj.userData.isLabel || obj.userData.isProjector || obj.userData.isTarget) {
                    obj.visible = false;
                } else if (obj.castShadow) {
                    obj.material = depthMaterial;
                } else {
                    obj.visible = false;
                }
            }
        });

        // Also hide helpers
        if (projectorHelper) projectorHelper.visible = false;
        if (transformControls) transformControls.visible = false;

        // Render to depth target
        renderer.setRenderTarget(depthRenderTarget);
        renderer.clear();
        renderer.render(scene, depthCamera);
        renderer.setRenderTarget(null);

        // Restore original materials and visibility
        scene.traverse(obj => {
            if (obj.isMesh && originalMaterials.has(obj)) {
                obj.material = originalMaterials.get(obj);
                obj.visible = originalVisibility.get(obj);
            }
        });

        // Restore helpers
        if (projectorHelper) projectorHelper.visible = document.getElementById('show-frustum')?.checked ?? true;
        if (transformControls) transformControls.visible = true;
    }

    function createMeasurementSprites() {
        spriteWidth = createTextSprite('0.00 m');
        spriteHeight = createTextSprite('0.00 m');
        spriteTR = createTextSprite('tr: 0.00');
        spriteInfo = createTextSprite('P1\n0 lx');
        scene.add(spriteWidth);
        scene.add(spriteHeight);
        scene.add(spriteTR);
        scene.add(spriteInfo);
    }

    function createTextSprite(text) {
        const canvas = document.createElement('canvas');
        canvas.width = 256; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent:true, side:THREE.DoubleSide, depthTest:false });
        const geometry = new THREE.PlaneGeometry(1.5, 0.375);
        const mesh = new THREE.Mesh(geometry, material);
        mesh.userData.canvas = canvas; mesh.userData.ctx = ctx; mesh.userData.texture = texture;
        mesh.userData.isLabel = true;
        updateSpriteText(mesh, text);
        return mesh;
    }

    function updateSpriteText(sprite, text) {
        const ctx = sprite.userData.ctx; const canvas = sprite.userData.canvas;
        ctx.clearRect(0,0,canvas.width, canvas.height);
        ctx.fillStyle = '#c0c0c0'; ctx.font = 'bold 22px monospace'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(text, canvas.width/2, canvas.height/2);
        sprite.userData.texture.needsUpdate = true;
    }

    function throwToFOV(tr) {
        const hFov = 2 * Math.atan(1 / (2 * tr));
        const vFov = 2 * Math.atan(Math.tan(hFov/2) / ASPECT);
        return THREE.MathUtils.radToDeg(vFov);
    }

    /**
     * Create custom off-axis frustum helper that properly visualizes lens shift.
     * Unlike CameraHelper, this shows the actual shifted frustum direction.
     */
    function createOffAxisFrustumHelper() {
        const geometry = new THREE.BufferGeometry();
        // 24 vertices for 12 line segments (8 edges + 4 diagonals from apex)
        const positions = new Float32Array(24 * 3);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const material = new THREE.LineBasicMaterial({ 
            color: 0xffaa00,
            depthTest: true,
            depthWrite: false
        });
        
        const helper = new THREE.LineSegments(geometry, material);
        helper.matrixAutoUpdate = false;
        
        // Custom update method
        helper.update = function() {
            updateOffAxisFrustumHelper(helper);
        };
        
        return helper;
    }
    
    /**
     * Update frustum helper for a specific projector instance
     */
    function updateOffAxisFrustumHelperForInstance(helper, instance) {
        if (!instance.group || !helper) return;
        
        const fovRad = THREE.MathUtils.degToRad(throwToFOV(instance.throwRatio));
        const near = 0.1;
        const far = instance.frustumFar;
        
        const nearHalfV = near * Math.tan(fovRad / 2);
        const nearHalfH = nearHalfV * ASPECT;
        const farHalfV = far * Math.tan(fovRad / 2);
        const farHalfH = farHalfV * ASPECT;
        
        const shiftH = instance.lensShiftH / 100;
        const shiftV = instance.lensShiftV / 100;
        
        const nbl = new THREE.Vector3(nearHalfH * (-1 + 2 * shiftH), nearHalfV * (-1 + 2 * shiftV), -near);
        const nbr = new THREE.Vector3(nearHalfH * (1 + 2 * shiftH), nearHalfV * (-1 + 2 * shiftV), -near);
        const ntr = new THREE.Vector3(nearHalfH * (1 + 2 * shiftH), nearHalfV * (1 + 2 * shiftV), -near);
        const ntl = new THREE.Vector3(nearHalfH * (-1 + 2 * shiftH), nearHalfV * (1 + 2 * shiftV), -near);
        
        const fbl = new THREE.Vector3(farHalfH * (-1 + 2 * shiftH), farHalfV * (-1 + 2 * shiftV), -far);
        const fbr = new THREE.Vector3(farHalfH * (1 + 2 * shiftH), farHalfV * (-1 + 2 * shiftV), -far);
        const ftr = new THREE.Vector3(farHalfH * (1 + 2 * shiftH), farHalfV * (1 + 2 * shiftV), -far);
        const ftl = new THREE.Vector3(farHalfH * (-1 + 2 * shiftH), farHalfV * (1 + 2 * shiftV), -far);
        
        const worldMatrix = instance.group.matrixWorld;
        [nbl, nbr, ntr, ntl, fbl, fbr, ftr, ftl].forEach(p => p.applyMatrix4(worldMatrix));
        
        const positions = helper.geometry.attributes.position.array;
        let i = 0;
        const addLine = (a, b) => {
            positions[i++] = a.x; positions[i++] = a.y; positions[i++] = a.z;
            positions[i++] = b.x; positions[i++] = b.y; positions[i++] = b.z;
        };
        
        addLine(nbl, nbr); addLine(nbr, ntr); addLine(ntr, ntl); addLine(ntl, nbl);
        addLine(fbl, fbr); addLine(fbr, ftr); addLine(ftr, ftl); addLine(ftl, fbl);
        addLine(nbl, fbl); addLine(nbr, fbr); addLine(ntr, ftr); addLine(ntl, ftl);
        
        helper.geometry.attributes.position.needsUpdate = true;
    }
    
    /**
     * Update the off-axis frustum helper geometry based on current lens shift.
     * This creates an asymmetric frustum that matches the off-axis projection matrix.
     * 
     * Off-axis projection via pm[8]/pm[9] maps NDC coordinates as:
     *   x = halfH * (ndc_x + 2*shiftH)
     *   y = halfV * (ndc_y + 2*shiftV)
     * 
     * This creates a sheared frustum where the apex stays at origin but
     * the projection direction tilts - exactly matching real lens shift behavior.
     */
    function updateOffAxisFrustumHelper(helper) {
        if (!projectorGroup || !helper) return;
        
        const fovRad = THREE.MathUtils.degToRad(throwToFOV(throwRatio));
        const near = 0.1;
        const far = frustumFar;
        
        // Calculate frustum half-extents at near and far planes
        const nearHalfV = near * Math.tan(fovRad / 2);
        const nearHalfH = nearHalfV * ASPECT;
        const farHalfV = far * Math.tan(fovRad / 2);
        const farHalfH = farHalfV * ASPECT;
        
        // Lens shift as fraction
        const shiftH = lensShiftH / 100;
        const shiftV = lensShiftV / 100;
        
        // Off-axis frustum corners: x = halfH * (ndc + 2*shift)
        // Near plane corners (ndc: bl=(-1,-1), br=(1,-1), tr=(1,1), tl=(-1,1))
        const nbl = new THREE.Vector3(
            nearHalfH * (-1 + 2 * shiftH),
            nearHalfV * (-1 + 2 * shiftV),
            -near
        );
        const nbr = new THREE.Vector3(
            nearHalfH * (1 + 2 * shiftH),
            nearHalfV * (-1 + 2 * shiftV),
            -near
        );
        const ntr = new THREE.Vector3(
            nearHalfH * (1 + 2 * shiftH),
            nearHalfV * (1 + 2 * shiftV),
            -near
        );
        const ntl = new THREE.Vector3(
            nearHalfH * (-1 + 2 * shiftH),
            nearHalfV * (1 + 2 * shiftV),
            -near
        );
        
        // Far plane corners
        const fbl = new THREE.Vector3(
            farHalfH * (-1 + 2 * shiftH),
            farHalfV * (-1 + 2 * shiftV),
            -far
        );
        const fbr = new THREE.Vector3(
            farHalfH * (1 + 2 * shiftH),
            farHalfV * (-1 + 2 * shiftV),
            -far
        );
        const ftr = new THREE.Vector3(
            farHalfH * (1 + 2 * shiftH),
            farHalfV * (1 + 2 * shiftV),
            -far
        );
        const ftl = new THREE.Vector3(
            farHalfH * (-1 + 2 * shiftH),
            farHalfV * (1 + 2 * shiftV),
            -far
        );
        
        // Transform all points to world space
        const worldMatrix = projectorGroup.matrixWorld;
        [nbl, nbr, ntr, ntl, fbl, fbr, ftr, ftl].forEach(p => p.applyMatrix4(worldMatrix));
        
        // Build line segments
        const positions = helper.geometry.attributes.position.array;
        let i = 0;
        
        // Helper to add a line segment
        const addLine = (a, b) => {
            positions[i++] = a.x; positions[i++] = a.y; positions[i++] = a.z;
            positions[i++] = b.x; positions[i++] = b.y; positions[i++] = b.z;
        };
        
        // Near plane edges
        addLine(nbl, nbr);
        addLine(nbr, ntr);
        addLine(ntr, ntl);
        addLine(ntl, nbl);
        
        // Far plane edges
        addLine(fbl, fbr);
        addLine(fbr, ftr);
        addLine(ftr, ftl);
        addLine(ftl, fbl);
        
        // Connecting edges (near to far)
        addLine(nbl, fbl);
        addLine(nbr, fbr);
        addLine(ntr, ftr);
        addLine(ntl, ftl);
        
        helper.geometry.attributes.position.needsUpdate = true;
    }

    /**
     * Apply lens shift via off-axis projection matrix modification.
     * This creates an asymmetric frustum that rotates around the projector.
     * 
     * In real projectors, lens shift moves the DMD/sensor within the lens,
     * which creates the same optical effect as this off-axis projection.
     * The frustum tilts, but there's NO parallax because all points on a ray
     * map to the same UV coordinate (property of projective transforms).
     * 
     * The key is that pm[8] and pm[9] add a skew to the projection that
     * shifts the frustum asymmetrically while maintaining correct UV mapping.
     */
    function applyLensShiftToCamera(camera, shiftH_frac, shiftV_frac) {
        camera.updateProjectionMatrix();
        const pm = camera.projectionMatrix.elements;
        // pm[8] shifts horizontally (multiply by 2 for proper NDC range [-1,1] -> [0,1])
        // pm[9] shifts vertically
        // Signs: positive shiftH = image shifts right, positive shiftV = image shifts up
        pm[8] = 2.0 * shiftH_frac;
        pm[9] = 2.0 * shiftV_frac;
    }

    /**
     * MULTI-PROJECTOR SHADER - WebGL 1.0 Compatible
     */
    const MAX_PROJECTORS = 4;
    
    function createProjectedMaterial() {
        const uniforms = {
            baseColor: { value: new THREE.Color(0x888888) },
            dirLightDir: { value: new THREE.Vector3(0.5, 0.8, 0.5).normalize() },
            ambientLightIntensity: { value: 0.1 },  // NEW: For ambient light
            directionalLightIntensity: { value: 0.5 }, // NEW: For directional light
        };
        
        for (let i = 0; i < MAX_PROJECTORS; i++) {
            uniforms[`projTexture${i}`] = { value: defaultProjectionTexture };
            uniforms[`projMatrix${i}`] = { value: new THREE.Matrix4() };
            uniforms[`projPosition${i}`] = { value: new THREE.Vector3() };
            uniforms[`hasTexture${i}`] = { value: false };
            uniforms[`intensity${i}`] = { value: 1.0 };
            uniforms[`projectorActive${i}`] = { value: i === 0 };
            uniforms[`shadowMap${i}`] = { value: defaultShadowTexture };
            uniforms[`shadowViewMatrix${i}`] = { value: new THREE.Matrix4() };
            uniforms[`shadowMatrix${i}`] = { value: new THREE.Matrix4() };
            uniforms[`shadowBias${i}`] = { value: 0.003 };
            uniforms[`depthMapFar${i}`] = { value: 200 };
            uniforms[`projectionFar${i}`] = { value: 500 };
            // Keystone uniforms (global + corners with X/Y control)
            uniforms[`keystoneV${i}`] = { value: 0.0 };
            uniforms[`keystoneH${i}`] = { value: 0.0 };
            uniforms[`keystoneTLX${i}`] = { value: 0.0 };
            uniforms[`keystoneTLY${i}`] = { value: 0.0 };
            uniforms[`keystoneTRX${i}`] = { value: 0.0 };
            uniforms[`keystoneTRY${i}`] = { value: 0.0 };
            uniforms[`keystoneBLX${i}`] = { value: 0.0 };
            uniforms[`keystoneBLY${i}`] = { value: 0.0 };
            uniforms[`keystoneBRX${i}`] = { value: 0.0 };
            uniforms[`keystoneBRY${i}`] = { value: 0.0 };
            // Soft edge uniforms
            uniforms[`softEdgeL${i}`] = { value: 0.0 };
            uniforms[`softEdgeR${i}`] = { value: 0.0 };
            uniforms[`softEdgeT${i}`] = { value: 0.0 };
            uniforms[`softEdgeB${i}`] = { value: 0.0 };
            uniforms[`softEdgeGamma${i}`] = { value: 2.2 };
            // Corner Pin uniforms
            uniforms[`cornerPinTLX${i}`] = { value: 0.0 };
            uniforms[`cornerPinTLY${i}`] = { value: 0.0 };
            uniforms[`cornerPinTRX${i}`] = { value: 0.0 };
            uniforms[`cornerPinTRY${i}`] = { value: 0.0 };
            uniforms[`cornerPinBLX${i}`] = { value: 0.0 };
            uniforms[`cornerPinBLY${i}`] = { value: 0.0 };
            uniforms[`cornerPinBRX${i}`] = { value: 0.0 };
            uniforms[`cornerPinBRY${i}`] = { value: 0.0 };
        }
        
        return new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: `
                varying vec3 vNormal;
                varying vec3 vWorldPos;
                varying vec4 vProjCoords0, vProjCoords1, vProjCoords2, vProjCoords3;
                varying vec4 vShadowCoord0, vShadowCoord1, vShadowCoord2, vShadowCoord3;

                uniform mat4 projMatrix0, projMatrix1, projMatrix2, projMatrix3;
                uniform mat4 shadowMatrix0, shadowMatrix1, shadowMatrix2, shadowMatrix3;

                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPos = worldPosition.xyz;
                    
                    vProjCoords0 = projMatrix0 * worldPosition;
                    vProjCoords1 = projMatrix1 * worldPosition;
                    vProjCoords2 = projMatrix2 * worldPosition;
                    vProjCoords3 = projMatrix3 * worldPosition;
                    
                    vShadowCoord0 = shadowMatrix0 * worldPosition;
                    vShadowCoord1 = shadowMatrix1 * worldPosition;
                    vShadowCoord2 = shadowMatrix2 * worldPosition;
                    vShadowCoord3 = shadowMatrix3 * worldPosition;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                precision highp float;

                uniform vec3 baseColor;
                uniform vec3 dirLightDir;
                uniform float ambientLightIntensity;
                uniform float directionalLightIntensity;
                
                uniform sampler2D projTexture0, projTexture1, projTexture2, projTexture3;
                uniform vec3 projPosition0, projPosition1, projPosition2, projPosition3;
                uniform bool hasTexture0, hasTexture1, hasTexture2, hasTexture3;
                uniform float intensity0, intensity1, intensity2, intensity3;
                uniform bool projectorActive0, projectorActive1, projectorActive2, projectorActive3;
                uniform sampler2D shadowMap0, shadowMap1, shadowMap2, shadowMap3;
                uniform mat4 shadowViewMatrix0, shadowViewMatrix1, shadowViewMatrix2, shadowViewMatrix3;
                uniform float shadowBias0, shadowBias1, shadowBias2, shadowBias3;
                uniform float depthMapFar0, depthMapFar1, depthMapFar2, depthMapFar3;
                uniform float projectionFar0, projectionFar1, projectionFar2, projectionFar3;
                
                // Keystone uniforms
                uniform float keystoneV0, keystoneH0;
                uniform float keystoneTLX0, keystoneTLY0, keystoneTRX0, keystoneTRY0;
                uniform float keystoneBLX0, keystoneBLY0, keystoneBRX0, keystoneBRY0;
                
                uniform float keystoneV1, keystoneH1;
                uniform float keystoneTLX1, keystoneTLY1, keystoneTRX1, keystoneTRY1;
                uniform float keystoneBLX1, keystoneBLY1, keystoneBRX1, keystoneBRY1;
                
                uniform float keystoneV2, keystoneH2;
                uniform float keystoneTLX2, keystoneTLY2, keystoneTRX2, keystoneTRY2;
                uniform float keystoneBLX2, keystoneBLY2, keystoneBRX2, keystoneBRY2;
                
                uniform float keystoneV3, keystoneH3;
                uniform float keystoneTLX3, keystoneTLY3, keystoneTRX3, keystoneTRY3;
                uniform float keystoneBLX3, keystoneBLY3, keystoneBRX3, keystoneBRY3;
                
                // Soft edge uniforms
                uniform float softEdgeL0, softEdgeR0, softEdgeT0, softEdgeB0, softEdgeGamma0;
                uniform float softEdgeL1, softEdgeR1, softEdgeT1, softEdgeB1, softEdgeGamma1;
                uniform float softEdgeL2, softEdgeR2, softEdgeT2, softEdgeB2, softEdgeGamma2;
                uniform float softEdgeL3, softEdgeR3, softEdgeT3, softEdgeB3, softEdgeGamma3;
                
                // Corner Pin uniforms
                uniform float cornerPinTLX0, cornerPinTLY0, cornerPinTRX0, cornerPinTRY0;
                uniform float cornerPinBLX0, cornerPinBLY0, cornerPinBRX0, cornerPinBRY0;
                uniform float cornerPinTLX1, cornerPinTLY1, cornerPinTRX1, cornerPinTRY1;
                uniform float cornerPinBLX1, cornerPinBLY1, cornerPinBRX1, cornerPinBRY1;
                uniform float cornerPinTLX2, cornerPinTLY2, cornerPinTRX2, cornerPinTRY2;
                uniform float cornerPinBLX2, cornerPinBLY2, cornerPinBRX2, cornerPinBRY2;
                uniform float cornerPinTLX3, cornerPinTLY3, cornerPinTRX3, cornerPinTRY3;
                uniform float cornerPinBLX3, cornerPinBLY3, cornerPinBRX3, cornerPinBRY3;

                varying vec3 vNormal;
                varying vec3 vWorldPos;
                varying vec4 vProjCoords0, vProjCoords1, vProjCoords2, vProjCoords3;
                varying vec4 vShadowCoord0, vShadowCoord1, vShadowCoord2, vShadowCoord3;
                
                // Keystone: Define trapezoid corners and check if point is inside
                // Returns: vec4(textureUV.xy, isInside, 0)
                vec4 applyKeystoneWithBounds(vec2 uv, float kV, float kH, 
                    float kTLX, float kTLY, float kTRX, float kTRY, 
                    float kBLX, float kBLY, float kBRX, float kBRY) {
                    // Scale factor for keystone parameters
                    float scale = 0.005;
                    float cornerScale = 0.01;  // 1% per unit for corners (more amplitude)
                    
                    // Define trapezoid corners with INDEPENDENT X and Y control
                    // Bottom-left corner
                    vec2 bl = vec2(
                        -kV * scale + kBLX * cornerScale,     // X: kV + independent X control
                        -kH * scale + kBLY * cornerScale      // Y: kH + independent Y control
                    );
                    
                    // Bottom-right corner
                    vec2 br = vec2(
                        1.0 + kV * scale + kBRX * cornerScale,  // X: kV + independent X control
                        kH * scale + kBRY * cornerScale         // Y: kH + independent Y control
                    );
                    
                    // Top-left corner
                    vec2 tl = vec2(
                        kV * scale + kTLX * cornerScale,        // X: kV + independent X control
                        1.0 + kH * scale + kTLY * cornerScale   // Y: kH + independent Y control
                    );
                    
                    // Top-right corner
                    vec2 tr = vec2(
                        1.0 - kV * scale + kTRX * cornerScale,  // X: kV + independent X control
                        1.0 - kH * scale + kTRY * cornerScale   // Y: kH + independent Y control
                    );
                    
                    // Check if UV point is inside the trapezoid using cross product method
                    // For a convex quad, point is inside if it's on the same side of all edges
                    vec2 v0 = br - bl;
                    vec2 v1 = tr - br;
                    vec2 v2 = tl - tr;
                    vec2 v3 = bl - tl;
                    
                    vec2 p0 = uv - bl;
                    vec2 p1 = uv - br;
                    vec2 p2 = uv - tr;
                    vec2 p3 = uv - tl;
                    
                    float c0 = v0.x * p0.y - v0.y * p0.x;
                    float c1 = v1.x * p1.y - v1.y * p1.x;
                    float c2 = v2.x * p2.y - v2.y * p2.x;
                    float c3 = v3.x * p3.y - v3.y * p3.x;
                    
                    // Point is inside if all cross products have the same sign
                    bool inside = (c0 >= 0.0 && c1 >= 0.0 && c2 >= 0.0 && c3 >= 0.0) ||
                                  (c0 <= 0.0 && c1 <= 0.0 && c2 <= 0.0 && c3 <= 0.0);
                    
                    if (!inside) {
                        return vec4(0.0, 0.0, 0.0, 0.0);
                    }
                    
                    // Inverse bilinear interpolation: find (s,t) such that
                    // P = (1-t)*[(1-s)*bl + s*br] + t*[(1-s)*tl + s*tr]
                    // This maps the trapezoid back to the unit square for texture sampling
                    
                    vec2 e = br - bl;
                    vec2 f = tl - bl;
                    vec2 g = bl - br + tr - tl;
                    vec2 h = uv - bl;
                    
                    // Solve quadratic for t: (g√óf)t¬≤ + (e√óf + h√óg)t + h√óe = 0
                    // where √ó denotes 2D cross product (a√ób = a.x*b.y - a.y*b.x)
                    float gxf = g.x * f.y - g.y * f.x;
                    float exf = e.x * f.y - e.y * f.x;
                    float hxg = h.x * g.y - h.y * g.x;
                    float hxe = h.x * e.y - h.y * e.x;
                    
                    float t;
                    if (abs(gxf) < 0.0001) {
                        // Linear case
                        t = -hxe / (exf + hxg);
                    } else {
                        // Quadratic case
                        float a = gxf;
                        float b = exf + hxg;
                        float c = hxe;
                        float disc = b * b - 4.0 * a * c;
                        if (disc < 0.0) {
                            return vec4(0.0, 0.0, 0.0, 0.0);
                        }
                        float sqrtDisc = sqrt(disc);
                        float t1 = (-b - sqrtDisc) / (2.0 * a);
                        float t2 = (-b + sqrtDisc) / (2.0 * a);
                        t = (t1 >= 0.0 && t1 <= 1.0) ? t1 : t2;
                    }
                    
                    // Compute s from t
                    vec2 bottomPoint = mix(bl, br, 0.0);
                    vec2 topPoint = mix(tl, tr, 0.0);
                    vec2 leftEdge = mix(bl, tl, t);
                    vec2 rightEdge = mix(br, tr, t);
                    vec2 edgeVec = rightEdge - leftEdge;
                    vec2 toPoint = uv - leftEdge;
                    
                    float s;
                    if (abs(edgeVec.x) > abs(edgeVec.y)) {
                        s = toPoint.x / edgeVec.x;
                    } else {
                        s = toPoint.y / edgeVec.y;
                    }
                    
                    // Clamp to valid range
                    s = clamp(s, 0.0, 1.0);
                    t = clamp(t, 0.0, 1.0);
                    
                    return vec4(s, t, 1.0, 0.0);
                }
                
                // Corner Pin Correction using Homography (Perspective Transform)
                // More precise than keystone - allows independent corner manipulation
                vec4 applyCornerPin(vec2 uv, 
                    float cpTLX, float cpTLY, float cpTRX, float cpTRY,
                    float cpBLX, float cpBLY, float cpBRX, float cpBRY) {
                    
                    // Same algorithm as Keystone, but with individual corner control
                    // Scale from percentage (-100 to +100) to normalized coordinates
                    float scale = 0.01;  // 1% per unit
                    
                    // Define quad corners (same logic as Keystone)
                    vec2 tl = vec2(0.0 + cpTLX * scale, 0.0 + cpTLY * scale);
                    vec2 tr = vec2(1.0 + cpTRX * scale, 0.0 + cpTRY * scale);
                    vec2 bl = vec2(0.0 + cpBLX * scale, 1.0 + cpBLY * scale);
                    vec2 br = vec2(1.0 + cpBRX * scale, 1.0 + cpBRY * scale);
                    
                    // Check if UV point is inside the quad (same as Keystone)
                    vec2 v0 = br - bl;
                    vec2 v1 = tr - br;
                    vec2 v2 = tl - tr;
                    vec2 v3 = bl - tl;
                    
                    vec2 p0 = uv - bl;
                    vec2 p1 = uv - br;
                    vec2 p2 = uv - tr;
                    vec2 p3 = uv - tl;
                    
                    float c0 = v0.x * p0.y - v0.y * p0.x;
                    float c1 = v1.x * p1.y - v1.y * p1.x;
                    float c2 = v2.x * p2.y - v2.y * p2.x;
                    float c3 = v3.x * p3.y - v3.y * p3.x;
                    
                    bool inside = (c0 >= 0.0 && c1 >= 0.0 && c2 >= 0.0 && c3 >= 0.0) ||
                                  (c0 <= 0.0 && c1 <= 0.0 && c2 <= 0.0 && c3 <= 0.0);
                    
                    if (!inside) {
                        return vec4(0.0, 0.0, 0.0, 0.0);
                    }
                    
                    // Inverse bilinear interpolation (same as Keystone)
                    vec2 e = br - bl;
                    vec2 f = tl - bl;
                    vec2 g = bl - br + tr - tl;
                    vec2 h = uv - bl;
                    
                    float gxf = g.x * f.y - g.y * f.x;
                    float exf = e.x * f.y - e.y * f.x;
                    float hxg = h.x * g.y - h.y * g.x;
                    float hxe = h.x * e.y - h.y * e.x;
                    
                    float t;
                    if (abs(gxf) < 0.0001) {
                        t = -hxe / (exf + hxg);
                    } else {
                        float a = gxf;
                        float b = exf + hxg;
                        float c = hxe;
                        float disc = b * b - 4.0 * a * c;
                        if (disc < 0.0) {
                            return vec4(0.0, 0.0, 0.0, 0.0);
                        }
                        float sqrtDisc = sqrt(disc);
                        float t1 = (-b - sqrtDisc) / (2.0 * a);
                        float t2 = (-b + sqrtDisc) / (2.0 * a);
                        t = (t1 >= 0.0 && t1 <= 1.0) ? t1 : t2;
                    }
                    
                    vec2 leftEdge = mix(bl, tl, t);
                    vec2 rightEdge = mix(br, tr, t);
                    vec2 edgeVec = rightEdge - leftEdge;
                    vec2 toPoint = uv - leftEdge;
                    
                    float s;
                    if (abs(edgeVec.x) > abs(edgeVec.y)) {
                        s = toPoint.x / edgeVec.x;
                    } else {
                        s = toPoint.y / edgeVec.y;
                    }
                    
                    s = clamp(s, 0.0, 1.0);
                    t = clamp(t, 0.0, 1.0);
                    
                    return vec4(s, t, 1.0, 0.0);
                }
                
                // Apply soft edge blending
                float applySoftEdge(vec2 uv, float edgeL, float edgeR, float edgeT, float edgeB, float gamma) {
                    float blend = 1.0;
                    
                    // Left edge
                    if (edgeL > 0.0) {
                        float edgeWidth = edgeL / 100.0;
                        if (uv.x < edgeWidth) {
                            blend *= pow(uv.x / edgeWidth, 1.0 / gamma);
                        }
                    }
                    
                    // Right edge
                    if (edgeR > 0.0) {
                        float edgeWidth = edgeR / 100.0;
                        if (uv.x > 1.0 - edgeWidth) {
                            blend *= pow((1.0 - uv.x) / edgeWidth, 1.0 / gamma);
                        }
                    }
                    
                    // Top edge (UI says "Haut" = top of screen = uv.y near 1.0)
                    if (edgeT > 0.0) {
                        float edgeWidth = edgeT / 100.0;
                        if (uv.y < edgeWidth) {
                            blend *= pow(uv.y / edgeWidth, 1.0 / gamma);
                        }
                    }
                    
                    // Bottom edge (UI says "Bas" = bottom of screen = uv.y near 0.0)
                    if (edgeB > 0.0) {
                        float edgeWidth = edgeB / 100.0;
                        if (uv.y > 1.0 - edgeWidth) {
                            blend *= pow((1.0 - uv.y) / edgeWidth, 1.0 / gamma);
                        }
                    }
                    
                    return clamp(blend, 0.0, 1.0);
                }

                void main() {
                    vec3 normal = normalize(vNormal);
                    float NdotL = abs(dot(normal, normalize(dirLightDir)));
                    
                    // Use uniforms for lighting (controlled by Three.js lights)
                    float ambientComponent = ambientLightIntensity;
                    float directionalComponent = directionalLightIntensity * NdotL;
                    float lighting = ambientComponent + directionalComponent;
                    
                    // Start with baseColor - will be replaced where projection hits
                    vec3 color = baseColor * lighting;
                    
                    // Projector 0
                    if (projectorActive0) {
                        vec3 pCoord = vProjCoords0.xyz / vProjCoords0.w;
                        vec2 uv = pCoord.xy * 0.5 + 0.5;
                        
                        // Check basic depth first
                        if (pCoord.z >= 0.0 && pCoord.z <= 1.0) {
                            // Apply keystone with bounds check and inverse mapping
                            vec4 keystoneResult = applyKeystoneWithBounds(uv, keystoneV0, keystoneH0, 
                                keystoneTLX0, keystoneTLY0, keystoneTRX0, keystoneTRY0, 
                                keystoneBLX0, keystoneBLY0, keystoneBRX0, keystoneBRY0);
                            
                            // Check if inside trapezoid (z component)
                            if (keystoneResult.z > 0.5) {
                                vec2 textureUV = keystoneResult.xy;
                                
                                // Apply Corner Pin correction AFTER keystone
                                vec4 cornerPinResult = applyCornerPin(textureUV, 
                                    cornerPinTLX0, cornerPinTLY0, cornerPinTRX0, cornerPinTRY0,
                                    cornerPinBLX0, cornerPinBLY0, cornerPinBRX0, cornerPinBRY0);
                                
                                // Use corner pin result if valid, otherwise use keystone result
                                if (cornerPinResult.z > 0.5) {
                                    textureUV = cornerPinResult.xy;
                                }
                                
                                vec3 lightDir = normalize(projPosition0 - vWorldPos);
                                float facing = max(dot(normal, lightDir), 0.25);
                                float dist = length(projPosition0 - vWorldPos);
                                float distAtten = 1.0 - smoothstep(projectionFar0 * 0.7, projectionFar0, dist);
                                
                                // Soft edge blending using texture UV
                                float softEdgeBlend = applySoftEdge(textureUV, softEdgeL0, softEdgeR0, softEdgeT0, softEdgeB0, softEdgeGamma0);
                                
                                // Simple shadow check
                                vec3 sCoord = vShadowCoord0.xyz / vShadowCoord0.w;
                                sCoord = sCoord * 0.5 + 0.5;
                                float shadow = 1.0;
                                if (sCoord.x >= 0.0 && sCoord.x <= 1.0 && sCoord.y >= 0.0 && sCoord.y <= 1.0) {
                                    vec4 viewPos = shadowViewMatrix0 * vec4(vWorldPos, 1.0);
                                    float currentDepth = (-viewPos.z - 0.1) / (depthMapFar0 - 0.1);
                                    float storedDepth = texture2D(shadowMap0, sCoord.xy).r;
                                    if (storedDepth > 0.001 && storedDepth < 0.999) {
                                        shadow = step(currentDepth, storedDepth + shadowBias0);
                                    }
                                }
                                
                                float projMix = intensity0 * facing * distAtten * shadow * softEdgeBlend;
                                
                                if (hasTexture0) {
                                    vec4 texC = texture2D(projTexture0, textureUV);
                                    color += texC.rgb * projMix;
                                    
                                }
                                // No else - pure black when no texture
                            }
                        }
                    }
                    
                    // Projector 1
                    if (projectorActive1) {
                        vec3 pCoord = vProjCoords1.xyz / vProjCoords1.w;
                        vec2 uv = pCoord.xy * 0.5 + 0.5;
                        
                        if (pCoord.z >= 0.0 && pCoord.z <= 1.0) {
                            vec4 keystoneResult = applyKeystoneWithBounds(uv, keystoneV1, keystoneH1, 
                                keystoneTLX1, keystoneTLY1, keystoneTRX1, keystoneTRY1, 
                                keystoneBLX1, keystoneBLY1, keystoneBRX1, keystoneBRY1);
                            
                            if (keystoneResult.z > 0.5) {
                                vec2 textureUV = keystoneResult.xy;
                                
                                // Apply Corner Pin correction
                                vec4 cornerPinResult = applyCornerPin(textureUV,
                                    cornerPinTLX1, cornerPinTLY1, cornerPinTRX1, cornerPinTRY1,
                                    cornerPinBLX1, cornerPinBLY1, cornerPinBRX1, cornerPinBRY1);
                                
                                if (cornerPinResult.z > 0.5) {
                                    textureUV = cornerPinResult.xy;
                                }
                                
                                vec3 lightDir = normalize(projPosition1 - vWorldPos);
                                float facing = max(dot(normal, lightDir), 0.25);
                                float dist = length(projPosition1 - vWorldPos);
                                float distAtten = 1.0 - smoothstep(projectionFar1 * 0.7, projectionFar1, dist);
                                
                                float softEdgeBlend = applySoftEdge(textureUV, softEdgeL1, softEdgeR1, softEdgeT1, softEdgeB1, softEdgeGamma1);
                                
                                vec3 sCoord = vShadowCoord1.xyz / vShadowCoord1.w;
                                sCoord = sCoord * 0.5 + 0.5;
                                float shadow = 1.0;
                                if (sCoord.x >= 0.0 && sCoord.x <= 1.0 && sCoord.y >= 0.0 && sCoord.y <= 1.0) {
                                    vec4 viewPos = shadowViewMatrix1 * vec4(vWorldPos, 1.0);
                                    float currentDepth = (-viewPos.z - 0.1) / (depthMapFar1 - 0.1);
                                    float storedDepth = texture2D(shadowMap1, sCoord.xy).r;
                                    if (storedDepth > 0.001 && storedDepth < 0.999) {
                                        shadow = step(currentDepth, storedDepth + shadowBias1);
                                    }
                                }
                                
                                float projMix = intensity1 * facing * distAtten * shadow * softEdgeBlend;
                                
                                if (hasTexture1) {
                                    vec4 texC = texture2D(projTexture1, textureUV);
                                    color += texC.rgb * projMix;
                                    
                                }
                                // No else - pure black when no texture
                            }
                        }
                    }
                    
                    // Projector 2
                    if (projectorActive2) {
                        vec3 pCoord = vProjCoords2.xyz / vProjCoords2.w;
                        vec2 uv = pCoord.xy * 0.5 + 0.5;
                        
                        if (pCoord.z >= 0.0 && pCoord.z <= 1.0) {
                            vec4 keystoneResult = applyKeystoneWithBounds(uv, keystoneV2, keystoneH2, 
                                keystoneTLX2, keystoneTLY2, keystoneTRX2, keystoneTRY2, 
                                keystoneBLX2, keystoneBLY2, keystoneBRX2, keystoneBRY2);
                            
                            if (keystoneResult.z > 0.5) {
                                vec2 textureUV = keystoneResult.xy;
                                
                                // Apply Corner Pin correction
                                vec4 cornerPinResult = applyCornerPin(textureUV,
                                    cornerPinTLX2, cornerPinTLY2, cornerPinTRX2, cornerPinTRY2,
                                    cornerPinBLX2, cornerPinBLY2, cornerPinBRX2, cornerPinBRY2);
                                
                                if (cornerPinResult.z > 0.5) {
                                    textureUV = cornerPinResult.xy;
                                }
                                
                                vec3 lightDir = normalize(projPosition2 - vWorldPos);
                                float facing = max(dot(normal, lightDir), 0.25);
                                float dist = length(projPosition2 - vWorldPos);
                                float distAtten = 1.0 - smoothstep(projectionFar2 * 0.7, projectionFar2, dist);
                                
                                float softEdgeBlend = applySoftEdge(textureUV, softEdgeL2, softEdgeR2, softEdgeT2, softEdgeB2, softEdgeGamma2);
                                
                                vec3 sCoord = vShadowCoord2.xyz / vShadowCoord2.w;
                                sCoord = sCoord * 0.5 + 0.5;
                                float shadow = 1.0;
                                if (sCoord.x >= 0.0 && sCoord.x <= 1.0 && sCoord.y >= 0.0 && sCoord.y <= 1.0) {
                                    vec4 viewPos = shadowViewMatrix2 * vec4(vWorldPos, 1.0);
                                    float currentDepth = (-viewPos.z - 0.1) / (depthMapFar2 - 0.1);
                                    float storedDepth = texture2D(shadowMap2, sCoord.xy).r;
                                    if (storedDepth > 0.001 && storedDepth < 0.999) {
                                        shadow = step(currentDepth, storedDepth + shadowBias2);
                                    }
                                }
                                
                                float projMix = intensity2 * facing * distAtten * shadow * softEdgeBlend;
                                
                                if (hasTexture2) {
                                    vec4 texC = texture2D(projTexture2, textureUV);
                                    color += texC.rgb * projMix;
                                    
                                }
                                // No else - pure black when no texture
                            }
                        }
                    }
                    // Projector 3
                    if (projectorActive3) {
                        vec3 pCoord = vProjCoords3.xyz / vProjCoords3.w;
                        vec2 uv = pCoord.xy * 0.5 + 0.5;
                        
                        if (pCoord.z >= 0.0 && pCoord.z <= 1.0) {
                            vec4 keystoneResult = applyKeystoneWithBounds(uv, keystoneV3, keystoneH3, 
                                keystoneTLX3, keystoneTLY3, keystoneTRX3, keystoneTRY3, 
                                keystoneBLX3, keystoneBLY3, keystoneBRX3, keystoneBRY3);
                            
                            if (keystoneResult.z > 0.5) {
                                vec2 textureUV = keystoneResult.xy;
                                
                                // Apply Corner Pin correction
                                vec4 cornerPinResult = applyCornerPin(textureUV,
                                    cornerPinTLX3, cornerPinTLY3, cornerPinTRX3, cornerPinTRY3,
                                    cornerPinBLX3, cornerPinBLY3, cornerPinBRX3, cornerPinBRY3);
                                
                                if (cornerPinResult.z > 0.5) {
                                    textureUV = cornerPinResult.xy;
                                }
                                
                                vec3 lightDir = normalize(projPosition3 - vWorldPos);
                                float facing = max(dot(normal, lightDir), 0.25);
                                float dist = length(projPosition3 - vWorldPos);
                                float distAtten = 1.0 - smoothstep(projectionFar3 * 0.7, projectionFar3, dist);
                                
                                float softEdgeBlend = applySoftEdge(textureUV, softEdgeL3, softEdgeR3, softEdgeT3, softEdgeB3, softEdgeGamma3);
                                
                                vec3 sCoord = vShadowCoord3.xyz / vShadowCoord3.w;
                                sCoord = sCoord * 0.5 + 0.5;
                                float shadow = 1.0;
                                if (sCoord.x >= 0.0 && sCoord.x <= 1.0 && sCoord.y >= 0.0 && sCoord.y <= 1.0) {
                                    vec4 viewPos = shadowViewMatrix3 * vec4(vWorldPos, 1.0);
                                    float currentDepth = (-viewPos.z - 0.1) / (depthMapFar3 - 0.1);
                                    float storedDepth = texture2D(shadowMap3, sCoord.xy).r;
                                    if (storedDepth > 0.001 && storedDepth < 0.999) {
                                        shadow = step(currentDepth, storedDepth + shadowBias3);
                                    }
                                }
                                
                                float projMix = intensity3 * facing * distAtten * shadow * softEdgeBlend;
                                
                                if (hasTexture3) {
                                    vec4 texC = texture2D(projTexture3, textureUV);
                                    color += texC.rgb * projMix;
                                    
                                }
                                // No else - pure black when no texture
                            }
                        }
                    }
                    
                    // color already has baseColor, projection adds on top
                    
                    gl_FragColor = vec4(color, 1.0);
                }
            `,
            side: THREE.DoubleSide
        });
    }

    // ===== GIZMO MODE CONTROLS =====

    window.setGizmoMode = function(mode) {
        if (!transformControls) return;
        transformControls.setMode(mode);

        // Apply rotation snapping if Shift is held when switching to rotate mode
        if (mode === 'rotate' && isShiftPressed) {
            transformControls.setRotationSnap(THREE.MathUtils.degToRad(15));
        } else if (mode !== 'rotate') {
            transformControls.setRotationSnap(null);
        }

        // Update old gizmo buttons
        document.querySelectorAll('.gizmo-mode-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        const btn = document.querySelector(`[data-mode="${mode}"]`);
        if (btn) btn.classList.add('active');
        
        // Update modern UI gizmo buttons (sidebar right)
        const activeStyle = 'padding: 12px; background: rgba(13,148,136,0.1); border: 1px solid #0d9488; border-radius: 6px; color: #0d9488; cursor: pointer; font-size: 20px;';
        const inactiveStyle = 'padding: 12px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: #e0e0e0; cursor: pointer; font-size: 20px;';
        
        const moveBtn = document.getElementById('gizmo-move-btn');
        const rotateBtn = document.getElementById('gizmo-rotate-btn');
        const scaleBtn = document.getElementById('gizmo-scale-btn');
        
        if (moveBtn) moveBtn.style.cssText = mode === 'translate' ? activeStyle : inactiveStyle;
        if (rotateBtn) rotateBtn.style.cssText = mode === 'rotate' ? activeStyle : inactiveStyle;
        if (scaleBtn) scaleBtn.style.cssText = mode === 'scale' ? activeStyle : inactiveStyle;
        
        // Update top bar gizmo buttons
        const topActiveStyle = 'padding: 6px 10px; background: rgba(13,148,136,0.1); border: 1px solid #0d9488; border-radius: 4px; color: #0d9488; cursor: pointer; font-size: 14px;';
        const topInactiveStyle = 'padding: 6px 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #888; cursor: pointer; font-size: 14px;';
        
        const topMoveBtn = document.getElementById('gizmo-move-btn-top');
        const topRotateBtn = document.getElementById('gizmo-rotate-btn-top');
        const topScaleBtn = document.getElementById('gizmo-scale-btn-top');
        
        if (topMoveBtn) topMoveBtn.style.cssText = mode === 'translate' ? topActiveStyle : topInactiveStyle;
        if (topRotateBtn) topRotateBtn.style.cssText = mode === 'rotate' ? topActiveStyle : topInactiveStyle;
        if (topScaleBtn) topScaleBtn.style.cssText = mode === 'scale' ? topActiveStyle : topInactiveStyle;
    };

    // ===== FLOATING WINDOWS =====

    // Track which windows are open
    const floatingWindows = {
        'transform-params': false,
        'keystone-window': false,
        'cornerpin-window': false,
        'softedge-window': false,
        'photometric-window': false
    };

    window.toggleFloatingWindow = function(windowId) {
        console.log('üîß Toggle window:', windowId);
        const win = document.getElementById(windowId);
        if (!win) {
            console.error('‚ùå Window not found:', windowId);
            return;
        }
        console.log('‚úÖ Window found:', win);

        floatingWindows[windowId] = !floatingWindows[windowId];
        console.log('üîÑ New state:', floatingWindows[windowId]);
        
        if (floatingWindows[windowId]) {
            win.classList.add('visible');
            console.log('üëÅÔ∏è Window should be visible now');
            // Update toggle button state
            const btnMap = {
                'transform-params': 'btn-transform',
                'keystone-window': 'btn-keystone',
                'cornerpin-window': 'btn-cornerpin',
                'softedge-window': 'btn-softedge',
                'photometric-window': 'btn-photometric'
            };
            const btn = document.getElementById(btnMap[windowId]);
            if (btn) btn.classList.add('active');
        } else {
            win.classList.remove('visible');
            const btnMap = {
                'transform-params': 'btn-transform',
                'keystone-window': 'btn-keystone',
                'cornerpin-window': 'btn-cornerpin',
                'softedge-window': 'btn-softedge',
                'photometric-window': 'btn-photometric'
            };
            const btn = document.getElementById(btnMap[windowId]);
            if (btn) btn.classList.remove('active');
        }
    };

    // Make floating windows draggable
    function initFloatingWindowDrag() {
        document.querySelectorAll('.floating-window').forEach(win => {
            const header = win.querySelector('.floating-window-header');
            if (!header) return;

            let isDragging = false;
            let offsetX = 0, offsetY = 0;

            header.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('floating-window-close')) return;
                isDragging = true;
                offsetX = e.clientX - win.offsetLeft;
                offsetY = e.clientY - win.offsetTop;
                win.style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                win.style.left = (e.clientX - offsetX) + 'px';
                win.style.top = (e.clientY - offsetY) + 'px';
                win.style.right = 'auto';
                win.style.bottom = 'auto';
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
                win.style.cursor = 'move';
            });
        });
    }

    // ===== 15¬∞ ROTATION SNAPPING =====

    let isShiftPressed = false;

    function initRotationSnapping() {
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Shift' && !isShiftPressed) {
                isShiftPressed = true;
                if (transformControls && transformControls.getMode() === 'rotate') {
                    transformControls.setRotationSnap(THREE.MathUtils.degToRad(15));
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            if (e.key === 'Shift') {
                isShiftPressed = false;
                if (transformControls) {
                    transformControls.setRotationSnap(null);
                }
            }
        });
    }

    // ===== TRANSFORM CONTROLS =====

    function updateTransformInputs() {
        if (!selectedObject) return;

        const obj = selectedObject.userData.isProjector ? projectorGroup : selectedObject;

        const posX = document.getElementById('pos-x');
        const posY = document.getElementById('pos-y');
        const posZ = document.getElementById('pos-z');
        if (posX) posX.value = obj.position.x.toFixed(2);
        if (posY) posY.value = obj.position.y.toFixed(2);
        if (posZ) posZ.value = obj.position.z.toFixed(2);

        const rotX = document.getElementById('rot-x');
        const rotY = document.getElementById('rot-y');
        const rotZ = document.getElementById('rot-z');
        if (rotX) rotX.value = THREE.MathUtils.radToDeg(obj.rotation.x).toFixed(1);
        if (rotY) rotY.value = THREE.MathUtils.radToDeg(obj.rotation.y).toFixed(1);
        if (rotZ) rotZ.value = THREE.MathUtils.radToDeg(obj.rotation.z).toFixed(1);

        const sx = document.getElementById('scale-x');
        const sy = document.getElementById('scale-y');
        const sz = document.getElementById('scale-z');
        if (sx) sx.value = obj.scale.x.toFixed(2);
        if (sy) sy.value = obj.scale.y.toFixed(2);
        if (sz) sz.value = obj.scale.z.toFixed(2);
    }

    window.updateTransformFromInputs = function() {
        if (!selectedObject) return;

        const obj = selectedObject.userData.isProjector ? projectorGroup : selectedObject;

        const px = parseFloat((document.getElementById('pos-x') || {value:0}).value);
        const py = parseFloat((document.getElementById('pos-y') || {value:0}).value);
        const pz = parseFloat((document.getElementById('pos-z') || {value:0}).value);
        obj.position.x = px; obj.position.y = py; obj.position.z = pz;

        const rx = parseFloat((document.getElementById('rot-x') || {value:0}).value);
        const ry = parseFloat((document.getElementById('rot-y') || {value:0}).value);
        const rz = parseFloat((document.getElementById('rot-z') || {value:0}).value);
        obj.rotation.x = THREE.MathUtils.degToRad(rx);
        obj.rotation.y = THREE.MathUtils.degToRad(ry);
        obj.rotation.z = THREE.MathUtils.degToRad(rz);

        const sx = parseFloat((document.getElementById('scale-x') || {value:1}).value);
        const sy = parseFloat((document.getElementById('scale-y') || {value:1}).value);
        const sz = parseFloat((document.getElementById('scale-z') || {value:1}).value);
        obj.scale.x = sx; obj.scale.y = sy; obj.scale.z = sz;

        updateProjectionMatrix();
        updateMeasurements();
    };

    window.resetTransform = function() {
        if (!selectedObject || selectedObject.userData.isProjector || selectedObject.userData.isTarget) return;

        selectedObject.position.set(0, 0, 0);
        selectedObject.rotation.set(0, 0, 0);
        selectedObject.scale.set(1, 1, 1);

        updateTransformInputs();
        updateProjectionMatrix();
    };

    // ===== KEYSTONE CONTROLS =====
    
    window.updateKeystone = function() {
        keystoneV = parseFloat(document.getElementById('keystone-v').value);
        keystoneH = parseFloat(document.getElementById('keystone-h').value);
        
        document.getElementById('keystone-v-val').textContent = keystoneV;
        document.getElementById('keystone-h-val').textContent = keystoneH;
        
        // Sync to active projector
        if (activeProjector) {
            activeProjector.keystoneV = keystoneV;
            activeProjector.keystoneH = keystoneH;
        }
        
        updateProjectionMatrix();
    };
    
    
    // Sync corner controls between sidebar panel and floating window
    window.syncCornerControl = function(corner, value) {
        value = parseFloat(value);
        
        // Update original control
        const originalId = 'keystone-' + corner;
        const originalInput = document.getElementById(originalId);
        const originalVal = document.getElementById(originalId + '-val');
        
        if (originalInput) {
            originalInput.value = value;
        }
        if (originalVal) {
            originalVal.textContent = value;
        }
        
        // Update sidebar copy
        const sidebarId = originalId + '-2';
        const sidebarVal = document.getElementById(sidebarId + '-val');
        
        if (sidebarVal) {
            sidebarVal.textContent = value;
        }
        
        // Call the main update function
        updateKeystoneCorners();
    };
    
    window.updateKeystoneCorners = function() {
        // Read all 8 sliders (now 0-200 range, where 0 = edges)
        const tlx_slider = parseFloat(document.getElementById('keystone-tl-x').value);
        const tly_slider = parseFloat(document.getElementById('keystone-tl-y').value);
        const trx_slider = parseFloat(document.getElementById('keystone-tr-x').value);
        const try_slider = parseFloat(document.getElementById('keystone-tr-y').value);
        const blx_slider = parseFloat(document.getElementById('keystone-bl-x').value);
        const bly_slider = parseFloat(document.getElementById('keystone-bl-y').value);
        const brx_slider = parseFloat(document.getElementById('keystone-br-x').value);
        const bry_slider = parseFloat(document.getElementById('keystone-br-y').value);
        
        // Convert slider values (0=edges) to internal values
        // TL: slider 0 ‚Üí X=-6, Y=+6 (top-left edge)
        keystoneTLX = tlx_slider - 6;   // 0‚Üí-6, 200‚Üí194
        keystoneTLY = 6 - tly_slider;   // 0‚Üí+6, 200‚Üí-194
        // TR: slider 0 ‚Üí X=+6, Y=+6 (top-right edge)
        keystoneTRX = 6 - trx_slider;   // 0‚Üí+6, 200‚Üí-194
        keystoneTRY = 6 - try_slider;   // 0‚Üí+6, 200‚Üí-194
        // BL: slider 0 ‚Üí X=-6, Y=-6 (bottom-left edge)
        keystoneBLX = blx_slider - 6;   // 0‚Üí-6, 200‚Üí194
        keystoneBLY = bly_slider - 6;   // 0‚Üí-6, 200‚Üí194
        // BR: slider 0 ‚Üí X=+6, Y=-6 (bottom-right edge)
        keystoneBRX = 6 - brx_slider;   // 0‚Üí+6, 200‚Üí-194
        keystoneBRY = bry_slider - 6;   // 0‚Üí-6, 200‚Üí194
        
        // Update value displays (just show slider value = user-friendly)
        document.getElementById('keystone-tl-x-val').textContent = tlx_slider;
        document.getElementById('keystone-tl-y-val').textContent = tly_slider;
        document.getElementById('keystone-tr-x-val').textContent = trx_slider;
        document.getElementById('keystone-tr-y-val').textContent = try_slider;
        document.getElementById('keystone-bl-x-val').textContent = blx_slider;
        document.getElementById('keystone-bl-y-val').textContent = bly_slider;
        document.getElementById('keystone-br-x-val').textContent = brx_slider;
        document.getElementById('keystone-br-y-val').textContent = bry_slider;
        
        // Sync to active projector
        if (activeProjector) {
            activeProjector.keystoneTLX = keystoneTLX;
            activeProjector.keystoneTLY = keystoneTLY;
            activeProjector.keystoneTRX = keystoneTRX;
            activeProjector.keystoneTRY = keystoneTRY;
            activeProjector.keystoneBLX = keystoneBLX;
            activeProjector.keystoneBLY = keystoneBLY;
            activeProjector.keystoneBRX = keystoneBRX;
            activeProjector.keystoneBRY = keystoneBRY;
        }
        
        updateProjectionMatrix();
    };
    
    window.resetKeystone = function() {
        // Reset global keystone
        keystoneV = 0; keystoneH = 0;
        document.getElementById('keystone-v').value = 0;
        document.getElementById('keystone-h').value = 0;
        
        // Reset corners to EDGES (full frame) - internal values
        keystoneTLX = -6; keystoneTLY = 6;
        keystoneTRX = 6; keystoneTRY = 6;
        keystoneBLX = -6; keystoneBLY = -6;
        keystoneBRX = 6; keystoneBRY = -6;
        
        // Reset sliders to 0 (which maps to edges)
        document.getElementById('keystone-tl-x').value = 0;
        document.getElementById('keystone-tl-y').value = 0;
        document.getElementById('keystone-tr-x').value = 0;
        document.getElementById('keystone-tr-y').value = 0;
        document.getElementById('keystone-bl-x').value = 0;
        document.getElementById('keystone-bl-y').value = 0;
        document.getElementById('keystone-br-x').value = 0;
        document.getElementById('keystone-br-y').value = 0;
        
        updateKeystone();
        updateKeystoneCorners();
    };
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // BRIGHTNESS SETTINGS (Mapping Matters style)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // Variables already declared above, just update defaults
    ambientLightLux = 50;
    let projectionBrightnessLux = 0;
    let autoViewportRange = true;
    let manualMaxLux = 250;
    let directionalYaw = 0;
    let directionalPitch = 45;
    
    // Note: lights will be available as window.ambientLightObj and window.directionalLightObj after init()
    
    window.toggleBrightnessPanel = function() {
        const panel = document.getElementById('brightness-panel');
        if (panel.style.display === 'none') {
            panel.style.display = 'block';
        } else {
            panel.style.display = 'none';
        }
    };
    
    window.updateAutoViewportRange = function() {
        autoViewportRange = document.getElementById('auto-viewport-range').checked;
        const manualControls = document.getElementById('manual-range-controls');
        
        if (autoViewportRange) {
            manualControls.style.display = 'none';
            // Calculate max from active projector
            if (activeProjector && activeProjector.illuminance) {
                const maxLux = activeProjector.illuminance;
                renderer.toneMappingExposure = 1.0; // Auto adjust
                console.log('‚úÖ Auto viewport range ON - Based on projector:', maxLux, 'lux');
            } else {
                renderer.toneMappingExposure = 1.0;
                console.log('‚úÖ Auto viewport range ON - No projector, using default');
            }
        } else {
            manualControls.style.display = 'block';
            console.log('‚úÖ Manual viewport range enabled');
            updateManualMaxLux(manualMaxLux);
        }
    };
    
    window.updateManualMaxLux = function(value) {
        manualMaxLux = parseFloat(value);
        document.getElementById('manual-max-lux-num').value = manualMaxLux;
        document.getElementById('manual-max-lux').value = manualMaxLux;
        
        // Adjust tone mapping based on manual max
        const exposure = 250 / manualMaxLux; // Normalize to 250 lux baseline
        renderer.toneMappingExposure = exposure;
        
        // BONUS: Also scale all scene lights to make effect MORE visible
        const lightScale = 250 / manualMaxLux; // Same as exposure
        if (window.ambientLightObj) {
            // Re-apply current ambient with new scale
            const currentLux = ambientLightLux;
            const newIntensity = (currentLux / 100) * lightScale;
            window.ambientLightObj.intensity = newIntensity;
            
            // UPDATE SHADER UNIFORMS
            projectedObjects.forEach(obj => {
                if (obj.material?.uniforms?.ambientLightIntensity) {
                    obj.material.uniforms.ambientLightIntensity.value = newIntensity;
                }
            });
        }
        if (window.directionalLightObj) {
            // Re-apply current directional with new scale
            const currentLux = directionalLightLux;
            const newIntensity = (currentLux / 100) * lightScale;
            window.directionalLightObj.intensity = newIntensity;
            
            // UPDATE SHADER UNIFORMS
            projectedObjects.forEach(obj => {
                if (obj.material?.uniforms?.directionalLightIntensity) {
                    obj.material.uniforms.directionalLightIntensity.value = newIntensity;
                }
            });
        }
        
        console.log('üîÜ Manual max brightness:', manualMaxLux, 'lux, scale:', lightScale.toFixed(2));
        console.log('   ‚Üí All lights scaled by', lightScale.toFixed(2) + 'x');
        console.log('   ‚Üí Updated', projectedObjects.length, 'shader uniforms');
    };
    
    window.updateProjectionBrightness = function(value) {
        projectionBrightnessLux = parseFloat(value);
        document.getElementById('projection-brightness-num').value = projectionBrightnessLux;
        document.getElementById('projection-brightness').value = projectionBrightnessLux;
        
        // Boost overall scene brightness DRAMATICALLY
        const baseExposure = autoViewportRange ? 1.0 : (250 / manualMaxLux);
        const projectionBoost = 1.0 + (projectionBrightnessLux / 1000); // 0-10000 lux ‚Üí 1.0-11.0x boost (was /10000)
        renderer.toneMappingExposure = baseExposure * projectionBoost;
        
        // BONUS: Also boost ambient light dramatically for visible effect
        const extraBoost = projectionBrightnessLux / 500; // Extra ambient from projection
        if (window.ambientLightObj && ambientLightLux > 0) {
            const newIntensity = (ambientLightLux / 100) + extraBoost;
            window.ambientLightObj.intensity = newIntensity;
            
            // UPDATE SHADER UNIFORMS
            projectedObjects.forEach(obj => {
                if (obj.material?.uniforms?.ambientLightIntensity) {
                    obj.material.uniforms.ambientLightIntensity.value = newIntensity;
                }
            });
        }
        
        console.log('üé¨ Projection texture brightness:', projectionBrightnessLux, 'lux');
        console.log('   ‚Üí Exposure boost:', projectionBoost.toFixed(2) + 'x');
        console.log('   ‚Üí Ambient boost:', extraBoost.toFixed(2));
        console.log('   ‚Üí Updated', projectedObjects.length, 'shader uniforms');
    };
    
    window.updateAmbientLight = function(value) {
        ambientLightLux = parseFloat(value);
        document.getElementById('ambient-light-num').value = ambientLightLux;
        document.getElementById('ambient-light').value = ambientLightLux;
        
        console.log('üîÜ updateAmbientLight called with:', ambientLightLux, 'lux');
        console.log('   window.ambientLightObj:', window.ambientLightObj);
        
        // Safety check
        if (!window.ambientLightObj) {
            console.warn('‚ö†Ô∏è Ambient light not initialized yet');
            return;
        }
        
        // Convert lux to Three.js intensity
        // Increased multiplier for more visible effect
        const intensity = ambientLightLux / 100; // Was /1000, now /100 = 10x stronger
        window.ambientLightObj.intensity = intensity;
        
        // UPDATE SHADER UNIFORMS for projected materials
        projectedObjects.forEach(obj => {
            if (obj.material?.uniforms?.ambientLightIntensity) {
                obj.material.uniforms.ambientLightIntensity.value = intensity;
            }
        });
        
        console.log('‚úÖ Ambient light updated:', ambientLightLux, 'lux, intensity:', intensity.toFixed(3));
        console.log('   ‚Üí Updated', projectedObjects.length, 'projected objects');
    };
    
    window.updateDirectionalLight = function(luxValue) {
        if (luxValue !== undefined) {
            directionalLightLux = parseFloat(luxValue);
            document.getElementById('directional-light-num').value = directionalLightLux;
            document.getElementById('directional-light').value = directionalLightLux;
        }
        
        directionalYaw = parseFloat(document.getElementById('directional-yaw').value);
        directionalPitch = parseFloat(document.getElementById('directional-pitch').value);
        
        document.getElementById('directional-yaw-num').value = directionalYaw;
        document.getElementById('directional-pitch-num').value = directionalPitch;
        
        // Safety check
        if (!window.directionalLightObj) {
            console.warn('Directional light not initialized yet');
            return;
        }
        
        // Convert lux to intensity
        // Increased multiplier for more visible effect
        const intensity = directionalLightLux / 100; // Was /1000, now /100 = 10x stronger
        window.directionalLightObj.intensity = intensity;
        
        // Calculate direction from yaw/pitch
        const yawRad = THREE.MathUtils.degToRad(directionalYaw);
        const pitchRad = THREE.MathUtils.degToRad(directionalPitch);
        
        const x = Math.cos(pitchRad) * Math.sin(yawRad);
        const y = Math.sin(pitchRad);
        const z = Math.cos(pitchRad) * Math.cos(yawRad);
        
        window.directionalLightObj.position.set(x * 20, y * 20, z * 20);
        
        // UPDATE SHADER UNIFORMS for projected materials
        const dirVector = new THREE.Vector3(x, y, z).normalize();
        projectedObjects.forEach(obj => {
            if (obj.material?.uniforms?.directionalLightIntensity) {
                obj.material.uniforms.directionalLightIntensity.value = intensity;
                obj.material.uniforms.dirLightDir.value.copy(dirVector);
            }
        });
        
        console.log('Directional light:', directionalLightLux, 'lux, Yaw:', directionalYaw, '¬∞ Pitch:', directionalPitch, '¬∞');
        console.log('   ‚Üí Updated', projectedObjects.length, 'projected objects');
    };
    
    // Initialize brightness after scene setup (called from init)
    window.initBrightnessSystem = function() {
        if (window.ambientLightObj) {
            updateAmbientLight(50);
            console.log('‚úÖ Brightness system initialized');
        } else {
            console.warn('‚ö†Ô∏è Lights not ready yet');
        }
    };
    
    // ===== SOFT EDGE CONTROLS =====
    
    
    // Sync soft edge controls between sidebar and floating window
    window.syncSoftEdge = function(edge, value) {
        value = parseFloat(value);
        
        // Update original control
        const originalId = 'softedge-' + edge;
        const originalInput = document.getElementById(originalId);
        const originalVal = document.getElementById(originalId + '-val');
        
        if (originalInput) {
            originalInput.value = value;
        }
        if (originalVal) {
            const displayValue = edge === 'gamma' ? value.toFixed(1) : value + '%';
            originalVal.textContent = displayValue;
        }
        
        // Update sidebar copy
        const sidebarVal = document.getElementById(originalId + '-val-2');
        if (sidebarVal) {
            const displayValue = edge === 'gamma' ? value.toFixed(1) : value + '%';
            sidebarVal.textContent = displayValue;
        }
        
        // Call main update function
        updateSoftEdge();
    };
    
    window.updateSoftEdge = function() {
        softEdgeL = parseFloat(document.getElementById('softedge-l').value);
        softEdgeR = parseFloat(document.getElementById('softedge-r').value);
        softEdgeT = parseFloat(document.getElementById('softedge-t').value);
        softEdgeB = parseFloat(document.getElementById('softedge-b').value);
        softEdgeGamma = parseFloat(document.getElementById('softedge-gamma').value);
        
        document.getElementById('softedge-l-val').textContent = softEdgeL + '%';
        document.getElementById('softedge-r-val').textContent = softEdgeR + '%';
        document.getElementById('softedge-t-val').textContent = softEdgeT + '%';
        document.getElementById('softedge-b-val').textContent = softEdgeB + '%';
        document.getElementById('softedge-gamma-val').textContent = softEdgeGamma.toFixed(1);
        
        // Sync to active projector
        if (activeProjector) {
            activeProjector.softEdgeL = softEdgeL;
            activeProjector.softEdgeR = softEdgeR;
            activeProjector.softEdgeT = softEdgeT;
            activeProjector.softEdgeB = softEdgeB;
            activeProjector.softEdgeGamma = softEdgeGamma;
        }
        
        updateProjectionMatrix();
    };
    
    window.resetSoftEdge = function() {
        softEdgeL = 0; softEdgeR = 0; softEdgeT = 0; softEdgeB = 0;
        softEdgeGamma = 2.2;
        
        document.getElementById('softedge-l').value = 0;
        document.getElementById('softedge-r').value = 0;
        document.getElementById('softedge-t').value = 0;
        document.getElementById('softedge-b').value = 0;
        document.getElementById('softedge-gamma').value = 2.2;
        
        updateSoftEdge();
    };

    // ===== CORNER PIN CONTROLS =====
    
    window.updateCornerPin = function() {
        // Safety check - if no projectors exist yet, skip
        if (!activeProjector) {
            return;
        }
        
        const el_tl_x = document.getElementById('cp-tl-x');
        const el_tl_y = document.getElementById('cp-tl-y');
        const el_tr_x = document.getElementById('cp-tr-x');
        const el_tr_y = document.getElementById('cp-tr-y');
        const el_bl_x = document.getElementById('cp-bl-x');
        const el_bl_y = document.getElementById('cp-bl-y');
        const el_br_x = document.getElementById('cp-br-x');
        const el_br_y = document.getElementById('cp-br-y');
        
        // Safety check - return if elements don't exist yet
        if (!el_tl_x || !el_tl_y || !el_tr_x || !el_tr_y || 
            !el_bl_x || !el_bl_y || !el_br_x || !el_br_y) {
            return;
        }
        
        cornerPinTLX = parseFloat(el_tl_x.value) || 0;
        cornerPinTLY = parseFloat(el_tl_y.value) || 0;
        cornerPinTRX = parseFloat(el_tr_x.value) || 0;
        cornerPinTRY = parseFloat(el_tr_y.value) || 0;
        cornerPinBLX = parseFloat(el_bl_x.value) || 0;
        cornerPinBLY = parseFloat(el_bl_y.value) || 0;
        cornerPinBRX = parseFloat(el_br_x.value) || 0;
        cornerPinBRY = parseFloat(el_br_y.value) || 0;
        
        // Update UI values
        const val_tl_x = document.getElementById('cp-tl-x-val');
        const val_tl_y = document.getElementById('cp-tl-y-val');
        const val_tr_x = document.getElementById('cp-tr-x-val');
        const val_tr_y = document.getElementById('cp-tr-y-val');
        const val_bl_x = document.getElementById('cp-bl-x-val');
        const val_bl_y = document.getElementById('cp-bl-y-val');
        const val_br_x = document.getElementById('cp-br-x-val');
        const val_br_y = document.getElementById('cp-br-y-val');
        
        if (val_tl_x) val_tl_x.textContent = cornerPinTLX;
        if (val_tl_y) val_tl_y.textContent = cornerPinTLY;
        if (val_tr_x) val_tr_x.textContent = cornerPinTRX;
        if (val_tr_y) val_tr_y.textContent = cornerPinTRY;
        if (val_bl_x) val_bl_x.textContent = cornerPinBLX;
        if (val_bl_y) val_bl_y.textContent = cornerPinBLY;
        if (val_br_x) val_br_x.textContent = cornerPinBRX;
        if (val_br_y) val_br_y.textContent = cornerPinBRY;
        
        // Sync to active projector
        if (activeProjector) {
            activeProjector.cornerPinTLX = cornerPinTLX;
            activeProjector.cornerPinTLY = cornerPinTLY;
            activeProjector.cornerPinTRX = cornerPinTRX;
            activeProjector.cornerPinTRY = cornerPinTRY;
            activeProjector.cornerPinBLX = cornerPinBLX;
            activeProjector.cornerPinBLY = cornerPinBLY;
            activeProjector.cornerPinBRX = cornerPinBRX;
            activeProjector.cornerPinBRY = cornerPinBRY;
        }
        
        // Update visual editor
        updateCornerPinVisual();
        
        // Only update projection matrix if we have valid objects
        if (projectedObjects && projectedObjects.length > 0) {
            updateProjectionMatrix();
        }
    };
    
    window.resetCornerPin = function() {
        // Safety check - if no projectors exist yet, skip
        if (!activeProjector) {
            return;
        }
        
        cornerPinTLX = 0; cornerPinTLY = 0;
        cornerPinTRX = 0; cornerPinTRY = 0;
        cornerPinBLX = 0; cornerPinBLY = 0;
        cornerPinBRX = 0; cornerPinBRY = 0;
        
        const el_tl_x = document.getElementById('cp-tl-x');
        const el_tl_y = document.getElementById('cp-tl-y');
        const el_tr_x = document.getElementById('cp-tr-x');
        const el_tr_y = document.getElementById('cp-tr-y');
        const el_bl_x = document.getElementById('cp-bl-x');
        const el_bl_y = document.getElementById('cp-bl-y');
        const el_br_x = document.getElementById('cp-br-x');
        const el_br_y = document.getElementById('cp-br-y');
        
        if (el_tl_x) el_tl_x.value = 0;
        if (el_tl_y) el_tl_y.value = 0;
        if (el_tr_x) el_tr_x.value = 0;
        if (el_tr_y) el_tr_y.value = 0;
        if (el_bl_x) el_bl_x.value = 0;
        if (el_bl_y) el_bl_y.value = 0;
        if (el_br_x) el_br_x.value = 0;
        if (el_br_y) el_br_y.value = 0;
        
        updateCornerPin();
    };
    
    window.copyCornerPinValues = function() {
        const values = `Corner Pin Values:
TL: X=${cornerPinTLX}, Y=${cornerPinTLY}
TR: X=${cornerPinTRX}, Y=${cornerPinTRY}
BL: X=${cornerPinBLX}, Y=${cornerPinBLY}
BR: X=${cornerPinBRX}, Y=${cornerPinBRY}`;
        
        navigator.clipboard.writeText(values).then(() => {
            alert('Corner Pin values copied to clipboard!');
        });
    };
    
    // Initialize Corner Pin visual editor
    function initCornerPinVisual() {
        console.log('üé® Initializing Corner Pin Visual Editor...');
        const container = document.getElementById('cornerpin-visual');
        if (!container) {
            console.error('‚ùå cornerpin-visual container not found!');
            return;
        }
        console.log('‚úÖ Container found:', container);
        
        // Clear existing handles
        container.innerHTML = '';
        
        // Create corner handles - positioned slightly inside to stay visible
        const margin = 3; // 3% margin from edges
        const corners = [
            { id: 'tl', label: 'TL', x: margin, y: margin },
            { id: 'tr', label: 'TR', x: 100 - margin, y: margin },
            { id: 'bl', label: 'BL', x: margin, y: 100 - margin },
            { id: 'br', label: 'BR', x: 100 - margin, y: 100 - margin }
        ];
        
        corners.forEach(corner => {
            const handle = document.createElement('div');
            handle.className = 'cornerpin-handle';
            handle.id = `cp-handle-${corner.id}`;
            handle.tabIndex = 0; // Make focusable for keyboard access
            handle.style.cssText = `
                position: absolute;
                width: 16px;
                height: 16px;
                background: #0d9488;
                border: 2px solid #fff;
                border-radius: 50%;
                cursor: move;
                transform: translate(-50%, -50%);
                left: ${corner.x}%;
                top: ${corner.y}%;
                z-index: 10;
                box-shadow: 0 2px 8px rgba(0,0,0,0.5);
                transition: background 0.2s;
            `;
            
            // Keyboard control with clamping
            handle.addEventListener('keydown', function(e) {
                const step = e.shiftKey ? 10 : 1; // Shift = 10x faster
                let updated = false;
                const margin = 3; // Same margin as visual bounds
                
                switch(e.key) {
                    case 'ArrowLeft':
                        cornerPinValues[corner.id].x -= step;
                        updated = true;
                        break;
                    case 'ArrowRight':
                        cornerPinValues[corner.id].x += step;
                        updated = true;
                        break;
                    case 'ArrowUp':
                        cornerPinValues[corner.id].y -= step;
                        updated = true;
                        break;
                    case 'ArrowDown':
                        cornerPinValues[corner.id].y += step;
                        updated = true;
                        break;
                }
                
                if (updated) {
                    e.preventDefault();
                    
                    // Clamp values to keep handles in bounds
                    // Range is approximately -100 to +100 for each corner
                    cornerPinValues[corner.id].x = Math.max(-100, Math.min(100, cornerPinValues[corner.id].x));
                    cornerPinValues[corner.id].y = Math.max(-100, Math.min(100, cornerPinValues[corner.id].y));
                    
                    // Update sliders based on corner ID
                    const xId = `keystone-${corner.id}-x`;  // Changed to Keystone sliders
                    const yId = `keystone-${corner.id}-y`;
                    const xSlider = document.getElementById(xId);
                    const ySlider = document.getElementById(yId);
                    
                    if (xSlider) xSlider.value = cornerPinValues[corner.id].x;
                    if (ySlider) ySlider.value = cornerPinValues[corner.id].y;
                    
                    updateKeystoneCorners();  // Changed to updateKeystoneCorners
                }
            });
            
            // Click to select for keyboard control
            handle.addEventListener('click', function(e) {
                e.stopPropagation(); // Don't trigger drag
                this.focus(); // Give focus for keyboard control
            });
            
            // Focus highlight
            handle.addEventListener('focus', function() {
                this.style.background = '#06d6a0';
                this.style.boxShadow = '0 0 0 3px rgba(6, 214, 160, 0.3)';
            });
            handle.addEventListener('blur', function() {
                this.style.background = '#0d9488';
                this.style.boxShadow = '0 2px 8px rgba(0,0,0,0.5)';
            });
            
            // Label
            const label = document.createElement('div');
            label.textContent = corner.label;
            label.style.cssText = `
                position: absolute;
                top: -20px;
                left: 50%;
                transform: translateX(-50%);
                font-size: 8px;
                color: #0d9488;
                font-weight: bold;
                white-space: nowrap;
                text-shadow: 0 1px 2px rgba(0,0,0,0.8);
            `;
            handle.appendChild(label);
            
            // Make draggable
            makeDraggable(handle, corner.id);
            
            container.appendChild(handle);
        });
        
        // Draw grid background
        drawCornerPinGrid();
    }
    
    function drawCornerPinGrid() {
        const container = document.getElementById('cornerpin-visual');
        if (!container) return;
        
        // Add SVG overlay for grid
        let svg = container.querySelector('svg');
        if (!svg) {
            svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.style.cssText = 'position:absolute; width:100%; height:100%; top:0; left:0; pointer-events:none;';
            container.insertBefore(svg, container.firstChild);
        }
        
        svg.innerHTML = '';
        
        // Draw grid lines
        for (let i = 0; i <= 4; i++) {
            const x = (i / 4) * 100;
            const y = (i / 4) * 100;
            
            // Vertical lines
            const vline = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            vline.setAttribute('x1', `${x}%`);
            vline.setAttribute('y1', '0%');
            vline.setAttribute('x2', `${x}%`);
            vline.setAttribute('y2', '100%');
            vline.setAttribute('stroke', '#333');
            vline.setAttribute('stroke-width', '1');
            vline.setAttribute('stroke-dasharray', '2,2');
            svg.appendChild(vline);
            
            // Horizontal lines
            const hline = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            hline.setAttribute('x1', '0%');
            hline.setAttribute('y1', `${y}%`);
            hline.setAttribute('x2', '100%');
            hline.setAttribute('y2', `${y}%`);
            hline.setAttribute('stroke', '#333');
            hline.setAttribute('stroke-width', '1');
            hline.setAttribute('stroke-dasharray', '2,2');
            svg.appendChild(hline);
        }
    }
    
    function makeDraggable(element, cornerId) {
        let isDragging = false;
        let startX, startY, startLeft, startTop;
        
        element.addEventListener('mousedown', (e) => {
            isDragging = true;
            element.style.background = '#06b6a3';
            
            const rect = element.parentElement.getBoundingClientRect();
            startX = e.clientX;
            startY = e.clientY;
            
            const computedStyle = window.getComputedStyle(element);
            startLeft = parseFloat(computedStyle.left);
            startTop = parseFloat(computedStyle.top);
            
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const container = element.parentElement;
            const rect = container.getBoundingClientRect();
            
            const deltaX = e.clientX - startX;
            const deltaY = e.clientY - startY;
            
            const newLeft = startLeft + deltaX;
            const newTop = startTop + deltaY;
            
            // Convert to percentage
            const leftPercent = (newLeft / rect.width) * 100;
            const topPercent = (newTop / rect.height) * 100;
            
            // CLAMP TO 0-100% - CANNOT GO OUTSIDE THE FRAME!
            const clampedLeft = Math.max(0, Math.min(100, leftPercent));
            const clampedTop = Math.max(0, Math.min(100, topPercent));
            
            element.style.left = clampedLeft + '%';
            element.style.top = clampedTop + '%';
            
            // Update slider values based on corner position
            // Calculate offset from corner's natural position
            const margin = 3; // Natural position margin
            let xValue, yValue;
            
            if (cornerId === 'tl') {
                // Top-Left: natural position is (margin, margin)
                xValue = Math.round((clampedLeft - margin) * 2);
                yValue = Math.round((margin - clampedTop) * 2);  // INVERTED: up is negative
            } else if (cornerId === 'tr') {
                // Top-Right: natural position is (100-margin, margin)
                xValue = Math.round((clampedLeft - (100 - margin)) * 2);
                yValue = Math.round((margin - clampedTop) * 2);  // INVERTED: up is negative
            } else if (cornerId === 'bl') {
                // Bottom-Left: natural position is (margin, 100-margin)
                xValue = Math.round((clampedLeft - margin) * 2);
                yValue = Math.round(((100 - margin) - clampedTop) * 2);  // INVERTED
            } else if (cornerId === 'br') {
                // Bottom-Right: natural position is (100-margin, 100-margin)
                xValue = Math.round((clampedLeft - (100 - margin)) * 2);
                yValue = Math.round(((100 - margin) - clampedTop) * 2);  // INVERTED
            }
            
            const xInput = document.getElementById(`keystone-${cornerId}-x`);  // Changed to Keystone
            const yInput = document.getElementById(`keystone-${cornerId}-y`);
            
            if (xInput) xInput.value = xValue;
            if (yInput) yInput.value = yValue;
            
            updateKeystoneCorners();  // Changed to updateKeystoneCorners
        });
        
        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                element.style.background = '#0d9488';
            }
        });
    }
    
    function updateCornerPinVisual() {
        // Update handle positions based on slider values
        const handles = {
            tl: document.getElementById('cp-handle-tl'),
            tr: document.getElementById('cp-handle-tr'),
            bl: document.getElementById('cp-handle-bl'),
            br: document.getElementById('cp-handle-br')
        };
        
        const margin = 3; // Same margin as initial position
        
        // Position handles at corners + offset from sliders
        // Y is INVERTED because slider +Y means image goes DOWN
        // but in visual editor, DOWN means higher top% value
        
        // TL = Top-Left corner (margin%, margin%) + offset
        if (handles.tl) {
            const tlLeft = margin + cornerPinTLX / 2;
            const tlTop = margin - cornerPinTLY / 2;
            handles.tl.style.left = Math.max(0, Math.min(100, tlLeft)) + '%';
            handles.tl.style.top = Math.max(0, Math.min(100, tlTop)) + '%';
        }
        // TR = Top-Right corner (100-margin%, margin%) + offset
        if (handles.tr) {
            const trLeft = (100 - margin) + cornerPinTRX / 2;
            const trTop = margin - cornerPinTRY / 2;
            handles.tr.style.left = Math.max(0, Math.min(100, trLeft)) + '%';
            handles.tr.style.top = Math.max(0, Math.min(100, trTop)) + '%';
        }
        // BL = Bottom-Left corner (margin%, 100-margin%) + offset
        if (handles.bl) {
            const blLeft = margin + cornerPinBLX / 2;
            const blTop = (100 - margin) - cornerPinBLY / 2;
            handles.bl.style.left = Math.max(0, Math.min(100, blLeft)) + '%';
            handles.bl.style.top = Math.max(0, Math.min(100, blTop)) + '%';
        }
        // BR = Bottom-Right corner (100-margin%, 100-margin%) + offset
        if (handles.br) {
            const brLeft = (100 - margin) + cornerPinBRX / 2;
            const brTop = (100 - margin) - cornerPinBRY / 2;
            handles.br.style.left = Math.max(0, Math.min(100, brLeft)) + '%';
            handles.br.style.top = Math.max(0, Math.min(100, brTop)) + '%';
        }
    }

    // ===== PRIMITIVE POPUP =====

    window.showPrimitivePopup = function(event) {
        event.stopPropagation();
        const popup = document.getElementById('primitive-popup');
        if (!popup) return;
        popup.classList.add('visible');

        const rect = event.target.getBoundingClientRect();
        popup.style.left = rect.left + 'px';
        popup.style.top = (rect.top - popup.offsetHeight - 5) + 'px';
    };

    function hidePrimitivePopup(event) {
        const popup = document.getElementById('primitive-popup');
        if (!popup) return;
        if (!popup.contains(event.target) && !event.target.classList.contains('add-primitive-btn')) {
            popup.classList.remove('visible');
        }
    }

    // ===== UPDATES =====

    function updateAll() {
        updateProjectorCamera();
        updateProjectionMatrix();
        updateMeasurements();
        updateUI();
    }

    function updateProjectorCamera() {
        if (!projectorCamera) return;
        projectorCamera.aspect = ASPECT;
        projectorCamera.fov = throwToFOV(throwRatio);
        projectorCamera.far = PROJECTOR_CAMERA_FAR;
        projectorCamera.updateProjectionMatrix();
    }

    function updateMeasurements() {
        if (!targetMesh || !projectorGroup) return;

        const dist = targetMesh.position.distanceTo(projectorGroup.position);
        const width = dist / throwRatio;
        const height = width / ASPECT;

        const shiftOffsetV = (lensShiftV / 100) * height;
        const shiftOffsetH = (lensShiftH / 100) * width;

        const imgCenter = targetMesh.position.clone();
        imgCenter.y += shiftOffsetV;
        imgCenter.x += shiftOffsetH;

        const visible = showMeasurements;
        const projPos = projectorGroup.position.clone();

        const labelHalfHeight = 0.1875;
        const offset = 0.02;

        if (spriteWidth) {
            spriteWidth.visible = visible;
            spriteWidth.position.set(imgCenter.x, imgCenter.y + height/2 + labelHalfHeight + offset, imgCenter.z);
            spriteWidth.lookAt(projPos);
            updateSpriteText(spriteWidth, width.toFixed(3) + ' m');
        }

        if (spriteHeight) {
            spriteHeight.visible = visible;
            spriteHeight.position.set(imgCenter.x - width/2, imgCenter.y, imgCenter.z);
            spriteHeight.lookAt(projPos);
            updateSpriteText(spriteHeight, height.toFixed(3) + ' m');
        }

        if (spriteTR) {
            spriteTR.visible = visible;
            spriteTR.position.set(imgCenter.x - width/2, imgCenter.y + height/2 + labelHalfHeight + offset, imgCenter.z);
            spriteTR.lookAt(projPos);
            updateSpriteText(spriteTR, 'tr: ' + throwRatio.toFixed(2));
        }

        if (spriteInfo) {
            spriteInfo.visible = visible;
            const midPoint = projectorGroup.position.clone().lerp(targetMesh.position, 0.5);
            spriteInfo.position.copy(midPoint);
            spriteInfo.lookAt(projPos);
            const lux = LUMENS / (width * height);
            updateSpriteText(spriteInfo, lux.toFixed(0) + ' lx / ' + dist.toFixed(3) + ' m');
        }

        const imgWEl = document.getElementById('image-width');
        if (imgWEl) imgWEl.value = width.toFixed(2);

        const imgHEl = document.getElementById('image-height');
        if (imgHEl) imgHEl.value = height.toFixed(2);

        const trEl = document.getElementById('throw-ratio-display');
        if (trEl) trEl.textContent = throwRatio.toFixed(2) + ':1';

        const distEl = document.getElementById('distance-display');
        if (distEl) distEl.textContent = dist.toFixed(2);
    }

    function updateUI() {
        const zoomValEl = document.getElementById('zoom-val');
        if (zoomValEl) zoomValEl.textContent = throwRatio.toFixed(2) + ':1';

        const svEl = document.getElementById('shift-v-val');
        if (svEl) svEl.textContent = lensShiftV + '%';

        const shEl = document.getElementById('shift-h-val');
        if (shEl) shEl.textContent = lensShiftH + '%';

        const ssEl = document.getElementById('shadow-softness-val');
        if (ssEl) ssEl.textContent = shadowSoftness.toFixed(1);

        const sbEl = document.getElementById('shadow-bias-val');
        if (sbEl) sbEl.textContent = shadowBias.toFixed(4);

        const piEl = document.getElementById('proj-intensity-val');
        if (piEl) piEl.textContent = projectionIntensity.toFixed(1);
        
        // Update stack display
        updateStackLumensDisplay();
    }

    // ===== PRIMITIVE FUNCTIONS =====

    window.addPrimitive = function(type) {
        const sizeX = 1.5;
        const sizeY = 1.5;
        const sizeZ = 1.5;

        let geometry;
        let name = '';
        let isHuman = false;

        switch(type) {
            case 'cube':
                geometry = new THREE.BoxGeometry(sizeX, sizeY, sizeZ);
                name = 'Cube';
                break;
            case 'sphere':
                geometry = new THREE.SphereGeometry(sizeX / 2, 32, 32);
                name = 'Sph√®re';
                break;
            case 'cylinder':
                geometry = new THREE.CylinderGeometry(sizeX / 2, sizeX / 2, sizeY, 32);
                name = 'Cylindre';
                break;
            case 'cone':
                geometry = new THREE.ConeGeometry(sizeX / 2, sizeY, 32);
                name = 'C√¥ne';
                break;
            case 'torus':
                geometry = new THREE.TorusGeometry(sizeX / 2, sizeX / 6, 16, 100);
                name = 'Tore';
                break;
            case 'plane':
                geometry = new THREE.PlaneGeometry(sizeX * 3, sizeY * 3);
                name = 'Plan';
                break;
            case 'human-realistic':
                isHuman = true;
                name = 'Mannequin Realistic';
                break;
            case 'human-lowpoly':
                isHuman = true;
                name = 'Mannequin Low-Poly';
                break;
            case 'human-stick':
                isHuman = true;
                name = 'Mannequin Stick';
                break;
            case 'human':  // Legacy support
                isHuman = true;
                name = 'Mannequin';
                type = 'human-realistic';  // Default to realistic
                break;
            default:
                return;
        }

        // Create human mannequin (1.80m tall)
        if (isHuman) {
            const humanGroup = new THREE.Group();
            humanGroup.userData = { name: 'Mannequin 1.80m', type: 'object' };
            
            const mat = createProjectedMaterial();
            mat.uniforms.baseColor.value.setRGB(0.7, 0.6, 0.5); // Skin-like color
            
            // Body proportions for 1.80m human
            // Head: ~23cm height, ~18cm width
            const headGeo = new THREE.SphereGeometry(0.09, 16, 16);
            const head = new THREE.Mesh(headGeo, mat.clone());
            head.position.y = 1.68; // Top of neck
            head.scale.set(1, 1.2, 0.9);
            head.castShadow = true;
            head.receiveShadow = true;
            humanGroup.add(head);
            projectedObjects.push(head);
            
            // Neck: 10cm
            const neckGeo = new THREE.CylinderGeometry(0.05, 0.06, 0.10, 12);
            const neck = new THREE.Mesh(neckGeo, mat.clone());
            neck.position.y = 1.54;
            neck.castShadow = true;
            neck.receiveShadow = true;
            humanGroup.add(neck);
            projectedObjects.push(neck);
            
            // Torso: ~55cm height, 40cm width, 22cm depth
            const torsoGeo = new THREE.CylinderGeometry(0.15, 0.18, 0.55, 12);
            const torso = new THREE.Mesh(torsoGeo, mat.clone());
            torso.position.y = 1.22;
            torso.scale.set(1.3, 1, 0.7);
            torso.castShadow = true;
            torso.receiveShadow = true;
            humanGroup.add(torso);
            projectedObjects.push(torso);
            
            // Pelvis
            const pelvisGeo = new THREE.CylinderGeometry(0.18, 0.14, 0.20, 12);
            const pelvis = new THREE.Mesh(pelvisGeo, mat.clone());
            pelvis.position.y = 0.85;
            pelvis.scale.set(1.2, 1, 0.6);
            pelvis.castShadow = true;
            pelvis.receiveShadow = true;
            humanGroup.add(pelvis);
            projectedObjects.push(pelvis);
            
            // Left arm (upper)
            const armGeo = new THREE.CylinderGeometry(0.04, 0.035, 0.30, 8);
            const leftUpperArm = new THREE.Mesh(armGeo, mat.clone());
            leftUpperArm.position.set(-0.25, 1.30, 0);
            leftUpperArm.rotation.z = 0.15;
            leftUpperArm.castShadow = true;
            leftUpperArm.receiveShadow = true;
            humanGroup.add(leftUpperArm);
            projectedObjects.push(leftUpperArm);
            
            // Left arm (lower)
            const leftLowerArm = new THREE.Mesh(armGeo.clone(), mat.clone());
            leftLowerArm.position.set(-0.28, 1.00, 0);
            leftLowerArm.rotation.z = 0.1;
            leftLowerArm.castShadow = true;
            leftLowerArm.receiveShadow = true;
            humanGroup.add(leftLowerArm);
            projectedObjects.push(leftLowerArm);
            
            // Right arm (upper)
            const rightUpperArm = new THREE.Mesh(armGeo.clone(), mat.clone());
            rightUpperArm.position.set(0.25, 1.30, 0);
            rightUpperArm.rotation.z = -0.15;
            rightUpperArm.castShadow = true;
            rightUpperArm.receiveShadow = true;
            humanGroup.add(rightUpperArm);
            projectedObjects.push(rightUpperArm);
            
            // Right arm (lower)
            const rightLowerArm = new THREE.Mesh(armGeo.clone(), mat.clone());
            rightLowerArm.position.set(0.28, 1.00, 0);
            rightLowerArm.rotation.z = -0.1;
            rightLowerArm.castShadow = true;
            rightLowerArm.receiveShadow = true;
            humanGroup.add(rightLowerArm);
            projectedObjects.push(rightLowerArm);
            
            // Left hand
            const handGeo = new THREE.SphereGeometry(0.04, 8, 8);
            const leftHand = new THREE.Mesh(handGeo, mat.clone());
            leftHand.position.set(-0.30, 0.82, 0);
            leftHand.scale.set(0.8, 1.2, 0.5);
            leftHand.castShadow = true;
            leftHand.receiveShadow = true;
            humanGroup.add(leftHand);
            projectedObjects.push(leftHand);
            
            // Right hand
            const rightHand = new THREE.Mesh(handGeo.clone(), mat.clone());
            rightHand.position.set(0.30, 0.82, 0);
            rightHand.scale.set(0.8, 1.2, 0.5);
            rightHand.castShadow = true;
            rightHand.receiveShadow = true;
            humanGroup.add(rightHand);
            projectedObjects.push(rightHand);
            
            // Left leg (upper) - 45cm
            const legGeo = new THREE.CylinderGeometry(0.06, 0.05, 0.45, 12);
            const leftUpperLeg = new THREE.Mesh(legGeo, mat.clone());
            leftUpperLeg.position.set(-0.10, 0.52, 0);
            leftUpperLeg.castShadow = true;
            leftUpperLeg.receiveShadow = true;
            humanGroup.add(leftUpperLeg);
            projectedObjects.push(leftUpperLeg);
            
            // Left leg (lower) - 42cm
            const lowerLegGeo = new THREE.CylinderGeometry(0.05, 0.04, 0.42, 12);
            const leftLowerLeg = new THREE.Mesh(lowerLegGeo, mat.clone());
            leftLowerLeg.position.set(-0.10, 0.09, 0);
            leftLowerLeg.castShadow = true;
            leftLowerLeg.receiveShadow = true;
            humanGroup.add(leftLowerLeg);
            projectedObjects.push(leftLowerLeg);
            
            // Right leg (upper)
            const rightUpperLeg = new THREE.Mesh(legGeo.clone(), mat.clone());
            rightUpperLeg.position.set(0.10, 0.52, 0);
            rightUpperLeg.castShadow = true;
            rightUpperLeg.receiveShadow = true;
            humanGroup.add(rightUpperLeg);
            projectedObjects.push(rightUpperLeg);
            
            // Right leg (lower)
            const rightLowerLeg = new THREE.Mesh(lowerLegGeo.clone(), mat.clone());
            rightLowerLeg.position.set(0.10, 0.09, 0);
            rightLowerLeg.castShadow = true;
            rightLowerLeg.receiveShadow = true;
            humanGroup.add(rightLowerLeg);
            projectedObjects.push(rightLowerLeg);
            
            // Feet
            const footGeo = new THREE.BoxGeometry(0.08, 0.05, 0.20);
            const leftFoot = new THREE.Mesh(footGeo, mat.clone());
            leftFoot.position.set(-0.10, 0.025, 0.04);
            leftFoot.castShadow = true;
            leftFoot.receiveShadow = true;
            humanGroup.add(leftFoot);
            projectedObjects.push(leftFoot);
            
            const rightFoot = new THREE.Mesh(footGeo.clone(), mat.clone());
            rightFoot.position.set(0.10, 0.025, 0.04);
            rightFoot.castShadow = true;
            rightFoot.receiveShadow = true;
            humanGroup.add(rightFoot);
            projectedObjects.push(rightFoot);
            
            // Position at center of scene
            humanGroup.position.set(0, 0, 0);
            
            scene.add(humanGroup);
            selectableObjects.push(humanGroup);
            
            // Record for undo
            pushHistory({
                type: 'create_object',
                object: humanGroup,
                objectType: 'human'
            });
            
            updateProjectionMatrix();
            selectObject(humanGroup);
            
            // Update hierarchy
            populateSceneHierarchy();
            
            document.getElementById('primitive-popup')?.classList.remove('visible');
            return;
        }

        const mat = createProjectedMaterial();
        // Force a bright gray color for visibility
        mat.uniforms.baseColor.value.setRGB(0.6, 0.6, 0.6);
        const mesh = new THREE.Mesh(geometry, mat);

        // Calculate height for ground placement
        let yPos = 0;
        if (type === 'sphere') {
            yPos = sizeX / 2; // radius
        } else if (type === 'cylinder' || type === 'cone') {
            yPos = sizeY / 2;
        } else if (type === 'cube') {
            yPos = sizeY / 2;
        } else if (type === 'torus') {
            yPos = sizeX / 2; // torus major radius
        } else if (type === 'plane') {
            yPos = 0;
        }

        // All primitives at origin (0, y, 0)
        mesh.position.set(0, yPos, 0);

        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.userData = { name: name, type: 'object' };

        scene.add(mesh);
        projectedObjects.push(mesh);
        selectableObjects.push(mesh);

        // Record for undo
        pushHistory({
            type: 'create_object',
            object: mesh,
            objectType: 'primitive'
        });

        updateProjectionMatrix();
        selectObject(mesh);
        
        // Update hierarchy
        populateSceneHierarchy();

        document.getElementById('primitive-popup')?.classList.remove('visible');
    };

    // Default wall for initial scene setup (at Z=-8)
    function addDefaultWall() {
        const geo = new THREE.BoxGeometry(8, 5, 0.2);
        const mat = createProjectedMaterial();
        mat.uniforms.baseColor.value.setRGB(0.6, 0.6, 0.6);
        const wall = new THREE.Mesh(geo, mat);
        wall.position.set(0, 2.5, -8);
        wall.castShadow = true;
        wall.receiveShadow = true;
        wall.userData = { name: 'Mur', type: 'object' };
        scene.add(wall);
        projectedObjects.push(wall);
        selectableObjects.push(wall);
        updateProjectionMatrix();
    }

    window.addWall = function() {
        const geo = new THREE.BoxGeometry(8, 5, 0.2);
        const mat = createProjectedMaterial();
        // Force a bright gray color for visibility
        mat.uniforms.baseColor.value.setRGB(0.6, 0.6, 0.6);
        const wall = new THREE.Mesh(geo, mat);
        // Wall placed at 0,0 but raised for projection target
        wall.position.set(0, 2.5, 0);
        wall.castShadow = true;
        wall.receiveShadow = true;
        wall.userData = { name: 'Mur', type: 'object' };
        scene.add(wall);
        projectedObjects.push(wall);
        selectableObjects.push(wall);

        // Record for undo
        pushHistory({
            type: 'create_object',
            object: wall,
            objectType: 'wall'
        });

        updateProjectionMatrix();

        document.getElementById('primitive-popup')?.classList.remove('visible');
    };

    // ===== √âCRAN 16:9 =====
    window.addScreen = function(width = 4) {
        console.log('üì∫ addScreen called with width:', width);
        
        // Calculer hauteur pour ratio 16:9
        const height = width / (16/9);
        const depth = 0.05; // √âcran fin
        
        console.log('Screen dimensions:', { width, height, depth });
        
        const geo = new THREE.BoxGeometry(width, height, depth);
        const mat = createProjectedMaterial();
        
        // √âcran blanc mat avec gain = 1.0 (parfait pour projection)
        mat.uniforms.baseColor.value.setRGB(0.9, 0.9, 0.9);
        
        const screen = new THREE.Mesh(geo, mat);
        
        // Position de l'√©cran - centr√©, √† hauteur moyenne
        screen.position.set(0, 2.5, 0);
        
        // Si un projecteur existe, positionner l'√©cran au niveau de sa target
        if (activeProjector && activeProjector.target) {
            const targetPos = activeProjector.target.position;
            screen.position.copy(targetPos);
            console.log('Screen positioned at projector target:', targetPos);
        } else {
            console.log('Screen positioned at default (0, 2.5, 0)');
        }
        
        screen.castShadow = true;
        screen.receiveShadow = true;
        screen.userData = { 
            name: '√âcran 16:9 (' + width.toFixed(1) + 'm)', 
            type: 'object',
            isScreen: true,
            screenWidth: width,
            screenHeight: height
        };
        
        scene.add(screen);
        projectedObjects.push(screen);
        selectableObjects.push(screen);

        // Record for undo
        pushHistory({
            type: 'create_object',
            object: screen,
            objectType: 'screen'
        });

        updateProjectionMatrix();
        updateSceneHierarchy();

        document.getElementById('primitive-popup')?.classList.remove('visible');
        
        console.log('‚úÖ Screen created and added to scene:', screen.userData.name);
        return screen;
    };

    // Variantes de tailles d'√©crans standards
    window.addScreenSmall = function() {
        return addScreen(3); // 3m = ~10 pieds
    };

    window.addScreenMedium = function() {
        return addScreen(5); // 5m = ~16 pieds
    };

    window.addScreenLarge = function() {
        return addScreen(8); // 8m = ~26 pieds
    };

    // Open custom screen modal
    window.addScreenCustom = function() {
        console.log('üéØ Opening custom screen modal');
        const modal = document.getElementById('custom-screen-modal');
        if (modal) {
            modal.style.display = 'block';
            // Focus on input
            setTimeout(() => {
                const input = document.getElementById('custom-screen-width');
                if (input) {
                    input.focus();
                    input.select();
                }
            }, 100);
            // Update preview
            updateScreenPreview();
        }
    };
    
    // Close custom screen modal
    window.closeCustomScreenModal = function() {
        const modal = document.getElementById('custom-screen-modal');
        if (modal) {
            modal.style.display = 'none';
        }
    };
    
    // Update screen dimensions preview
    window.updateScreenPreview = function() {
        const input = document.getElementById('custom-screen-width');
        const widthDisplay = document.getElementById('screen-preview-width');
        const heightDisplay = document.getElementById('screen-preview-height');
        
        if (input && widthDisplay && heightDisplay) {
            const width = parseFloat(input.value) || 4.0;
            const height = width / (16/9);
            
            widthDisplay.textContent = width.toFixed(2);
            heightDisplay.textContent = height.toFixed(2);
        }
    };
    
    // Create custom screen from modal
    window.createCustomScreen = function() {
        const input = document.getElementById('custom-screen-width');
        if (!input) {
            console.error('Input not found');
            return;
        }
        
        const width = parseFloat(input.value);
        
        if (isNaN(width) || width <= 0 || width > 100) {
            alert('‚ö†Ô∏è La largeur doit √™tre entre 0.1m et 100m');
            console.log('Invalid width:', width);
            return;
        }
        
        console.log('Creating custom screen with width:', width);
        const screen = addScreen(width);
        
        if (screen) {
            console.log('‚úÖ Custom screen created successfully!');
            // Select the newly created screen
            selectObject(screen);
            // Close modal
            closeCustomScreenModal();
        } else {
            console.error('‚ùå Failed to create screen');
        }
    };
    


    window.toggleObjectProjection = function() {
        if (!selectedObject || selectedObject.userData.type !== 'object') {
            alert("‚ö†Ô∏è S√©lectionnez d'abord un objet (√©cran, cube, etc.)");
            return;
        }
        
        // Toggle noProjection flag
        selectedObject.userData.noProjection = !selectedObject.userData.noProjection;
        
        const status = selectedObject.userData.noProjection ? 'D√âSACTIV√âE' : 'ACTIV√âE';
        const btn = document.getElementById('toggle-projection-btn');
        if (btn) {
            btn.textContent = selectedObject.userData.noProjection ? 'üö´ Projection OFF' : 'üé• Projection ON';
            btn.style.background = selectedObject.userData.noProjection ? '#dc2626' : '#0d9488';
        }
        
        console.log(`Projection ${status} pour ${selectedObject.userData.name}`);
        updateProjectionMatrix();
    };

    window.clearObjects = function() {
        const toRemove = projectedObjects.filter(o => o.userData.type === 'object');
        toRemove.forEach(o => {
            scene.remove(o);
            o.geometry?.dispose();
            o.material?.dispose();
            projectedObjects.splice(projectedObjects.indexOf(o), 1);
            selectableObjects.splice(selectableObjects.indexOf(o), 1);
        });
        if (selectedObject && toRemove.includes(selectedObject)) selectObject(null);
    };

    function updateAllBaseColors() {
        scene.traverse((obj) => {
            if (obj.isMesh && obj.material && obj.material.uniforms && obj.material.uniforms.baseColor) {
                obj.material.uniforms.baseColor.value.setHex(0x555555);
            }
        });
    }

    // ===== UI HANDLERS =====

    window.changeLens = function() {
        const lensEl = document.getElementById('lens-select');
        if (!lensEl) return;

        const id = lensEl.value;
        currentLens = LENSES[id] || currentLens;

        const specThrowEl = document.getElementById('spec-throw');
        if (specThrowEl) {
            specThrowEl.textContent = currentLens.fixed
                ? currentLens.throwMin + ':1'
                : currentLens.throwMin + '-' + currentLens.throwMax + ':1';
        }

        const specShiftVEl = document.getElementById('spec-shift-v');
        if (specShiftVEl) {
            specShiftVEl.textContent = currentLens.shiftV[0] + '% / +' + currentLens.shiftV[1] + '%';
        }

        const specShiftHEl = document.getElementById('spec-shift-h');
        if (specShiftHEl) {
            specShiftHEl.textContent = currentLens.shiftH[0] + '% / +' + currentLens.shiftH[1] + '%';
        }

        const zoomEl = document.getElementById('zoom');
        if (zoomEl) {
            zoomEl.min = currentLens.throwMin;
            zoomEl.max = currentLens.throwMax;
            zoomEl.disabled = !!currentLens.fixed;
            throwRatio = Math.max(currentLens.throwMin, Math.min(currentLens.throwMax, throwRatio));
            zoomEl.value = throwRatio;
        } else {
            throwRatio = Math.max(currentLens.throwMin, Math.min(currentLens.throwMax, throwRatio));
        }

        const svEl = document.getElementById('shift-v');
        if (svEl) {
            svEl.min = currentLens.shiftV[0];
            svEl.max = currentLens.shiftV[1];
        }

        const shEl = document.getElementById('shift-h');
        if (shEl) {
            shEl.min = currentLens.shiftH[0];
            shEl.max = currentLens.shiftH[1];
        }

        updateAll();
    };

    window.updateZoom = function() {
        throwRatio = parseFloat((document.getElementById('zoom') || {value:throwRatio}).value);
        updateAll();
    };

    window.updateFromWidth = function() {
        const w = parseFloat((document.getElementById('image-width') || {value:7.35}).value);
        projDistance = w * throwRatio;
        const dir = new THREE.Vector3(0,0,-1).applyQuaternion(projectorGroup.quaternion);
        targetMesh.position.copy(projectorGroup.position.clone().add(dir.multiplyScalar(projDistance)));
        userMovedTarget = true;
        updateAll();
    };

    window.updateFromHeight = function() {
        const h = parseFloat((document.getElementById('image-height') || {value:4.59}).value);
        const w = h * ASPECT;
        projDistance = w * throwRatio;
        const dir = new THREE.Vector3(0,0,-1).applyQuaternion(projectorGroup.quaternion);
        targetMesh.position.copy(projectorGroup.position.clone().add(dir.multiplyScalar(projDistance)));
        userMovedTarget = true;
        updateAll();
    };

    window.updateFrustumFar = function() {
        frustumFar = parseFloat((document.getElementById('frustum-far') || {value:frustumFar}).value);
        const valEl = document.getElementById('frustum-far-val');
        if (valEl) valEl.textContent = frustumFar.toFixed(1) + ' m';
        
        if (shadowLight) {
            shadowLight.shadow.camera.far = frustumFar;
            shadowLight.shadow.camera.updateProjectionMatrix();
        }
        
        updateAll();
    };

    window.updateLensShift = function() {
        lensShiftV = parseInt((document.getElementById('shift-v') || {value:lensShiftV}).value);
        lensShiftH = parseInt((document.getElementById('shift-h') || {value:lensShiftH}).value);
        updateAll();
    };

    window.resetLensShift = function() {
        lensShiftV = 0; lensShiftH = 0;
        const sv = document.getElementById('shift-v');
        const sh = document.getElementById('shift-h');
        if (sv) sv.value = 0;
        if (sh) sh.value = 0;
        updateAll();
    };

    window.updateShadowQuality = function() {
        shadowSoftness = parseFloat((document.getElementById('shadow-softness') || {value:shadowSoftness}).value);
        shadowBias = parseFloat((document.getElementById('shadow-bias') || {value:shadowBias}).value);
        updateAll();
    };

    window.updateProjectionIntensity = function() {
        projectionIntensity = parseFloat((document.getElementById('proj-intensity') || {value:projectionIntensity}).value);
        updateProjectionMatrix();
        updateUI();
    };

    // ========== PROJECTOR STACK SYSTEM ==========
    
    // Sync stack controls between sidebar and floating window
    window.syncStack = function(control, value) {
        if (control === 'count') {
            value = parseInt(value);
            document.getElementById('stack-count').value = value;
            document.getElementById('stack-count-val').textContent = value;
            document.getElementById('stack-count-val-2').textContent = value;
            updateStackCount();
        } else if (control.startsWith('offset-')) {
            value = parseFloat(value);
            const axis = control.split('-')[1]; // x, y, or z
            const originalId = 'stack-offset-' + axis;
            document.getElementById(originalId).value = value;
            document.getElementById(originalId + '-val').textContent = value.toFixed(2);
            document.getElementById(originalId + '-val-2').textContent = value.toFixed(2);
            updateStackOffset();
        } else if (control === 'auto-lumens' || control === 'visible' || control === 'powered') {
            const originalId = 'stack-' + control;
            document.getElementById(originalId).checked = value;
            document.getElementById(originalId + '-2').checked = value;
            updateStackSettings();
        }
    };
    
    window.updateStackCount = function() {
        if (!activeProjector) return;
        
        const count = parseInt(document.getElementById('stack-count').value);
        document.getElementById('stack-count-val').textContent = count;
        document.getElementById('stack-count-val-2').textContent = count; // Sync sidebar
        
        // Remove existing dummy projectors for this main projector
        if (activeProjector.dummyProjectors) {
            activeProjector.dummyProjectors.forEach(dummy => {
                scene.remove(dummy.mesh);
                scene.remove(dummy.target);
                scene.remove(dummy.helper);
                if (dummy.light) scene.remove(dummy.light);
            });
        }
        
        activeProjector.dummyProjectors = [];
        activeProjector.stackCount = count;
        
        // Create new dummy projectors
        if (count > 0) {
            const offsetX = parseFloat(document.getElementById('stack-offset-x').value);
            const offsetY = parseFloat(document.getElementById('stack-offset-y').value);
            const offsetZ = parseFloat(document.getElementById('stack-offset-z').value);
            
            for (let i = 1; i <= count; i++) {
                const dummy = createDummyProjector(activeProjector, i, offsetX, offsetY, offsetZ);
                activeProjector.dummyProjectors.push(dummy);
            }
        }
        
        // Update lumens display
        updateStackLumensDisplay();
        updateStackSettings();
    };
    
    function updateStackLumensDisplay() {
        if (!activeProjector) return;
        
        const baseLumens = activeProjector.projectorLumens || 25000;
        const stackMultiplier = (activeProjector.stackCount || 0) + 1; // +1 for the main projector
        const totalLumens = baseLumens * stackMultiplier;
        
        const lumensEl = document.getElementById('stack-total-lumens');
        const multiplierEl = document.getElementById('stack-multiplier');
        const lumensEl2 = document.getElementById('stack-total-lumens-2');
        const multiplierEl2 = document.getElementById('stack-multiplier-2');
        
        if (lumensEl) lumensEl.textContent = totalLumens.toLocaleString();
        if (multiplierEl) multiplierEl.textContent = stackMultiplier;
        if (lumensEl2) lumensEl2.textContent = totalLumens.toLocaleString();
        if (multiplierEl2) multiplierEl2.textContent = stackMultiplier;
        
        // Update stackMultiplier property for shader use
        activeProjector.stackMultiplier = stackMultiplier;
    }
    
    window.updateStackOffset = function() {
        const offsetX = parseFloat(document.getElementById('stack-offset-x').value);
        const offsetY = parseFloat(document.getElementById('stack-offset-y').value);
        const offsetZ = parseFloat(document.getElementById('stack-offset-z').value);
        
        document.getElementById('stack-offset-x-val').textContent = offsetX.toFixed(2);
        document.getElementById('stack-offset-y-val').textContent = offsetY.toFixed(2);
        document.getElementById('stack-offset-z-val').textContent = offsetZ.toFixed(2);
        document.getElementById('stack-offset-x-val-2').textContent = offsetX.toFixed(2);
        document.getElementById('stack-offset-y-val-2').textContent = offsetY.toFixed(2);
        document.getElementById('stack-offset-z-val-2').textContent = offsetZ.toFixed(2);
        
        if (!activeProjector || !activeProjector.dummyProjectors) return;
        
        // Update positions of all dummy projectors
        activeProjector.dummyProjectors.forEach((dummy, i) => {
            const index = i + 1;
            dummy.mesh.position.copy(activeProjector.mesh.position);
            dummy.mesh.position.x += offsetX * index;
            dummy.mesh.position.y += offsetY * index;
            dummy.mesh.position.z += offsetZ * index;
            
            dummy.target.position.copy(activeProjector.target.position);
            dummy.mesh.lookAt(dummy.target.position);
        });
    };
    
    window.updateStackSettings = function() {
        if (!activeProjector || !activeProjector.dummyProjectors) return;
        
        const autoLumens = document.getElementById('stack-auto-lumens').checked;
        const visible = document.getElementById('stack-visible').checked;
        const powered = document.getElementById('stack-powered').checked;
        
        activeProjector.dummyProjectors.forEach(dummy => {
            dummy.mesh.visible = visible;
            dummy.target.visible = visible;
            if (dummy.helper) dummy.helper.visible = visible;
            if (dummy.light) dummy.light.visible = powered;
        });
        
        // Update lumens multiplication in shader
        updateProjectionMatrix();
    };
    
    function createDummyProjector(mainProj, index, offsetX, offsetY, offsetZ) {
        // Clone the main projector geometry
        const geometry = mainProj.mesh.geometry.clone();
        const material = new THREE.MeshStandardMaterial({ 
            color: 0x666666,
            metalness: 0.3,
            roughness: 0.7,
            opacity: 0.7,
            transparent: true
        });
        
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.copy(mainProj.mesh.position);
        mesh.position.x += offsetX * index;
        mesh.position.y += offsetY * index;
        mesh.position.z += offsetZ * index;
        mesh.castShadow = true;
        
        // Create target
        const targetGeo = new THREE.SphereGeometry(0.1, 8, 8);
        const targetMat = new THREE.MeshBasicMaterial({ color: 0xff6666, opacity: 0.5, transparent: true });
        const target = new THREE.Mesh(targetGeo, targetMat);
        target.position.copy(mainProj.target.position);
        
        mesh.lookAt(target.position);
        
        scene.add(mesh);
        scene.add(target);
        
        return { mesh, target, helper: null, light: null };
    }

    window.togglePCFQuality = function() {
        useHighQualityPCF = !!(document.getElementById('high-quality-pcf') && document.getElementById('high-quality-pcf').checked);
        updateProjectionMatrix();
    };

    window.toggleTargetLock = function() {
        if (!activeProjector) return;
        
        // Simple toggle
        activeProjector.targetLocked = !activeProjector.targetLocked;
        targetLocked = activeProjector.targetLocked; // Sync global
        
        // If unlocking, clear target object reference
        if (!activeProjector.targetLocked) {
            activeProjector.targetObject = null;
        }
        
        // Mark as moved so lock works
        activeProjector.userMovedTarget = true;
        
        console.log(`üéØ Lock Aim: ${activeProjector.targetLocked ? 'ON' : 'OFF'}`);
        
        // Update button
        updateLockAimButton();
        
        // Update hierarchy
        populateSceneHierarchy();
    };
    
    function updateLockAimButton() {
        const btn = document.getElementById('lock-aim-btn');
        if (!btn || !activeProjector) return;
        
        if (activeProjector.targetLocked) {
            btn.style.background = 'rgba(13,148,136,0.2)';
            btn.style.borderColor = '#0d9488';
            btn.style.color = '#0d9488';
            btn.textContent = 'üîí Locked';
        } else {
            btn.style.background = 'rgba(255,107,107,0.1)';
            btn.style.borderColor = '#ff6b6b';
            btn.style.color = '#ff6b6b';
            btn.textContent = 'üîì Unlocked';
        }
    }
    
    window.toggleTargetLockFromTopBar = function() {
        // Just call the main function
        toggleTargetLock();
    };
    
    // ========== SET AS TARGET SYSTEM ==========
    let contextMenuTarget = null; // Store object for context menu
    
    window.setSelectedAsTarget = function() {
        if (!activeProjector || !selectedObject) return;
        
        // Don't allow setting projector or target as target
        if (selectedObject.userData.isProjector || selectedObject.userData.isTarget) {
            console.log('‚ùå Cannot set projector or target as target');
            return;
        }
        
        setObjectAsTarget(selectedObject);
    };
    
    window.setAsTargetFromContextMenu = function() {
        if (!activeProjector || !contextMenuTarget) return;
        
        setObjectAsTarget(contextMenuTarget);
        hideContextMenu();
    };
    
    window.deleteObjectFromContextMenu = function() {
        if (!contextMenuTarget) return;
        
        deleteObject(contextMenuTarget);
        hideContextMenu();
    };
    
    function setObjectAsTarget(obj) {
        if (!activeProjector) {
            console.log('‚ùå No active projector');
            return;
        }
        
        // Store reference to target object for hierarchy
        activeProjector.targetObject = obj;
        
        // Move target mesh to object position
        const worldPos = new THREE.Vector3();
        obj.getWorldPosition(worldPos);
        targetMesh.position.copy(worldPos);
        
        // Mark as moved so lock works
        activeProjector.userMovedTarget = true;
        
        // Auto-enable Lock Aim
        activeProjector.targetLocked = true;
        targetLocked = true;
        
        // Update Lock Aim button
        updateLockAimButton();
        
        // Update hierarchy
        populateSceneHierarchy();
        
        console.log(`üéØ Target set to: ${obj.userData.name || obj.name || 'Object'}`);
        console.log(`‚úÖ Lock Aim auto-enabled - projector will follow`);
    }
    
    function showContextMenu(x, y, obj) {
        const menu = document.getElementById('context-menu');
        if (!menu) return;
        
        contextMenuTarget = obj;
        
        menu.style.left = x + 'px';
        menu.style.top = y + 'px';
        menu.style.display = 'block';
    }
    
    function hideContextMenu() {
        const menu = document.getElementById('context-menu');
        if (menu) menu.style.display = 'none';
        contextMenuTarget = null;
    }
    
    // Hide context menu on click anywhere
    document.addEventListener('click', function(e) {
        if (!e.target.closest('#context-menu')) {
            hideContextMenu();
        }
    });
    
    function updateLockTargetButton() {
        const btn = document.getElementById('lock-target-btn-top');
        if (!btn) return;
        
        if (targetLocked) {
            btn.style.cssText = 'margin-left: 12px; padding: 6px 12px; background: rgba(13,148,136,0.2); border: 1px solid #0d9488; border-radius: 4px; color: #0d9488; cursor: pointer; font-size: 12px; font-weight: 600;';
            btn.innerHTML = 'üîí Locked';
        } else {
            btn.style.cssText = 'margin-left: 12px; padding: 6px 12px; background: rgba(255,107,107,0.1); border: 1px solid #ff6b6b; border-radius: 4px; color: #ff6b6b; cursor: pointer; font-size: 12px; font-weight: 600;';
            btn.innerHTML = 'üîì Unlocked';
        }
    }

    window.toggleFrustum = function() {
        const isVisible = !!(document.getElementById('show-frustum') && document.getElementById('show-frustum').checked);
        // Toggle ALL projector helpers
        projectors.forEach(proj => {
            if (proj.helper) proj.helper.visible = isVisible;
        });
        // Also update the global projectorHelper reference (active projector)
        if (projectorHelper) projectorHelper.visible = isVisible;
        
        // Update menu icon
        const menuIcon = document.getElementById('menu-frustum-icon');
        if (menuIcon) menuIcon.textContent = isVisible ? '‚úì' : '';
    };

    window.toggleMeasurements = function() {
        showMeasurements = !showMeasurements;
        updateMeasurements();
        
        // Update button style
        const btn = document.getElementById('measure-btn');
        if (btn) {
            if (showMeasurements) {
                btn.style.background = 'rgba(13,148,136,0.2)';
                btn.style.borderColor = '#0d9488';
                btn.style.color = '#0d9488';
            } else {
                btn.style.background = 'rgba(255,255,255,0.05)';
                btn.style.borderColor = 'rgba(255,255,255,0.1)';
                btn.style.color = '#888';
            }
        }
        
        // Update menu icon if exists
        const menuIcon = document.getElementById('menu-measurements-icon');
        if (menuIcon) menuIcon.textContent = showMeasurements ? '‚úì' : '';
    };

    window.setSnapPoint = function(point) {
        snapPoint = point;
        document.querySelectorAll('.snap-btn').forEach(b => b.classList.remove('active'));
        const btn = document.querySelector(`[data-snap="${point}"]`);
        if (btn) btn.classList.add('active');
    };

    window.setSelectedAsTarget = function() {
        if (!selectedObject || selectedObject.userData.isProjector || selectedObject.userData.isTarget) return;

        const box = new THREE.Box3().setFromObject(selectedObject);
        const center = new THREE.Vector3();
        box.getCenter(center);

        let targetPos = center.clone();
        const size = new THREE.Vector3();
        box.getSize(size);

        switch(snapPoint) {
            case 'tl': targetPos.add(new THREE.Vector3(-size.x/2, size.y/2, 0)); break;
            case 'tr': targetPos.add(new THREE.Vector3(size.x/2, size.y/2, 0)); break;
            case 'bl': targetPos.add(new THREE.Vector3(-size.x/2, -size.y/2, 0)); break;
            case 'br': targetPos.add(new THREE.Vector3(size.x/2, -size.y/2, 0)); break;
        }

        targetMesh.position.copy(targetPos);
        userMovedTarget = true;
        
        // Auto-adjust frustum far to match distance to target
        if (projectorGroup) {
            const projPos = projectorGroup.position.clone();
            const distance = projPos.distanceTo(targetPos);
            // Add small margin (10%) to ensure target is fully within frustum
            frustumFar = Math.max(1, distance * 1.1);
            
            // Update UI slider and value display
            const slider = document.getElementById('frustum-far');
            const valEl = document.getElementById('frustum-far-val');
            if (slider) {
                slider.value = frustumFar;
                slider.max = Math.max(500, frustumFar + 50); // Extend max if needed
            }
            if (valEl) valEl.textContent = frustumFar.toFixed(1) + ' m';
            
            // Update shadow camera
            if (shadowLight) {
                shadowLight.shadow.camera.far = frustumFar;
                shadowLight.shadow.camera.updateProjectionMatrix();
            }
        }
        
        updateAll();
    };

    // Show snap points on the selected object's bounding box
    window.showObjectSnapPoints = function() {
        const panel = document.getElementById('object-snap-points');
        const list = document.getElementById('snap-points-list');
        
        if (!selectedObject || selectedObject.userData.isProjector || selectedObject.userData.isTarget) {
            panel?.classList.remove('visible');
            return;
        }
        
        // Calculate bounding box
        const box = new THREE.Box3().setFromObject(selectedObject);
        const center = new THREE.Vector3();
        const size = new THREE.Vector3();
        box.getCenter(center);
        box.getSize(size);
        
        // Define snap points (relative to bounding box)
        const snapPoints = [
            { name: 'Centre', pos: center.clone() },
            { name: 'Haut', pos: center.clone().add(new THREE.Vector3(0, size.y/2, 0)) },
            { name: 'Bas', pos: center.clone().add(new THREE.Vector3(0, -size.y/2, 0)) },
            { name: 'Gauche', pos: center.clone().add(new THREE.Vector3(-size.x/2, 0, 0)) },
            { name: 'Droite', pos: center.clone().add(new THREE.Vector3(size.x/2, 0, 0)) },
            { name: 'Avant', pos: center.clone().add(new THREE.Vector3(0, 0, size.z/2)) },
            { name: 'Arri√®re', pos: center.clone().add(new THREE.Vector3(0, 0, -size.z/2)) },
            { name: 'H-G', pos: box.min.clone().setY(box.max.y) },
            { name: 'H-D', pos: new THREE.Vector3(box.max.x, box.max.y, box.min.z) },
            { name: 'B-G', pos: box.min.clone() },
            { name: 'B-D', pos: new THREE.Vector3(box.max.x, box.min.y, box.min.z) },
        ];
        
        // Build buttons
        list.innerHTML = snapPoints.map((sp, i) => 
            `<button class="snap-point-btn" onclick="snapToObjectPoint(${i})" data-index="${i}">${sp.name}</button>`
        ).join('');
        
        // Store snap points for later use
        window._objectSnapPoints = snapPoints;
        
        panel?.classList.toggle('visible');
    };
    
    window.snapToObjectPoint = function(index) {
        const snapPoints = window._objectSnapPoints;
        if (!snapPoints || !snapPoints[index]) return;
        
        const targetPos = snapPoints[index].pos.clone();
        targetMesh.position.copy(targetPos);
        userMovedTarget = true;
        
        // Auto-adjust frustum far to match distance to target
        if (projectorGroup) {
            const projPos = projectorGroup.position.clone();
            const distance = projPos.distanceTo(targetPos);
            frustumFar = Math.max(1, distance * 1.1);
            
            const slider = document.getElementById('frustum-far');
            const valEl = document.getElementById('frustum-far-val');
            if (slider) {
                slider.value = frustumFar;
                slider.max = Math.max(500, frustumFar + 50);
            }
            if (valEl) valEl.textContent = frustumFar.toFixed(1) + ' m';
            
            if (shadowLight) {
                shadowLight.shadow.camera.far = frustumFar;
                shadowLight.shadow.camera.updateProjectionMatrix();
            }
        }
        
        // Highlight selected button
        document.querySelectorAll('.snap-point-btn').forEach(b => b.classList.remove('active'));
        const btn = document.querySelector(`.snap-point-btn[data-index="${index}"]`);
        if (btn) btn.classList.add('active');
        
        updateAll();
    };

    window.loadImage = function() {
        const file = document.getElementById('image-upload') ? document.getElementById('image-upload').files[0] : null;
        if (!file) return;

        const reader = new FileReader();
        reader.onload = e => {
            new THREE.TextureLoader().load(e.target.result,
                tex => {
                    tex.minFilter = THREE.LinearFilter;
                    tex.anisotropy = renderer.capabilities.getMaxAnisotropy ? renderer.capabilities.getMaxAnisotropy() : 1;
                    
                    // Update global and ALL projectors with the texture
                    projectionTexture = tex;
                    projectors.forEach(proj => {
                        proj.projectionTexture = tex;
                    });

                    let updatedCount = 0;
                    projectedObjects.forEach(obj => {
                        if (obj.material?.uniforms) {
                            // Update for all projectors
                            for (let i = 0; i < 4; i++) {
                                if (obj.material.uniforms[`projTexture${i}`]) {
                                    obj.material.uniforms[`projTexture${i}`].value = tex;
                                    obj.material.uniforms[`hasTexture${i}`].value = true;
                                }
                            }
                            obj.material.needsUpdate = true;
                            updatedCount++;
                        }
                    });
                    updateProjectionMatrix();
                    const status = document.getElementById('image-status');
                    if (status) status.innerHTML = '<div class="status success">‚úì Charg√© (tous les projecteurs)</div>';
                },
                undefined,
                err => {
                    const status = document.getElementById('image-status');
                    if (status) status.innerHTML = '<div class="status info">‚úó Erreur chargement</div>';
                }
            );
        };
        reader.readAsDataURL(file);
    };
    
    // Load image for active projector
    window.loadProjectorImage = function() {
        const file = document.getElementById('proj-image-upload')?.files[0];
        if (!file) return;
        
        console.log('üì∑ Loading image for active projector:', file.name);
        
        // CLEANUP old video if any
        if (window.currentVideoElement) {
            console.log('üßπ Stopping old video...');
            window.currentVideoElement.pause();
            window.currentVideoElement.src = '';
            window.currentVideoElement.remove();
            window.currentVideoElement = null;
        }
        
        // CLEANUP old texture
        if (window.currentVideoTexture) {
            window.currentVideoTexture.dispose();
            window.currentVideoTexture = null;
        }
        
        const reader = new FileReader();
        reader.onload = e => {
            new THREE.TextureLoader().load(e.target.result,
                tex => {
                    tex.minFilter = THREE.LinearFilter;
                    tex.anisotropy = renderer.capabilities.getMaxAnisotropy ? renderer.capabilities.getMaxAnisotropy() : 1;
                    
                    // Apply to active projector
                    if (activeProjector) {
                        activeProjector.projectionTexture = tex;
                        console.log('‚úì Image applied to active projector');
                    }
                    
                    // Update global for new projectors
                    projectionTexture = tex;
                    
                    // Update all projected objects
                    projectedObjects.forEach(obj => {
                        if (obj.material?.uniforms) {
                            for (let i = 0; i < 4; i++) {
                                if (obj.material.uniforms[`projTexture${i}`]) {
                                    obj.material.uniforms[`projTexture${i}`].value = tex;
                                    obj.material.uniforms[`hasTexture${i}`].value = true;
                                }
                            }
                            obj.material.needsUpdate = true;
                        }
                    });
                    
                    updateProjectionMatrix();
                    
                    const status = document.getElementById('image-status');
                    if (status) status.innerHTML = '<div style="color:#0d9488; font-size:10px;">‚úì Image loaded</div>';
                },
                undefined,
                err => {
                    console.error('‚úó Error loading image:', err);
                    const status = document.getElementById('image-status');
                    if (status) status.innerHTML = '<div style="color:#f87171; font-size:10px;">‚úó Error loading</div>';
                }
            );
        };
        reader.readAsDataURL(file);
    };
    
    // Load video for active projector (MP4, ProRes, MOV)
    // FINAL WORKING SOLUTION: Data URL + Canvas
    window.loadProjectorVideo = async function() {
        const file = document.getElementById('proj-video-upload')?.files[0];
        if (!file) return;
        
        const sizeMB = file.size / 1024 / 1024;
        console.log('üé¨ Loading video:', file.name, sizeMB.toFixed(2), 'MB');
        
        const status = document.getElementById('image-status');
        if (status) status.innerHTML = '<div style="color:#888; font-size:10px;">‚è≥ Reading video file...</div>';
        
        try {
            // Read as data URL (bypasses blob CSP)
            console.log('Converting to data URL...');
            const dataURL = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
            
            console.log('‚úì Data URL created');
            
            if (status) status.innerHTML = '<div style="color:#888; font-size:10px;">‚è≥ Creating video element...</div>';
            
            // Create hidden video element
            const video = document.createElement('video');
            video.style.position = 'absolute';
            video.style.top = '-9999px';
            video.style.width = '1px';
            video.style.height = '1px';
            video.muted = true;
            video.loop = true;
            video.playsInline = true;
            document.body.appendChild(video);
            
            // Try loading with data URL
            video.src = dataURL;
            
            console.log('Waiting for video metadata...');
            
            // Wait for metadata or error
            const result = await Promise.race([
                new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        console.log('‚úì Video metadata loaded:', video.videoWidth, 'x', video.videoHeight);
                        resolve('metadata');
                    };
                }),
                new Promise((resolve) => {
                    video.onerror = () => {
                        console.log('‚ö†Ô∏è Direct video load failed, using Canvas fallback');
                        resolve('error');
                    };
                }),
                new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Timeout')), 10000);
                })
            ]);
            
            if (result === 'error') {
                // Canvas fallback: extract frames manually
                console.log('Using Canvas extraction method...');
                if (status) status.innerHTML = '<div style="color:#888; font-size:10px;">‚è≥ Extracting video frames...</div>';
                
                // Create canvas
                const canvas = document.createElement('canvas');
                canvas.width = 1920;
                canvas.height = 1080;
                const ctx = canvas.getContext('2d');
                
                console.log('Canvas created, starting video...');
                
                // Force video to play
                video.currentTime = 0;
                video.loop = true;
                video.muted = true;
                
                // Try to play (might fail silently)
                try {
                    await video.play();
                    console.log('‚úì Video playing');
                } catch (e) {
                    console.log('Play auto-failed (expected), will draw frames anyway');
                }
                
                // Create CanvasTexture
                const canvasTexture = new THREE.CanvasTexture(canvas);
                canvasTexture.minFilter = THREE.LinearFilter;
                canvasTexture.magFilter = THREE.LinearFilter;
                
                // Update canvas continuously (don't check paused state)
                let frameCount = 0;
                const updateCanvas = () => {
                    try {
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        canvasTexture.needsUpdate = true;
                        frameCount++;
                        
                        if (frameCount % 60 === 0) {
                            console.log('Canvas updated', frameCount, 'frames, video time:', video.currentTime.toFixed(2));
                        }
                    } catch (e) {
                        // Ignore drawing errors
                    }
                    requestAnimationFrame(updateCanvas);
                };
                updateCanvas();
                
                console.log('Canvas update loop started');
                
                // Apply canvas texture
                if (activeProjector) activeProjector.projectionTexture = canvasTexture;
                projectionTexture = canvasTexture;
                
                projectedObjects.forEach(obj => {
                    if (obj.material?.uniforms) {
                        for (let i = 0; i < 4; i++) {
                            if (obj.material.uniforms[`projTexture${i}`]) {
                                obj.material.uniforms[`projTexture${i}`].value = canvasTexture;
                                obj.material.uniforms[`hasTexture${i}`].value = true;
                            }
                        }
                        obj.material.needsUpdate = true;
                    }
                });
                
                console.log('‚úì Canvas texture applied');
                
            } else {
                // Direct VideoTexture (if metadata loaded successfully)
                console.log('Using direct VideoTexture...');
                
                const videoTexture = new THREE.VideoTexture(video);
                videoTexture.minFilter = THREE.LinearFilter;
                videoTexture.magFilter = THREE.LinearFilter;
                
                await video.play();
                console.log('‚úì Video playing');
                
                // Apply video texture
                if (activeProjector) activeProjector.projectionTexture = videoTexture;
                projectionTexture = videoTexture;
                
                projectedObjects.forEach(obj => {
                    if (obj.material?.uniforms) {
                        for (let i = 0; i < 4; i++) {
                            if (obj.material.uniforms[`projTexture${i}`]) {
                                obj.material.uniforms[`projTexture${i}`].value = videoTexture;
                                obj.material.uniforms[`hasTexture${i}`].value = true;
                            }
                        }
                        obj.material.needsUpdate = true;
                    }
                });
                
                console.log('‚úì VideoTexture applied');
            }
            
            updateProjectionMatrix();
            
            if (status) status.innerHTML = '<div style="color:#0d9488; font-size:10px;">‚úì Video loaded!</div>';
            console.log('‚úÖ Video projection ready');
            
        } catch (error) {
            console.error('‚ùå Video error:', error);
            if (status) status.innerHTML = `<div style="color:#f87171; font-size:10px;">‚úó ${error.message}</div>`;
        }
    };
    
    // MODERN FILE PICKER (Chrome 86+) - bypasses CSP!
    window.loadVideoModern = async function() {
        try {
            if (!('showOpenFilePicker' in window)) {
                alert('‚ùå Not supported in this browser\n\nUse Chrome/Edge 86+');
                return;
            }
            
            console.log('üé¨ Opening modern file picker...');
            
            // CLEANUP: Stop and remove old videos
            if (window.currentVideoElement) {
                console.log('üßπ Cleaning up old video...');
                window.currentVideoElement.pause();
                window.currentVideoElement.src = '';
                window.currentVideoElement.remove();
                window.currentVideoElement = null;
            }
            
            // CLEANUP: Dispose old texture
            if (window.currentVideoTexture) {
                console.log('üßπ Disposing old texture...');
                window.currentVideoTexture.dispose();
                window.currentVideoTexture = null;
            }
            
            const [handle] = await window.showOpenFilePicker({
                types: [{ description: 'Videos', accept: { 'video/*': ['.mp4', '.mov', '.webm'] } }]
            });
            
            const file = await handle.getFile();
            console.log('‚úì File:', file.name);
            
            const video = document.createElement('video');
            video.src = URL.createObjectURL(file);
            video.loop = video.muted = video.playsInline = true;
            document.body.appendChild(video);
            video.style.display = 'none';
            
            // Store reference for cleanup next time
            window.currentVideoElement = video;
            
            video.onloadedmetadata = async () => {
                console.log('Video metadata loaded:', video.videoWidth, 'x', video.videoHeight);
                
                const tex = new THREE.VideoTexture(video);
                tex.minFilter = THREE.LinearFilter;
                tex.magFilter = THREE.LinearFilter;
                
                // Store texture reference for cleanup
                window.currentVideoTexture = tex;
                
                // Show media controls
                const mediaControls = document.getElementById('media-controls');
                if (mediaControls) mediaControls.style.display = 'block';
                
                // Setup timeline update
                if (!window.timelineUpdateInterval) {
                    window.timelineUpdateInterval = setInterval(updateMediaTimeline, 100);
                }
                
                console.log('VideoTexture created, trying to play...');
                await video.play();
                console.log('‚úì Video playing, currentTime:', video.currentTime);
                
                console.log('Applying texture to projector...');
                console.log('Active projector:', activeProjector);
                console.log('Projected objects count:', projectedObjects.length);
                
                // Apply to active projector
                if (activeProjector) {
                    activeProjector.projectionTexture = tex;
                    console.log('‚úì Applied to active projector');
                }
                projectionTexture = tex;
                console.log('‚úì Set global projectionTexture');
                
                // Update ALL objects
                let updatedCount = 0;
                projectedObjects.forEach((obj, idx) => {
                    console.log(`Object ${idx}:`, obj.userData?.name || 'unnamed', 'has uniforms:', !!obj.material?.uniforms);
                    if (obj.material?.uniforms) {
                        for (let i = 0; i < 4; i++) {
                            if (obj.material.uniforms[`projTexture${i}`]) {
                                obj.material.uniforms[`projTexture${i}`].value = tex;
                                obj.material.uniforms[`hasTexture${i}`].value = true;
                                updatedCount++;
                                console.log(`  ‚Üí Updated projTexture${i}`);
                            }
                        }
                        obj.material.needsUpdate = true;
                    }
                });
                console.log(`‚úì Updated ${updatedCount} texture uniforms`);
                
                // Force projection matrix update
                console.log('Calling updateProjectionMatrix...');
                updateProjectionMatrix();
                
                // Double-check: update again after a frame
                setTimeout(() => {
                    console.log('Second update pass...');
                    projectedObjects.forEach(obj => {
                        if (obj.material) {
                            obj.material.needsUpdate = true;
                        }
                    });
                    updateProjectionMatrix();
                    console.log('Second update complete');
                }, 100);
                
                document.getElementById('image-status').innerHTML = '<div style="color:#0d9488; font-size:10px;">‚úì Playing!</div>';
                console.log('‚úÖ Video ready!');
            };
        } catch (e) {
            console.error('Modern picker error:', e);
        }
    };
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MEDIA PLAYER CONTROLS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    window.mediaPlay = function() {
        if (window.currentVideoElement) {
            window.currentVideoElement.play();
            console.log('‚ñ∂Ô∏è Play');
        }
    };
    
    window.mediaPause = function() {
        if (window.currentVideoElement) {
            window.currentVideoElement.pause();
            console.log('‚è∏Ô∏è Pause');
        }
    };
    
    window.mediaStop = function() {
        if (window.currentVideoElement) {
            window.currentVideoElement.pause();
            window.currentVideoElement.currentTime = 0;
            console.log('‚èπÔ∏è Stop');
        }
    };
    
    window.mediaSeek = function(percentage) {
        if (window.currentVideoElement && window.currentVideoElement.duration) {
            const time = (percentage / 100) * window.currentVideoElement.duration;
            window.currentVideoElement.currentTime = time;
        }
    };
    
    window.mediaVolume = function(volume) {
        if (window.currentVideoElement) {
            window.currentVideoElement.volume = volume / 100;
            window.currentVideoElement.muted = (volume === 0);
        }
    };
    
    window.mediaSpeed = function(speed) {
        if (window.currentVideoElement) {
            window.currentVideoElement.playbackRate = speed;
            console.log('Speed:', speed + 'x');
        }
    };
    
    window.updateMediaTimeline = function() {
        const video = window.currentVideoElement;
        if (!video) return;
        
        // Update seek bar
        const seekBar = document.getElementById('seek-bar');
        if (seekBar && video.duration) {
            const percentage = (video.currentTime / video.duration) * 100;
            seekBar.value = percentage;
        }
        
        // Update time display
        const formatTime = (seconds) => {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        };
        
        const timeCurrent = document.getElementById('time-current');
        const timeTotal = document.getElementById('time-total');
        
        if (timeCurrent) timeCurrent.textContent = formatTime(video.currentTime);
        if (timeTotal && video.duration) timeTotal.textContent = formatTime(video.duration);
    };
    
    // Load video from external URL (works in Claude.ai)
    window.loadVideoFromURL = function() {
        const input = document.getElementById('video-url-input');
        const url = input?.value?.trim();
        
        if (!url) {
            alert('Please enter a video URL');
            return;
        }
        
        if (!url.startsWith('http://') && !url.startsWith('https://')) {
            alert('URL must start with http:// or https://');
            return;
        }
        
        console.log('üé¨ Loading video from URL:', url);
        
        const status = document.getElementById('image-status');
        if (status) status.innerHTML = '<div style="color:#888; font-size:10px;">‚è≥ Loading video from URL...</div>';
        
        // Create video element
        const video = document.createElement('video');
        video.src = url;
        video.loop = true;
        video.muted = true;
        video.playsInline = true;
        video.crossOrigin = 'anonymous';
        
        video.onloadeddata = () => {
            console.log('‚úì Video loaded from URL, dimensions:', video.videoWidth, 'x', video.videoHeight);
            
            // Create video texture
            const videoTex = new THREE.VideoTexture(video);
            videoTex.minFilter = THREE.LinearFilter;
            videoTex.magFilter = THREE.LinearFilter;
            videoTex.format = THREE.RGBAFormat;
            videoTex.anisotropy = renderer.capabilities.getMaxAnisotropy ? renderer.capabilities.getMaxAnisotropy() : 1;
            
            // Start playing
            video.play().then(() => {
                console.log('‚úì Video playing from URL');
                
                // Apply to active projector
                if (activeProjector) {
                    activeProjector.projectionTexture = videoTex;
                    console.log('‚úì Video applied to active projector');
                }
                
                // Update global
                projectionTexture = videoTex;
                
                // Update all objects
                projectedObjects.forEach(obj => {
                    if (obj.material?.uniforms) {
                        for (let i = 0; i < 4; i++) {
                            if (obj.material.uniforms[`projTexture${i}`]) {
                                obj.material.uniforms[`projTexture${i}`].value = videoTex;
                                obj.material.uniforms[`hasTexture${i}`].value = true;
                            }
                        }
                        obj.material.needsUpdate = true;
                    }
                });
                
                updateProjectionMatrix();
                
                if (status) status.innerHTML = '<div style="color:#0d9488; font-size:10px;">‚úì Video loaded from URL</div>';
            }).catch(err => {
                console.error('‚úó Error playing video:', err);
                if (status) status.innerHTML = '<div style="color:#f87171; font-size:10px;">‚úó Cannot play video</div>';
            });
        };
        
        video.onerror = (err) => {
            console.error('‚úó Error loading video from URL:', err);
            if (status) status.innerHTML = '<div style="color:#f87171; font-size:10px;">‚úó Cannot load video (CORS?)</div>';
        };
    };

    // Generate preset textures programmatically
    
    // Auto-load UV Grid for new projectors (for easy calibration)
    function loadUVGridForProjector(projector) {
        const canvas = document.createElement('canvas');
        const size = 2048;
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        
        // Generate UV Grid (same as preset)
        const gridSize = 8;
        const cellW = size / gridSize;
        const cellH = size / gridSize;
        
        for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
                // Color based on UV position
                const r = Math.floor((x / gridSize) * 255);
                const g = Math.floor((y / gridSize) * 255);
                const b = 128;
                ctx.fillStyle = `rgb(${r},${g},${b})`;
                ctx.fillRect(x * cellW, y * cellH, cellW, cellH);
                
                // Grid lines
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 2;
                ctx.strokeRect(x * cellW, y * cellH, cellW, cellH);
                
                // UV coordinates text
                ctx.fillStyle = 'white';
                ctx.font = '24px monospace';
                ctx.textAlign = 'center';
                const u = (x / gridSize).toFixed(1);
                const v = (1 - y / gridSize).toFixed(1);
                ctx.fillText(`${u},${v}`, x * cellW + cellW/2, y * cellH + cellH/2);
            }
        }
        
        // Create texture from canvas
        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.anisotropy = renderer.capabilities.getMaxAnisotropy ? renderer.capabilities.getMaxAnisotropy() : 1;
        
        // Apply to this projector only
        projector.projectionTexture = texture;
        
        // Update shader uniforms for all objects
        updateProjectionMatrix();
        
        console.log('‚úÖ UV Grid auto-loaded for projector', projector.id);
    }
    
    window.loadPresetTexture = function() {
        const select = document.getElementById('preset-texture');
        const preset = select ? select.value : '';
        if (!preset) return;
        
        // Load UV Grid Full HD from file
        if (preset === 'uv-grid-full') {
            new THREE.TextureLoader().load('/mnt/user-data/uploads/UV_Grid_FullHD_1920x1080.png',
                tex => {
                    tex.minFilter = THREE.LinearFilter;
                    tex.anisotropy = renderer.capabilities.getMaxAnisotropy ? renderer.capabilities.getMaxAnisotropy() : 1;
                    
                    // Update global and ALL projectors with the texture
                    projectionTexture = tex;
                    projectors.forEach(proj => {
                        proj.projectionTexture = tex;
                    });
                    
                    let updatedCount = 0;
                    projectedObjects.forEach(obj => {
                        if (obj.material?.uniforms) {
                            for (let i = 0; i < 4; i++) {
                                if (obj.material.uniforms[`projTexture${i}`]) {
                                    obj.material.uniforms[`projTexture${i}`].value = tex;
                                    obj.material.uniforms[`hasTexture${i}`].value = true;
                                }
                            }
                            obj.material.needsUpdate = true;
                            updatedCount++;
                        }
                    });
                    
                    updateProjectionMatrix();
                    const status = document.getElementById('image-status');
                    if (status) status.innerHTML = '<div class="status success">‚úì UV Grid Full HD (tous les projecteurs)</div>';
                    
                    // Clear file input
                    const fileInput = document.getElementById('image-upload');
                    if (fileInput) fileInput.value = '';
                },
                undefined,
                err => {
                    const status = document.getElementById('image-status');
                    if (status) status.innerHTML = '<div class="status info">‚úó Erreur chargement UV Grid</div>';
                }
            );
            return;
        }
        
        const canvas = document.createElement('canvas');
        const size = 512;
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        
        switch(preset) {
            case 'uv-grid':
                // Generate UV Grid test pattern
                const gridSize = 8;
                const cellW = size / gridSize;
                const cellH = size / gridSize;
                
                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        // Color based on UV position
                        const r = Math.floor((x / gridSize) * 255);
                        const g = Math.floor((y / gridSize) * 255);
                        const b = 128;
                        ctx.fillStyle = `rgb(${r},${g},${b})`;
                        ctx.fillRect(x * cellW, y * cellH, cellW, cellH);
                        
                        // Grid lines
                        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x * cellW, y * cellH, cellW, cellH);
                        
                        // UV coordinates text
                        ctx.fillStyle = 'white';
                        ctx.font = '10px monospace';
                        ctx.textAlign = 'center';
                        const u = (x / gridSize).toFixed(1);
                        const v = (y / gridSize).toFixed(1);
                        ctx.fillText(`${u},${v}`, x * cellW + cellW/2, y * cellH + cellH/2 + 4);
                    }
                }
                
                // Border frame
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 4;
                ctx.strokeRect(2, 2, size-4, size-4);
                
                // Corner markers
                ctx.fillStyle = 'red';
                ctx.fillRect(0, 0, 20, 20);
                ctx.fillStyle = 'green';
                ctx.fillRect(size-20, 0, 20, 20);
                ctx.fillStyle = 'blue';
                ctx.fillRect(0, size-20, 20, 20);
                ctx.fillStyle = 'yellow';
                ctx.fillRect(size-20, size-20, 20, 20);
                
                // Center cross
                ctx.strokeStyle = 'cyan';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(size/2 - 30, size/2);
                ctx.lineTo(size/2 + 30, size/2);
                ctx.moveTo(size/2, size/2 - 30);
                ctx.lineTo(size/2, size/2 + 30);
                ctx.stroke();
                break;
                
            case 'white':
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, size, size);
                break;
                
            case 'checkerboard':
                const checkSize = 32;
                for (let y = 0; y < size; y += checkSize) {
                    for (let x = 0; x < size; x += checkSize) {
                        const isWhite = ((x / checkSize) + (y / checkSize)) % 2 === 0;
                        ctx.fillStyle = isWhite ? 'white' : 'black';
                        ctx.fillRect(x, y, checkSize, checkSize);
                    }
                }
                break;
                
            case 'gradient':
                const gradH = ctx.createLinearGradient(0, 0, size, 0);
                gradH.addColorStop(0, 'red');
                gradH.addColorStop(0.5, 'green');
                gradH.addColorStop(1, 'blue');
                ctx.fillStyle = gradH;
                ctx.fillRect(0, 0, size, size/2);
                
                const gradV = ctx.createLinearGradient(0, size/2, 0, size);
                gradV.addColorStop(0, 'black');
                gradV.addColorStop(1, 'white');
                ctx.fillStyle = gradV;
                ctx.fillRect(0, size/2, size, size/2);
                break;
        }
        
        // Create texture from canvas
        const tex = new THREE.CanvasTexture(canvas);
        tex.minFilter = THREE.LinearFilter;
        tex.magFilter = THREE.LinearFilter;
        tex.anisotropy = renderer.capabilities.getMaxAnisotropy ? renderer.capabilities.getMaxAnisotropy() : 1;
        
        projectionTexture = tex;
        
        // Update ALL projectors with the texture
        projectors.forEach(proj => {
            proj.projectionTexture = tex;
        });
        
        let updatedCount = 0;
        projectedObjects.forEach(obj => {
            if (obj.material?.uniforms) {
                // Update all 4 projector slots
                for (let i = 0; i < 4; i++) {
                    if (obj.material.uniforms[`projTexture${i}`]) {
                        obj.material.uniforms[`projTexture${i}`].value = tex;
                        obj.material.uniforms[`hasTexture${i}`].value = true;
                    }
                }
                obj.material.needsUpdate = true;
                updatedCount++;
            }
        });
        
        updateProjectionMatrix();
        const status = document.getElementById('image-status');
        if (status) status.innerHTML = '<div class="status success">‚úì ' + preset + ' (tous les projecteurs)</div>';
        
        // Clear file input
        const fileInput = document.getElementById('image-upload');
        if (fileInput) fileInput.value = '';
    };


    window.removeImage = function() {
        projectionTexture = null;
        
        // Remove texture from ALL projectors
        projectors.forEach(proj => {
            proj.projectionTexture = null;
        });
        
        projectedObjects.forEach(obj => {
            if (obj.material?.uniforms) {
                // Update all 4 projector slots
                for (let i = 0; i < 4; i++) {
                    if (obj.material.uniforms[`projTexture${i}`]) {
                        obj.material.uniforms[`projTexture${i}`].value = null;
                        obj.material.uniforms[`hasTexture${i}`].value = false;
                    }
                }
                obj.material.needsUpdate = true;
            }
        });
        updateProjectionMatrix();
        const upload = document.getElementById('image-upload');
        if (upload) upload.value = '';
        const status = document.getElementById('image-status');
        if (status) status.innerHTML = '<div class="status info">Enlev√©</div>';
    };

    // ========== 3D MODEL LOADER FUNCTIONS ==========
    
    window.openModelLoader = function() {
        document.getElementById('model-loader-modal').classList.add('show');
        initModelPreview();
    };
    
    window.closeModelLoader = function() {
        document.getElementById('model-loader-modal').classList.remove('show');
        cleanupModelPreview();
        pendingModel = null;
        document.getElementById('model-file-input').value = '';
        document.getElementById('model-load-status').textContent = '';
    };
    
    function initModelPreview() {
        const viewport = document.getElementById('model-preview-viewport');
        viewport.innerHTML = '';
        
        modelPreviewScene = new THREE.Scene();
        modelPreviewScene.background = new THREE.Color(0x1a1a1a);
        
        modelPreviewCamera = new THREE.PerspectiveCamera(60, viewport.clientWidth / viewport.clientHeight, 0.1, 1000);
        modelPreviewCamera.position.set(3, 3, 3);
        modelPreviewCamera.lookAt(0, 0, 0);
        
        modelPreviewRenderer = new THREE.WebGLRenderer({ antialias: true });
        modelPreviewRenderer.setSize(viewport.clientWidth, viewport.clientHeight);
        viewport.appendChild(modelPreviewRenderer.domElement);
        
        modelPreviewControls = new THREE.OrbitControls(modelPreviewCamera, modelPreviewRenderer.domElement);
        modelPreviewControls.enableDamping = true;
        modelPreviewControls.dampingFactor = 0.05;
        
        // Lighting
        modelPreviewScene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const light = new THREE.DirectionalLight(0xffffff, 0.8);
        light.position.set(5, 10, 5);
        modelPreviewScene.add(light);
        
        // Grid and axes
        modelPreviewScene.add(new THREE.GridHelper(10, 10, 0x444444, 0x222222));
        modelPreviewScene.add(new THREE.AxesHelper(2));
        
        // Animation loop for preview
        function animatePreview() {
            if (!modelPreviewRenderer) return;
            requestAnimationFrame(animatePreview);
            if (modelPreviewControls) modelPreviewControls.update();
            if (modelPreviewRenderer && modelPreviewScene && modelPreviewCamera) {
                modelPreviewRenderer.render(modelPreviewScene, modelPreviewCamera);
            }
        }
        animatePreview();
    }
    
    function cleanupModelPreview() {
        if (modelPreviewRenderer) {
            modelPreviewRenderer.dispose();
            modelPreviewRenderer = null;
        }
        modelPreviewScene = null;
        modelPreviewCamera = null;
        modelPreviewControls = null;
    }
    
    window.handleModelFileSelect = async function(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        const ext = file.name.split('.').pop().toLowerCase();
        if (!['glb', 'gltf', 'obj', 'fbx'].includes(ext)) {
            document.getElementById('model-load-status').innerHTML = '<span style="color:#dc2626;">Format non support√©</span>';
            return;
        }
        
        document.getElementById('model-load-status').innerHTML = '<span style="color:#0d9488;">Chargement...</span>';
        
        try {
            const buffer = await file.arrayBuffer();
            const model = await parseModel(buffer, ext, file.name);
            
            // Wrap in group
            const wrapper = new THREE.Group();
            wrapper.name = file.name;
            wrapper.userData.fileName = file.name;
            wrapper.add(model);
            
            pendingModel = wrapper;
            
            // Add to preview scene
            if (modelPreviewScene) {
                // Remove any existing preview model
                const existing = modelPreviewScene.getObjectByName('preview-model');
                if (existing) modelPreviewScene.remove(existing);
                
                wrapper.name = 'preview-model';
                modelPreviewScene.add(wrapper);
                
                // Auto-fit camera
                const box = new THREE.Box3().setFromObject(wrapper);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                
                // Center the model
                wrapper.position.sub(center);
                
                // Adjust camera distance
                modelPreviewCamera.position.set(maxDim * 1.5, maxDim * 1.5, maxDim * 1.5);
                modelPreviewCamera.lookAt(0, 0, 0);
                modelPreviewControls.target.set(0, 0, 0);
            }
            
            document.getElementById('model-load-status').innerHTML = '<span style="color:#16a34a;">‚úì ' + file.name + '</span>';
        } catch (err) {
            console.error('Model load error:', err);
            document.getElementById('model-load-status').innerHTML = '<span style="color:#dc2626;">Erreur: ' + err.message + '</span>';
        }
    };
    
    async function parseModel(buffer, format, filename) {
        return new Promise((resolve, reject) => {
            if (format === 'glb' || format === 'gltf') {
                const loader = new THREE.GLTFLoader();
                loader.parse(buffer, '', (gltf) => {
                    gltf.scene.traverse(child => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            // CRITICAL: Convert materials to react to lights
                            if (child.material) {
                                const oldMat = child.material;
                                
                                // If material doesn't react to lights, convert it
                                if (oldMat.type === 'MeshBasicMaterial' || !oldMat.isMeshStandardMaterial) {
                                    const newMat = new THREE.MeshStandardMaterial({
                                        color: oldMat.color || 0xffffff,
                                        map: oldMat.map || null,
                                        roughness: 0.7,
                                        metalness: 0.1
                                    });
                                    child.material = newMat;
                                    console.log('‚úÖ Converted', child.name || 'mesh', 'to MeshStandardMaterial');
                                }
                            }
                        }
                    });
                    resolve(gltf.scene);
                }, reject);
            } else if (format === 'obj') {
                const loader = new THREE.OBJLoader();
                const text = new TextDecoder().decode(buffer);
                try {
                    const obj = loader.parse(text);
                    obj.traverse(child => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            // CRITICAL: Convert materials to react to lights
                            if (child.material) {
                                const oldMat = child.material;
                                const newMat = new THREE.MeshStandardMaterial({
                                    color: oldMat.color || 0xcccccc,
                                    map: oldMat.map || null,
                                    roughness: 0.7,
                                    metalness: 0.1
                                });
                                child.material = newMat;
                                console.log('‚úÖ Converted OBJ material to MeshStandardMaterial');
                            }
                        }
                    });
                    resolve(obj);
                } catch (err) {
                    reject(err);
                }
            } else if (format === 'fbx') {
                const loader = new THREE.FBXLoader();
                try {
                    const fbx = loader.parse(buffer, '');
                    fbx.traverse(child => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            // CRITICAL: Convert materials to react to lights
                            if (child.material) {
                                const oldMat = child.material;
                                const newMat = new THREE.MeshStandardMaterial({
                                    color: oldMat.color || 0xcccccc,
                                    map: oldMat.map || null,
                                    roughness: 0.7,
                                    metalness: 0.1
                                });
                                child.material = newMat;
                                console.log('‚úÖ Converted FBX material to MeshStandardMaterial');
                            }
                        }
                    });
                    resolve(fbx);
                } catch (err) {
                    reject(err);
                }
            } else {
                reject(new Error('Format non support√©'));
            }
        });
    }
    
    window.pickAxisOption = function(el) {
        selectedAxis = el.dataset.axis;
        document.querySelectorAll('#axis-options .axis-option').forEach(a => a.classList.remove('selected'));
        el.classList.add('selected');
    };
    
    window.pickPivotOption = function(el) {
        selectedPivot = el.dataset.pivot;
        document.querySelectorAll('.pivot-btn').forEach(p => p.classList.remove('active'));
        el.classList.add('active');
    };
    
    window.rotatePreviewModel = function(axis, degrees) {
        if (!pendingModel) return;
        const rad = THREE.MathUtils.degToRad(degrees);
        if (axis === 'x') pendingModel.rotation.x += rad;
        if (axis === 'y') pendingModel.rotation.y += rad;
        if (axis === 'z') pendingModel.rotation.z += rad;
    };
    
    window.confirmModelLoad = function() {
        if (!pendingModel) {
            alert('Veuillez d\'abord charger un fichier 3D');
            return;
        }
        
        // Clone the pending model for the main scene
        const modelClone = pendingModel.clone(true);
        
        // Apply axis correction if needed
        if (selectedAxis === 'x') {
            modelClone.rotateZ(THREE.MathUtils.degToRad(90));
        }
        
        // Calculate bounding box
        const bbox = new THREE.Box3().setFromObject(modelClone);
        const center = bbox.getCenter(new THREE.Vector3());
        const min = bbox.min.clone();
        const size = bbox.getSize(new THREE.Vector3());
        
        // Apply pivot positioning
        if (selectedPivot === 'floor') {
            // Center X/Z, bottom on Y=0
            modelClone.position.set(-center.x, -min.y, -center.z);
        } else if (selectedPivot === 'center') {
            // Full center
            modelClone.position.set(-center.x, -center.y, -center.z);
        }
        // 'origin' keeps original position
        
        // Auto-scale if enabled (disabled by default for real-size models)
        if (document.getElementById('model-auto-scale').checked) {
            const maxDim = Math.max(size.x, size.y, size.z);
            if (maxDim > 50) {
                const scaleFactor = 50 / maxDim;
                modelClone.scale.setScalar(scaleFactor);
            }
        }
        
        // Create a group pivot for the model
        const pivotGroup = new THREE.Group();
        pivotGroup.name = pendingModel.userData.fileName || 'Imported Model';
        pivotGroup.add(modelClone);
        
        // Position in front of projector
        pivotGroup.position.set(0, 0, -5);
        
        // Apply projection material to all meshes and add them to projectedObjects
        const meshChildren = [];
        const addWireframe = document.getElementById('model-wireframe').checked;
        
        pivotGroup.traverse(child => {
            if (child.isMesh) {
                const projMat = createProjectedMaterial();
                
                // Always use a visible default gray color for loaded models
                projMat.uniforms.baseColor.value.setRGB(0.7, 0.7, 0.7);
                
                // Try to preserve original color if it exists and is bright enough
                if (child.material) {
                    // Handle array of materials
                    const mat = Array.isArray(child.material) ? child.material[0] : child.material;
                    if (mat && mat.color && mat.color.r !== undefined) {
                        const brightness = Math.max(mat.color.r, mat.color.g, mat.color.b);
                        if (brightness > 0.2) {
                            projMat.uniforms.baseColor.value.copy(mat.color);
                        }
                    }
                }
                
                child.material = projMat;
                child.castShadow = document.getElementById('model-cast-shadows').checked;
                child.receiveShadow = true;
                meshChildren.push(child);
                
                // Add Gouraud shading wireframe overlay if enabled
                if (addWireframe) {
                    const edges = new THREE.EdgesGeometry(child.geometry, 30);
                    const lineMat = new THREE.LineBasicMaterial({ 
                        color: 0xffffff, 
                        transparent: true, 
                        opacity: 0.3 
                    });
                    const wireframe = new THREE.LineSegments(edges, lineMat);
                    wireframe.userData.isWireframe = true;
                    wireframe.userData.noProjection = true;
                    child.add(wireframe);
                }
            }
        });
        
        // Add to scene
        scene.add(pivotGroup);
        
        // Add each mesh child to projectedObjects so they receive projection uniforms
        meshChildren.forEach(mesh => {
            projectedObjects.push(mesh);
        });
        
        selectableObjects.push(pivotGroup);
        
        // Select the newly added model
        selectObject(pivotGroup);
        pivotGroup.userData = { name: pendingModel.userData.fileName || 'Mod√®le 3D', type: 'object' };
        
        // Record for undo
        pushHistory({
            type: 'create_object',
            object: pivotGroup,
            objectType: 'model'
        });
        
        updateProjectionMatrix();
        
        // Update target selector dropdown
        
        
        closeModelLoader();
    };

    function onTransformChange() {
        if (transformControls.object === targetMesh) {
            userMovedTarget = true;
            
            // Set userMovedTarget on active projector for lock to work
            if (activeProjector) {
                activeProjector.userMovedTarget = true;
            }
            
            // If projector is locked to target, move projector with target
            if (activeProjector && activeProjector.projectorLockedToTarget) {
                const targetPos = new THREE.Vector3();
                targetMesh.getWorldPosition(targetPos);
                
                // Calculate offset vector (projector ‚Üí target)
                const offset = new THREE.Vector3().subVectors(
                    targetPos,
                    activeProjector.group.position
                );
                
                // Move projector to maintain same relative position
                activeProjector.group.position.copy(targetPos);
                
                console.log(`üìç Projector #${activeProjector.id} following target to position:`, activeProjector.group.position);
            }
        }
        
        updateProjectionMatrix();
        updateMeasurements();
        
        // Update dummy projectors positions if stack is active
        if (activeProjector && activeProjector.dummyProjectors && activeProjector.dummyProjectors.length > 0) {
            updateStackOffset();
        }
    }

    function onClick(e) {
        // Skip selection if we just finished dragging to prevent deselection
        if (window._justFinishedDragging && window._justFinishedDragging()) {
            return;
        }
        
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        
        // Use recursive raycasting to hit meshes inside groups (imported models)
        const hits = raycaster.intersectObjects(selectableObjects, true);
        
        if (hits.length > 0) {
            // Find the selectable parent (the one in selectableObjects array)
            let hitObj = hits[0].object;
            let selectableParent = null;
            
            // Check if hit object is directly selectable
            if (selectableObjects.includes(hitObj)) {
                selectableParent = hitObj;
            } else {
                // Traverse up to find selectable parent
                let current = hitObj;
                while (current && current.parent) {
                    if (selectableObjects.includes(current)) {
                        selectableParent = current;
                        break;
                    }
                    current = current.parent;
                }
            }
            
            selectObject(selectableParent);
        } else {
            selectObject(null);
        }
    }

    function onRightClick(e) {
        e.preventDefault(); // Prevent browser context menu
        
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        
        // Use recursive raycasting to hit meshes inside groups (imported models)
        const hits = raycaster.intersectObjects(selectableObjects, true);
        
        if (hits.length > 0) {
            // Find the selectable parent
            let hitObj = hits[0].object;
            let selectableParent = null;
            
            if (selectableObjects.includes(hitObj)) {
                selectableParent = hitObj;
            } else {
                let current = hitObj;
                while (current && current.parent) {
                    if (selectableObjects.includes(current)) {
                        selectableParent = current;
                        break;
                    }
                    current = current.parent;
                }
            }
            
            // Only show context menu for non-projector, non-target objects
            if (selectableParent && !selectableParent.userData.isProjector && !selectableParent.userData.isTarget) {
                showContextMenu(e.clientX, e.clientY, selectableParent);
            } else {
                hideContextMenu();
            }
        } else {
            hideContextMenu();
        }
    }

    function selectObject(obj) {
        selectedObject = obj;
        const gizmoControls = document.getElementById('gizmo-controls');
        
        // Show/hide "Set as Target" buttons based on selection
        const setTargetBtn = document.getElementById('set-target-btn'); // Sidebar right
        const setTargetBtnPanel = document.getElementById('set-target-btn-panel'); // Panel left
        
        const canBeTarget = obj && !obj.userData.isProjector && !obj.userData.isTarget;
        
        if (setTargetBtn) {
            setTargetBtn.style.display = canBeTarget ? 'block' : 'none';
        }
        
        if (setTargetBtnPanel) {
            setTargetBtnPanel.disabled = !canBeTarget;
            if (canBeTarget) {
                setTargetBtnPanel.style.opacity = '1';
                setTargetBtnPanel.style.cursor = 'pointer';
            } else {
                setTargetBtnPanel.style.opacity = '0.3';
                setTargetBtnPanel.style.cursor = 'not-allowed';
            }
        }

        if (obj) {
            // Check if selecting a projector or its target - switch active projector
            if (obj.userData.projectorInstance) {
                const instance = obj.userData.projectorInstance;
                if (instance !== activeProjector) {
                    setActiveProjector(instance);
                }
            }
            
            if (obj.userData.isProjector) {
                // Get the projector instance from the object
                const instance = obj.userData.projectorInstance || activeProjector;
                if (instance) {
                    transformControls.attach(instance.group);
                } else {
                    transformControls.attach(projectorGroup);
                }
                transformControls.setSpace('local');
            } else if (obj.userData.isCamera) {
                // Camera - attach to camera group
                const camInstance = obj.userData.cameraInstance;
                if (camInstance) {
                    transformControls.attach(camInstance.group);
                    transformControls.setSpace('local');
                }
            } else if (obj.userData.isTarget) {
                // Target - attach directly
                transformControls.attach(obj);
                transformControls.setSpace('world');
            } else {
                // For imported models (groups), attach to the group, not the mesh
                let attachTarget = obj;
                if (obj.parent && obj.parent.type === 'Group' && selectableObjects.includes(obj.parent)) {
                    attachTarget = obj.parent;
                }
                transformControls.attach(attachTarget);
                transformControls.setSpace('world');
            }
            const selName = document.getElementById('selected-name');
            if (selName) selName.textContent = obj.userData.name || 'Objet 3D';
            gizmoControls?.classList.add('visible');
            updateTransformInputs();
            updatePropertiesPanel(); // Update modern interface properties
        } else {
            transformControls.detach();
            const selName = document.getElementById('selected-name');
            if (selName) selName.textContent = 'Aucun';
            gizmoControls?.classList.remove('visible');
            updatePropertiesPanel(); // Update modern interface properties
        }
    }

    // ========== ADVANCED TIMELINE SYSTEM (Layer-based) ==========
    
    let timeline = {
        duration: 30, // seconds
        currentTime: 0,
        playing: false,
        fps: 30,
        layers: [] // { object, name, keyframes: [], visible: true, locked: false }
    };
    
    let timelineAnimationFrame = null;
    
    // Add object to timeline as layer
    window.addToTimeline = function(obj) {
        if (!obj) return;
        
        // Ensure object has a name
        if (!obj.userData) obj.userData = {};
        if (!obj.userData.name) {
            obj.userData.name = `Object_${Date.now()}`;
        }
        
        // Check if already exists
        const existing = timeline.layers.find(l => l.object === obj);
        if (existing) {
            console.log(`‚ö†Ô∏è ${obj.userData.name} already in timeline`);
            return;
        }
        
        const layer = {
            id: Date.now(),
            object: obj,
            name: obj.userData.name,
            keyframes: [],
            visible: true,
            locked: false,
            color: getRandomColor()
        };
        
        timeline.layers.push(layer);
        updateTimelineUI();
        console.log(`üìä Added layer: ${layer.name}`);
    };
    
    // Remove layer
    window.removeLayer = function(layerId) {
        timeline.layers = timeline.layers.filter(l => l.id !== layerId);
        updateTimelineUI();
    };
    
    // Quick add keyframe (K hotkey)
    window.addKeyframeQuick = function() {
        if (!selectedObject) {
            console.log('‚ö†Ô∏è No object selected');
            return;
        }
        
        // Handle special cases
        let targetObject = selectedObject;
        let propertyToAnimate = 'position';
        
        // If projector, animate the group (which contains camera)
        if (selectedObject.userData.isProjector) {
            const instance = selectedObject.userData.projectorInstance || activeProjector;
            if (instance && instance.group) {
                targetObject = instance.group;
                console.log('üìΩÔ∏è Animating projector group');
            }
        }
        // If camera, animate the group
        else if (selectedObject.userData.isCamera) {
            const instance = selectedObject.userData.cameraInstance;
            if (instance && instance.group) {
                targetObject = instance.group;
                console.log('üì∑ Animating camera group');
            }
        }
        
        // Ensure target has name
        if (!targetObject.userData) targetObject.userData = {};
        if (!targetObject.userData.name) {
            targetObject.userData.name = selectedObject.userData.name || `Object_${Date.now()}`;
        }
        
        // Add to timeline if not already
        addToTimeline(targetObject);
        
        // Add keyframe for position
        addKeyframe(targetObject, propertyToAnimate);
        console.log('‚ö° Quick keyframe added (K)');
    };
    
    // Create keyframe with easing
    window.addKeyframe = function(obj, property, time = null, easingOverride = null) {
        if (!obj) {
            console.log('‚ùå addKeyframe: no object');
            return;
        }
        
        console.log('üîß addKeyframe called:', {
            obj: obj.userData?.name || 'unnamed',
            property,
            time: time !== null ? time : timeline.currentTime
        });
        
        // Ensure object is in timeline
        let layer = timeline.layers.find(l => l.object === obj);
        if (!layer) {
            console.log('üìä Creating layer for object...');
            addToTimeline(obj);
            layer = timeline.layers.find(l => l.object === obj);
        }
        
        if (!layer) {
            console.log('‚ùå Failed to create layer!');
            return;
        }
        
        console.log('‚úÖ Layer found:', layer.name, 'keyframes:', layer.keyframes.length);
        
        const t = time !== null ? time : timeline.currentTime;
        
        // Get easing from dropdown or use override
        const easingSelect = document.getElementById('easing-select');
        const easing = easingOverride || (easingSelect ? easingSelect.value : 'easeInOutQuad');
        
        // Get current value
        let value;
        if (property === 'position') {
            value = obj.position.clone();
        } else if (property === 'rotation') {
            value = obj.rotation.clone();
        } else if (property === 'scale') {
            value = obj.scale.clone();
        }
        
        console.log('üìç Value:', property, value);
        
        // Check if keyframe exists at this time
        const existing = layer.keyframes.findIndex(
            kf => kf.property === property && Math.abs(kf.time - t) < 0.01
        );
        
        if (existing >= 0) {
            // Update existing
            layer.keyframes[existing].value = value;
            layer.keyframes[existing].easing = easing;
            console.log(`üîÑ Updated keyframe: ${property} at ${t.toFixed(2)}s`);
        } else {
            // Add new
            layer.keyframes.push({
                time: t,
                property: property,
                value: value,
                easing: easing
            });
            layer.keyframes.sort((a, b) => a.time - b.time);
            console.log(`‚úÖ Added keyframe: ${property} at ${t.toFixed(2)}s (${easing})`);
            console.log(`üìä Total keyframes in layer: ${layer.keyframes.length}`);
        }
        
        updateTimelineUI();
    };
    
    // Easing functions
    const easingFunctions = {
        linear: t => t,
        easeInQuad: t => t * t,
        easeOutQuad: t => t * (2 - t),
        easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
        easeInCubic: t => t * t * t,
        easeOutCubic: t => (--t) * t * t + 1,
        easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1
    };
    
    // Play timeline
    window.playTimeline = function() {
        if (timeline.playing) return;
        
        timeline.playing = true;
        const startTime = performance.now();
        const startTimelineTime = timeline.currentTime;
        
        function animate() {
            if (!timeline.playing) return;
            
            const elapsed = (performance.now() - startTime) / 1000;
            timeline.currentTime = startTimelineTime + elapsed;
            
            if (timeline.currentTime >= timeline.duration) {
                timeline.currentTime = 0;
                timeline.playing = false;
                updateTimelineUI();
                return;
            }
            
            applyKeyframesAtTime(timeline.currentTime);
            updateTimelineUI();
            
            timelineAnimationFrame = requestAnimationFrame(animate);
        }
        
        animate();
        console.log('‚ñ∂Ô∏è Playing timeline');
    };
    
    // Pause timeline
    window.pauseTimeline = function() {
        timeline.playing = false;
        if (timelineAnimationFrame) {
            cancelAnimationFrame(timelineAnimationFrame);
        }
        console.log('‚è∏Ô∏è Paused timeline');
    };
    
    // Stop timeline (reset to 0)
    window.stopTimeline = function() {
        pauseTimeline();
        timeline.currentTime = 0;
        applyKeyframesAtTime(0);
        updateTimelineUI();
        console.log('‚èπÔ∏è Stopped timeline');
    };
    
    // Seek to time
    window.seekTimeline = function(time) {
        timeline.currentTime = Math.max(0, Math.min(time, timeline.duration));
        applyKeyframesAtTime(timeline.currentTime);
        updateTimelineUI();
    };
    
    // Apply keyframes at specific time with easing
    function applyKeyframesAtTime(time) {
        timeline.layers.forEach(layer => {
            if (!layer.visible || layer.locked) return;
            
            // Group keyframes by property
            const byProperty = {};
            layer.keyframes.forEach(kf => {
                if (!byProperty[kf.property]) byProperty[kf.property] = [];
                byProperty[kf.property].push(kf);
            });
            
            // Apply each property
            Object.keys(byProperty).forEach(property => {
                const keyframes = byProperty[property];
                const obj = layer.object;
                
                // Find surrounding keyframes
                let before = null;
                let after = null;
                
                for (let i = 0; i < keyframes.length; i++) {
                    if (keyframes[i].time <= time) {
                        before = keyframes[i];
                    }
                    if (keyframes[i].time >= time && !after) {
                        after = keyframes[i];
                        break;
                    }
                }
                
                // Interpolate with easing
                if (before && after && before !== after) {
                    const duration = after.time - before.time;
                    const elapsed = time - before.time;
                    const linearT = elapsed / duration;
                    
                    // Apply easing function
                    const easingFunc = easingFunctions[before.easing] || easingFunctions.linear;
                    const t = easingFunc(linearT);
                    
                    if (property === 'position') {
                        obj.position.lerpVectors(before.value, after.value, t);
                    } else if (property === 'rotation') {
                        obj.rotation.x = THREE.MathUtils.lerp(before.value.x, after.value.x, t);
                        obj.rotation.y = THREE.MathUtils.lerp(before.value.y, after.value.y, t);
                        obj.rotation.z = THREE.MathUtils.lerp(before.value.z, after.value.z, t);
                    } else if (property === 'scale') {
                        obj.scale.lerpVectors(before.value, after.value, t);
                    }
                } else if (before) {
                    // Use exact keyframe
                    if (property === 'position') {
                        obj.position.copy(before.value);
                    } else if (property === 'rotation') {
                        obj.rotation.copy(before.value);
                    } else if (property === 'scale') {
                        obj.scale.copy(before.value);
                    }
                }
                
                obj.updateMatrixWorld(true);
            });
        });
    }
    
    // Update timeline UI (full rebuild)
    function updateTimelineUI() {
        const timeDisplay = document.getElementById('timeline-time');
        const progressBar = document.getElementById('timeline-progress');
        const playBtn = document.getElementById('timeline-play-btn');
        const layersContainer = document.getElementById('timeline-layers');
        
        if (timeDisplay) {
            timeDisplay.textContent = `${timeline.currentTime.toFixed(2)}s / ${timeline.duration}s`;
        }
        
        if (progressBar) {
            const percent = (timeline.currentTime / timeline.duration) * 100;
            progressBar.style.width = percent + '%';
        }
        
        if (playBtn) {
            playBtn.textContent = timeline.playing ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è';
        }
        
        // Update playhead position and tooltip
        const playhead = document.getElementById('timeline-playhead');
        const playheadTime = document.getElementById('playhead-time');
        if (playhead) {
            const percent = (timeline.currentTime / timeline.duration) * 100;
            playhead.style.left = percent + '%';
            
            if (playheadTime) {
                playheadTime.textContent = timeline.currentTime.toFixed(2) + 's';
            }
        }
        
        // Generate timeline ticks (once)
        const ticksContainer = document.getElementById('timeline-ticks');
        if (ticksContainer && ticksContainer.children.length === 0) {
            for (let i = 0; i <= timeline.duration; i++) {
                if (i % 5 !== 0) { // Skip main markers
                    const tick = document.createElement('div');
                    tick.style.cssText = `
                        position: absolute;
                        left: ${(i / timeline.duration) * 100}%;
                        top: 0;
                        width: 1px;
                        height: ${i % 1 === 0 ? '50%' : '25%'};
                        background: rgba(255,255,255,${i % 1 === 0 ? '0.15' : '0.05'});
                    `;
                    ticksContainer.appendChild(tick);
                }
            }
        }
        
        // Rebuild layers list
        if (layersContainer) {
            // DEBUG: Check if layers exist
            console.log('üîÑ Rebuilding UI - Layers count:', timeline.layers.length);
            
            layersContainer.innerHTML = '';
            
            if (timeline.layers.length === 0) {
                layersContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #666; font-size: 11px;">No layers. Select object and click [+ Layer]</div>';
            } else {
                timeline.layers.forEach((layer, index) => {
                    console.log(`  Layer ${index}:`, layer.name, 'keyframes:', layer.keyframes.length);
                    const layerEl = createLayerElement(layer);
                    layersContainer.appendChild(layerEl);
                });
            }
        }
    }
    
    // Create layer element
    function createLayerElement(layer) {
        const div = document.createElement('div');
        div.className = 'timeline-layer';
        div.style.cssText = `
            display: grid;
            grid-template-columns: 200px 1fr;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            height: 40px;
        `;
        
        // Layer info (left)
        const info = document.createElement('div');
        info.style.cssText = `
            padding: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            border-right: 1px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.3);
        `;
        
        const colorDot = document.createElement('div');
        colorDot.style.cssText = `
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: ${layer.color};
        `;
        
        const name = document.createElement('div');
        name.textContent = layer.name;
        name.style.cssText = 'font-size: 11px; color: #fff; flex: 1;';
        
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = '‚úï';
        deleteBtn.onclick = () => removeLayer(layer.id);
        deleteBtn.style.cssText = `
            width: 20px;
            height: 20px;
            border: none;
            background: rgba(220,38,38,0.2);
            color: #dc2626;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
        `;
        
        info.appendChild(colorDot);
        info.appendChild(name);
        info.appendChild(deleteBtn);
        
        // Timeline track (right)
        const track = document.createElement('div');
        track.style.cssText = `
            position: relative;
            background: rgba(0,0,0,0.5);
            cursor: pointer;
        `;
        track.onclick = (e) => {
            const rect = track.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const percent = x / rect.width;
            const time = percent * timeline.duration;
            seekTimeline(time);
        };
        
        // Add keyframe markers
        layer.keyframes.forEach(kf => {
            const marker = document.createElement('div');
            marker.className = 'timeline-keyframe-marker';
            marker.style.left = ((kf.time / timeline.duration) * 100) + '%';
            marker.style.background = layer.color;
            marker.title = `${kf.property} at ${kf.time.toFixed(2)}s (${kf.easing})`;
            marker.onclick = (e) => {
                e.stopPropagation();
                seekTimeline(kf.time);
            };
            track.appendChild(marker);
        });
        
        div.appendChild(info);
        div.appendChild(track);
        
        return div;
    }
    
    // Get random color for layer
    function getRandomColor() {
        const colors = [
            '#0d9488', '#3b82f6', '#8b5cf6', '#ec4899', 
            '#f59e0b', '#10b981', '#ef4444', '#06b6d4'
        ];
        return colors[Math.floor(Math.random() * colors.length)];
    }
    
    // Toggle timeline visibility
    window.toggleTimeline = function() {
        const container = document.getElementById('timeline-container');
        if (container) {
            const isVisible = container.style.display !== 'none';
            container.style.display = isVisible ? 'none' : 'block';
            
            // Update button style
            const btn = document.getElementById('timeline-toggle-btn');
            if (btn) {
                if (!isVisible) {
                    btn.style.background = 'rgba(13,148,136,0.2)';
                    btn.style.borderColor = '#0d9488';
                    btn.style.color = '#0d9488';
                } else {
                    btn.style.background = 'rgba(255,255,255,0.05)';
                    btn.style.borderColor = 'rgba(255,255,255,0.1)';
                    btn.style.color = '#888';
                }
            }
            
            // Initialize playhead dragging after showing timeline
            if (!isVisible) {
                setTimeout(initPlayheadDrag, 100);
            }
            
            console.log(`‚è±Ô∏è Timeline: ${isVisible ? 'Hidden' : 'Shown'}`);
        }
    };
    
    // Initialize playhead dragging
    function initPlayheadDrag() {
        const playhead = document.getElementById('timeline-playhead');
        const ruler = document.getElementById('timeline-ruler');
        
        if (!playhead || !ruler) return;
        
        let isDragging = false;
        
        // Click ruler to seek
        ruler.addEventListener('click', (e) => {
            if (e.target === playhead || playhead.contains(e.target)) return;
            
            const rect = ruler.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const percent = x / rect.width;
            const time = percent * timeline.duration;
            seekTimeline(Math.max(0, Math.min(time, timeline.duration)));
        });
        
        // Drag playhead
        playhead.addEventListener('mousedown', (e) => {
            isDragging = true;
            playhead.style.cursor = 'grabbing';
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const rect = ruler.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const percent = Math.max(0, Math.min(1, x / rect.width));
            const time = percent * timeline.duration;
            
            seekTimeline(time);
        });
        
        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                playhead.style.cursor = 'grab';
            }
        });
    }
    
    // DEBUG: Inspect timeline
    window.inspectTimeline = function() {
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('üîç TIMELINE INSPECTION');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('Duration:', timeline.duration, 's');
        console.log('Current time:', timeline.currentTime, 's');
        console.log('Playing:', timeline.playing);
        console.log('Layers count:', timeline.layers.length);
        console.log('');
        
        timeline.layers.forEach((layer, i) => {
            console.log(`Layer ${i}: ${layer.name}`);
            console.log('  Object:', layer.object);
            console.log('  Keyframes:', layer.keyframes.length);
            layer.keyframes.forEach((kf, j) => {
                console.log(`    ${j}. ${kf.property} at ${kf.time.toFixed(2)}s (${kf.easing})`);
            });
            console.log('');
        });
        
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    };
    
    // Change easing for selected keyframe
    window.changeEasing = function(easing) {
        // TODO: Add UI to select keyframe and change easing
        console.log(`üìà Easing: ${easing}`);
    };
    
    // ========== CAMERA SYSTEM (Mapping Matters Style) ==========
    
    // Camera storage
    let cameras = [];
    let activeCameraForView = null;
    let cameraIdCounter = 0;
    
    // Create camera function
    window.createCamera = function() {
        const cameraId = ++cameraIdCounter;
        
        // Create camera helper (frustum visualization)
        const fov = 50;
        const aspect = 16 / 9;
        const near = 0.1;
        const far = 100;
        
        const helperCamera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        
        // Position at current viewport camera position or center
        if (camera) {
            helperCamera.position.copy(camera.position);
            helperCamera.quaternion.copy(camera.quaternion);
        } else {
            helperCamera.position.set(0, 5, 10);
            helperCamera.lookAt(0, 0, 0);
        }
        
        // Create target point (red sphere)
        const targetGeometry = new THREE.SphereGeometry(0.2, 16, 16);
        const targetMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const target = new THREE.Mesh(targetGeometry, targetMaterial);
        target.position.set(0, 2, 0);
        target.userData = { isTarget: true, isCameraTarget: true, noProjection: true };
        scene.add(target);
        selectableObjects.push(target);
        
        // Create camera helper
        const helper = new THREE.CameraHelper(helperCamera);
        helper.userData = { noProjection: true };
        scene.add(helper);
        
        // Create camera group for selection
        const group = new THREE.Group();
        group.position.copy(helperCamera.position);
        group.quaternion.copy(helperCamera.quaternion);
        group.userData = { isCamera: true, name: `Camera ${cameraId}`, type: 'camera' };
        scene.add(group);
        selectableObjects.push(group);
        
        // Create camera object
        const cameraObj = {
            id: cameraId,
            name: `Camera ${cameraId}`,
            camera: helperCamera,
            target: target,
            helper: helper,
            group: group,
            focalLength: 35, // mm
            resolution: { width: 1920, height: 1080 },
            roll: 0, // degrees
            orthographic: false,
            visible: true
        };
        
        // Store reference
        group.userData.cameraInstance = cameraObj;
        
        cameras.push(cameraObj);
        
        // Update hierarchy
        populateSceneHierarchy();
        
        console.log(`üì∑ Camera created: ${cameraObj.name}`);
        
        return cameraObj;
    };
    
    // Look from camera
    window.lookFromCamera = function(cameraObj) {
        if (!cameraObj) return;
        
        activeCameraForView = cameraObj;
        
        // Disable orbit controls
        controls.enabled = false;
        
        // Switch main camera to this camera's view
        camera.position.copy(cameraObj.camera.position);
        camera.quaternion.copy(cameraObj.camera.quaternion);
        camera.fov = cameraObj.camera.fov;
        camera.aspect = cameraObj.camera.aspect;
        camera.near = cameraObj.camera.near;
        camera.far = cameraObj.camera.far;
        camera.updateProjectionMatrix();
        
        console.log(`üëÅÔ∏è Looking from: ${cameraObj.name}`);
        
        // Show exit button
        showCameraExitButton();
    };
    
    // Exit camera view
    window.exitCameraView = function() {
        activeCameraForView = null;
        controls.enabled = true;
        hideCameraExitButton();
        console.log(`üëÅÔ∏è Exited camera view`);
    };
    
    // Update camera to look at target
    function updateCameraLookAt(cameraObj) {
        if (!cameraObj) return;
        
        cameraObj.camera.lookAt(cameraObj.target.position);
        cameraObj.group.position.copy(cameraObj.camera.position);
        cameraObj.group.quaternion.copy(cameraObj.camera.quaternion);
        
        if (cameraObj.helper) {
            cameraObj.helper.update();
        }
    }
    
    // Update camera target
    window.updateCameraTarget = function(cameraObj, x, y, z) {
        if (!cameraObj) return;
        
        cameraObj.target.position.set(x, y, z);
        updateCameraLookAt(cameraObj);
        
        console.log(`üéØ Target: (${x.toFixed(2)}, ${y.toFixed(2)}, ${z.toFixed(2)})`);
    };
    
    // Update camera focal length
    window.updateCameraFocalLength = function(cameraObj, focalLength) {
        if (!cameraObj) return;
        
        cameraObj.focalLength = focalLength;
        
        // Convert focal length to FOV
        // FOV = 2 * atan(sensor_size / (2 * focal_length))
        // Assuming 35mm full frame sensor (36mm width)
        const sensorWidth = 36;
        const fov = 2 * Math.atan(sensorWidth / (2 * focalLength)) * (180 / Math.PI);
        
        cameraObj.camera.fov = fov;
        cameraObj.camera.updateProjectionMatrix();
        
        if (cameraObj.helper) {
            scene.remove(cameraObj.helper);
            cameraObj.helper = new THREE.CameraHelper(cameraObj.camera);
            cameraObj.helper.userData = { noProjection: true };
            scene.add(cameraObj.helper);
        }
        
        console.log(`üì∑ Focal Length: ${focalLength}mm ‚Üí FOV: ${fov.toFixed(1)}¬∞`);
    };
    
    // Update camera roll
    window.updateCameraRoll = function(cameraObj, rollDegrees) {
        if (!cameraObj) return;
        
        cameraObj.roll = rollDegrees;
        
        // Save current forward direction
        const forward = new THREE.Vector3(0, 0, -1);
        forward.applyQuaternion(cameraObj.camera.quaternion);
        
        // Recalculate orientation with roll
        cameraObj.camera.lookAt(cameraObj.target.position);
        
        // Apply roll around forward axis
        const rollRad = rollDegrees * (Math.PI / 180);
        const rollQuat = new THREE.Quaternion();
        rollQuat.setFromAxisAngle(forward, rollRad);
        cameraObj.camera.quaternion.multiply(rollQuat);
        
        cameraObj.group.quaternion.copy(cameraObj.camera.quaternion);
        
        if (cameraObj.helper) {
            cameraObj.helper.update();
        }
        
        console.log(`üì∑ Roll: ${rollDegrees}¬∞`);
    };
    
    // Toggle orthographic mode
    window.toggleCameraOrthographic = function(cameraObj) {
        if (!cameraObj) return;
        
        cameraObj.orthographic = !cameraObj.orthographic;
        
        scene.remove(cameraObj.helper);
        
        if (cameraObj.orthographic) {
            // Switch to orthographic
            const frustumHeight = 10;
            const frustumWidth = frustumHeight * (cameraObj.resolution.width / cameraObj.resolution.height);
            
            const orthoCamera = new THREE.OrthographicCamera(
                -frustumWidth / 2, frustumWidth / 2,
                frustumHeight / 2, -frustumHeight / 2,
                cameraObj.camera.near, cameraObj.camera.far
            );
            
            orthoCamera.position.copy(cameraObj.camera.position);
            orthoCamera.quaternion.copy(cameraObj.camera.quaternion);
            
            cameraObj.camera = orthoCamera;
            
            console.log(`üì∑ ${cameraObj.name}: Orthographic ON`);
        } else {
            // Switch to perspective
            const perspCamera = new THREE.PerspectiveCamera(
                50, cameraObj.resolution.width / cameraObj.resolution.height,
                0.1, 100
            );
            
            perspCamera.position.copy(cameraObj.camera.position);
            perspCamera.quaternion.copy(cameraObj.camera.quaternion);
            
            cameraObj.camera = perspCamera;
            updateCameraFocalLength(cameraObj, cameraObj.focalLength);
            
            console.log(`üì∑ ${cameraObj.name}: Orthographic OFF`);
        }
        
        cameraObj.helper = new THREE.CameraHelper(cameraObj.camera);
        cameraObj.helper.userData = { noProjection: true };
        scene.add(cameraObj.helper);
    };
    
    // Update camera resolution
    window.updateCameraResolution = function(cameraObj, width, height) {
        if (!cameraObj) return;
        
        cameraObj.resolution = { width, height };
        cameraObj.camera.aspect = width / height;
        cameraObj.camera.updateProjectionMatrix();
        
        if (cameraObj.helper) {
            scene.remove(cameraObj.helper);
            cameraObj.helper = new THREE.CameraHelper(cameraObj.camera);
            cameraObj.helper.userData = { noProjection: true };
            scene.add(cameraObj.helper);
        }
        
        console.log(`üì∑ Resolution: ${width}√ó${height}`);
    };
    
    // Delete camera
    window.deleteCamera = function(cameraObj) {
        if (!cameraObj) return;
        
        scene.remove(cameraObj.target);
        scene.remove(cameraObj.helper);
        scene.remove(cameraObj.group);
        
        const targetIdx = selectableObjects.indexOf(cameraObj.target);
        if (targetIdx > -1) selectableObjects.splice(targetIdx, 1);
        
        const groupIdx = selectableObjects.indexOf(cameraObj.group);
        if (groupIdx > -1) selectableObjects.splice(groupIdx, 1);
        
        const index = cameras.indexOf(cameraObj);
        if (index > -1) {
            cameras.splice(index, 1);
        }
        
        if (activeCameraForView === cameraObj) {
            exitCameraView();
        }
        
        populateSceneHierarchy();
        
        console.log(`üì∑ Camera deleted: ${cameraObj.name}`);
    };
    
    // Show exit button overlay
    function showCameraExitButton() {
        let exitBtn = document.getElementById('camera-exit-btn');
        if (!exitBtn) {
            exitBtn = document.createElement('button');
            exitBtn.id = 'camera-exit-btn';
            exitBtn.innerHTML = 'üëÅÔ∏è Exit Camera View';
            exitBtn.onclick = exitCameraView;
            exitBtn.style.cssText = `
                position: fixed;
                top: 70px;
                left: 50%;
                transform: translateX(-50%);
                padding: 10px 20px;
                background: rgba(220, 38, 38, 0.9);
                border: 2px solid #dc2626;
                border-radius: 6px;
                color: white;
                font-weight: 600;
                cursor: pointer;
                z-index: 1000;
                font-size: 14px;
            `;
            document.body.appendChild(exitBtn);
        }
        exitBtn.style.display = 'block';
    }
    
    function hideCameraExitButton() {
        const exitBtn = document.getElementById('camera-exit-btn');
        if (exitBtn) exitBtn.style.display = 'none';
    }
    
    // Update all cameras in animate loop
    function updateAllCameras() {
        cameras.forEach(cam => {
            // If gizmo is dragging camera group, sync camera to group
            if (transformControls.object === cam.group && transformControls.dragging) {
                cam.camera.position.copy(cam.group.position);
                cam.camera.quaternion.copy(cam.group.quaternion);
            } else {
                // Otherwise sync group to camera
                cam.group.position.copy(cam.camera.position);
                cam.group.quaternion.copy(cam.camera.quaternion);
            }
            
            // Always look at target
            updateCameraLookAt(cam);
            
            // Update helper
            if (cam.helper) {
                cam.helper.update();
            }
        });
        
        // If in camera view, sync main camera
        if (activeCameraForView) {
            camera.position.copy(activeCameraForView.camera.position);
            camera.quaternion.copy(activeCameraForView.camera.quaternion);
            camera.fov = activeCameraForView.camera.fov;
            camera.updateProjectionMatrix();
        }
    }
    
    // ===== EXPORT PNG =====
    window.exportScenePNG = function() {
        console.log('üì∏ Exporting scene as PNG...');
        
        // Render current frame
        renderer.render(scene, camera);
        
        // Get canvas data as PNG
        const link = document.createElement('a');
        link.download = `projector_scene_${Date.now()}.png`;
        link.href = renderer.domElement.toDataURL('image/png');
        link.click();
        
        console.log('‚úÖ PNG exported');
    };
    
    // ===== COPY / PASTE / DUPLICATE =====
    let copiedObject = null;
    
    function copyObject() {
        if (!selectedObject) return;
        copiedObject = selectedObject;
        console.log(`üìã Copied: ${selectedObject.userData.name || 'Object'}`);
    }
    
    function pasteObject() {
        if (!copiedObject) {
            console.log('‚ùå Nothing to paste');
            return;
        }
        duplicateObject(copiedObject);
    }
    
    function duplicateObject(obj) {
        if (!obj || obj.userData.isTarget) return;
        
        // Duplicate projector
        if (obj.userData.isProjector) {
            const instance = obj.userData.projectorInstance || activeProjector;
            if (!instance) return;
            
            // Create new projector with same config
            createProjector(instance.config.model, instance.config.lens);
            
            // Copy position with offset
            if (activeProjector) {
                const pos = instance.group.position;
                activeProjector.group.position.set(pos.x + 1, pos.y, pos.z + 1);
                
                // Copy rotation
                const rot = instance.group.rotation;
                activeProjector.group.rotation.copy(rot);
            }
            
            console.log(`‚úÖ Duplicated projector`);
            populateSceneHierarchy();
            return;
        }
        
        // Duplicate regular object
        let newObj;
        
        if (obj.type === 'Group') {
            // Clone group (like human mannequin)
            newObj = obj.clone();
            newObj.traverse(child => {
                if (child.isMesh && child.material) {
                    child.material = child.material.clone();
                }
            });
        } else {
            // Clone single mesh
            const newGeometry = obj.geometry.clone();
            const newMaterial = obj.material.clone();
            newObj = new THREE.Mesh(newGeometry, newMaterial);
            newObj.castShadow = true;
            newObj.receiveShadow = true;
        }
        
        // Copy position with offset
        newObj.position.copy(obj.position);
        newObj.position.x += 1;
        newObj.position.z += 1;
        
        // Copy rotation and scale
        newObj.rotation.copy(obj.rotation);
        newObj.scale.copy(obj.scale);
        
        // Copy userData
        newObj.userData = { ...obj.userData };
        const baseName = obj.userData.name || 'Object';
        newObj.userData.name = baseName + ' Copy';
        
        scene.add(newObj);
        projectedObjects.push(newObj);
        selectableObjects.push(newObj);
        
        selectObject(newObj);
        updateProjectionMatrix();
        populateSceneHierarchy();
        
        console.log(`‚úÖ Duplicated: ${newObj.userData.name}`);
    }
    
    function onKeyDown(e) {
        // Handle Undo/Redo globally (not dependent on selection)
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
            if (e.shiftKey) {
                historyRedo();
            } else {
                historyUndo();
            }
            e.preventDefault();
            return;
        }
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y') {
            historyRedo();
            e.preventDefault();
            return;
        }
        
        // Ctrl+C - Copy
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'c') {
            if (selectedObject && !selectedObject.userData.isTarget) {
                copyObject();
                e.preventDefault();
            }
            return;
        }
        
        // Ctrl+V - Paste
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'v') {
            pasteObject();
            e.preventDefault();
            return;
        }
        
        // Ctrl+D - Duplicate
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'd') {
            if (selectedObject && !selectedObject.userData.isTarget) {
                duplicateObject(selectedObject);
                e.preventDefault();
            }
            return;
        }

        if (!selectedObject) return;

        switch(e.key.toLowerCase()) {
            case 'g':
                setGizmoMode('translate');
                break;
            case 'r':
                setGizmoMode('rotate');
                break;
            case 's':
                if (!e.ctrlKey && !e.metaKey) {
                    setGizmoMode('scale');
                    e.preventDefault();
                }
                break;
            case 'delete':
            case 'backspace':
                if (selectedObject && !selectedObject.userData.isProjector && !selectedObject.userData.isTarget) {
                    // Record deletion for undo
                    pushHistory({
                        type: 'delete_object',
                        object: selectedObject,
                        objectType: selectedObject.userData.type || 'object'
                    });
                    scene.remove(selectedObject);
                    projectedObjects.splice(projectedObjects.indexOf(selectedObject), 1);
                    selectableObjects.splice(selectableObjects.indexOf(selectedObject), 1);
                    selectObject(null);
                    populateSceneHierarchy();
                }
                e.preventDefault();
                break;
            case 'escape':
                selectObject(null);
                break;
            case 'k':
                if (!e.ctrlKey && !e.metaKey) {
                    addKeyframeQuick();
                    e.preventDefault();
                }
                break;
        }
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ===== PHOTOMETRIC ANALYSIS FUNCTIONS =====
    
    window.togglePhotometric = function() {
        photometricMode = !photometricMode;
        
        const toggleBtn = document.getElementById('photometric-toggle');
        const settings = document.getElementById('photometric-settings');
        const results = document.getElementById('photometric-results');
        
        if (photometricMode) {
            toggleBtn.textContent = '‚ùå Disable Analysis Mode';
            toggleBtn.style.background = '#dc2626';
            settings.style.display = 'block';
            results.style.display = 'block';
            updatePhotometric();
        } else {
            toggleBtn.textContent = '‚úÖ Enable Analysis Mode';
            toggleBtn.style.background = '#0d9488';
            settings.style.display = 'none';
            results.style.display = 'none';
        }
    };
    
    window.updatePhotometric = function() {
        if (!photometricMode) return;
        
        // Read UI values
        photometricScaleMax = parseFloat(document.getElementById('photo-scale-max')?.value || 1000);
        photometricScaleLog = document.getElementById('photo-scale-log')?.checked || false;
        photometricShaderLog = document.getElementById('photo-shader-log')?.checked || false;
        ambientLightLux = parseFloat(document.getElementById('photo-ambient')?.value || 0);
        directionalLightLux = parseFloat(document.getElementById('photo-directional')?.value || 0);
        materialGain = parseFloat(document.getElementById('photo-gain')?.value || 1.0);
        
        // Update display values
        document.getElementById('photo-scale-max-val').textContent = photometricScaleMax;
        document.getElementById('photo-ambient-val').textContent = ambientLightLux;
        document.getElementById('photo-directional-val').textContent = directionalLightLux;
        document.getElementById('photo-gain-val').textContent = materialGain.toFixed(2);
        
        // Calculate photometric values if projector exists
        if (activeProjector && activeProjector.target) {
            const results = calculatePhotometrics(activeProjector);
            
            // Update result displays
            document.getElementById('photo-result-illuminance').textContent = 
                results.illuminance.toFixed(1) + ' lux';
            document.getElementById('photo-result-luminance').textContent = 
                results.luminance.toFixed(1) + ' cd/m¬≤';
            document.getElementById('photo-result-pixelsize').textContent = 
                results.pixelSize.toFixed(2) + ' mm';
            document.getElementById('photo-result-contrast').textContent = 
                results.contrastRatio.toFixed(1) + ':1';
        }
    };
    
    function calculatePhotometrics(projector) {
        // Safety checks
        if (!projector || !projector.group || !projector.target) {
            return {
                illuminance: 0,
                luminance: 0,
                pixelSize: 0,
                contrastRatio: 0,
                projectedArea: 0,
                projectedWidth: 0,
                projectedHeight: 0
            };
        }
        
        // Distance from projector to target
        const projPos = projector.group.position;
        const targetPos = projector.target.position;
        const distance = projPos.distanceTo(targetPos);
        
        // Safety check for throw ratio
        if (!projector.throwRatio || projector.throwRatio <= 0) {
            console.warn('‚ö†Ô∏è Invalid throw ratio:', projector.throwRatio);
            return {
                illuminance: 0,
                luminance: 0,
                pixelSize: 0,
                contrastRatio: 0,
                projectedArea: 0,
                projectedWidth: 0,
                projectedHeight: 0
            };
        }
        
        // Projected area calculation
        // Width of projection = distance / throw ratio
        const projectedWidth = distance / projector.throwRatio;
        const projectedHeight = projectedWidth / ASPECT; // ASPECT = 16/9 = 1.777...
        const projectedArea = projectedWidth * projectedHeight; // in m¬≤
        
        // Lumens calculation (with stack multiplier if applicable)
        const lumens = projector.projectorLumens || 25000; // Default to 25000 if not set
        const totalLumens = lumens * (projector.stackMultiplier || 1);
        
        // ILLUMINANCE (lux) = Lumens / Area
        // This is the luminous flux per unit area
        const illuminance = projectedArea > 0 ? totalLumens / projectedArea : 0;
        
        // LUMINANCE (cd/m¬≤) = (Illuminance √ó Material Gain) / œÄ
        // For Lambertian surfaces (matte screens)
        const luminance = (illuminance * materialGain) / Math.PI;
        
        // PIXEL SIZE (mm)
        // Native resolution 1920√ó1080
        const pixelSize = (projectedWidth / 1920) * 1000; // Convert to mm
        
        // CONTRAST RATIO
        // = Projection Illuminance / (Ambient + Directional)
        const ambientTotal = ambientLightLux + directionalLightLux;
        const contrastRatio = ambientTotal > 0 ? illuminance / ambientTotal : Infinity;
        
        return {
            illuminance: illuminance,
            luminance: luminance,
            pixelSize: pixelSize,
            contrastRatio: isFinite(contrastRatio) ? contrastRatio : 9999,
            projectedArea: projectedArea,
            projectedWidth: projectedWidth,
            projectedHeight: projectedHeight
        };
    }
    
    window.closePhotometricResults = function() {
        document.getElementById('photometric-results').style.display = 'none';
    };

    function updateProjectionMatrix() {
        if (!projectorCamera || !shadowLight) return;

        // Reset camera positions to origin (no offset - lens shift is via projection matrix)
        projectorCamera.position.set(0, 0, 0);
        shadowLight.position.set(0, 0, 0);
        
        projectorCamera.updateMatrixWorld(true);
        projectorCamera.updateProjectionMatrix();
        // Apply lens shift via off-axis projection
        applyLensShiftToCamera(projectorCamera, lensShiftH / 100, lensShiftV / 100);

        const projMatrix = new THREE.Matrix4();
        projMatrix.multiplyMatrices(projectorCamera.projectionMatrix, projectorCamera.matrixWorldInverse);

        const worldPos = new THREE.Vector3();
        projectorCamera.getWorldPosition(worldPos);

        const fov = throwToFOV(throwRatio);
        shadowLight.angle = THREE.MathUtils.degToRad(fov / 2);
        shadowLight.shadow.camera.fov = fov;
        shadowLight.shadow.camera.aspect = ASPECT;
        shadowLight.shadow.camera.near = projectorCamera.near;
        shadowLight.shadow.camera.far = frustumFar;
        shadowLight.shadow.bias = -0.0001;
        shadowLight.shadow.camera.updateProjectionMatrix();
        // Apply same lens shift to shadow camera (for frustum visualization)
        applyLensShiftToCamera(shadowLight.shadow.camera, lensShiftH / 100, lensShiftV / 100);

        shadowLight.updateMatrixWorld(true);
        shadowLight.shadow.camera.updateMatrixWorld(true);

        // Use depthCamera for shadowMatrix since it renders the depth map WITHOUT lens shift
        // This ensures shadow UV lookup matches the depth map rendering
        depthCamera.position.copy(projectorGroup.position);
        depthCamera.quaternion.copy(projectorGroup.quaternion);
        depthCamera.fov = fov;
        depthCamera.aspect = ASPECT;
        depthCamera.near = projectorCamera.near;
        depthCamera.far = window.DEPTH_MAP_FAR || 200;
        depthCamera.updateProjectionMatrix();
        depthCamera.updateMatrixWorld(true);
        
        const shadowMatrix = new THREE.Matrix4();
        shadowMatrix.multiplyMatrices(depthCamera.projectionMatrix, depthCamera.matrixWorldInverse);

        const dist = projDistance;
        const width = dist / throwRatio;
        const height = width / ASPECT;
        const shiftOffsetV = (lensShiftV / 100) * height;
        const shiftOffsetH = (lensShiftH / 100) * width;
        const localCenter = new THREE.Vector3(shiftOffsetH, shiftOffsetV, -dist);
        if (projectorMesh.userData.shadowTarget) {
            projectorMesh.userData.shadowTarget.position.copy(localCenter);
        }

        projectedObjects.forEach(obj => {
            if (obj.userData?.noProjection) return;
            if (obj.material?.uniforms) {
                const u = obj.material.uniforms;
                // Update projector 0 uniforms (the first/default projector)
                if (u.projMatrix0) u.projMatrix0.value.copy(projMatrix);
                if (u.projPosition0) u.projPosition0.value.copy(worldPos);
                if (u.hasTexture0) u.hasTexture0.value = !!projectionTexture;
                // Apply stack multiplier to intensity for lumens multiplication
                // If stack is bypassed, use multiplier = 1 (no stacking)
                const stackMultiplier = stackBypassed ? 1 : (activeProjector ? activeProjector.stackMultiplier : 1);
                const effectiveIntensity = projectionIntensity * stackMultiplier;
                if (u.intensity0) u.intensity0.value = effectiveIntensity;
                if (u.shadowSoftness0) u.shadowSoftness0.value = shadowSoftness;
                if (u.shadowBias0) u.shadowBias0.value = shadowBias;
                if (u.useHighQualityPCF) u.useHighQualityPCF.value = useHighQualityPCF;
                if (u.shadowCameraFar0) u.shadowCameraFar0.value = frustumFar;
                if (u.projTexture0 && projectionTexture) u.projTexture0.value = projectionTexture;
                if (u.shadowMatrix0) u.shadowMatrix0.value.copy(shadowMatrix);
                if (u.shadowMap0) u.shadowMap0.value = depthRenderTarget ? depthRenderTarget.texture : defaultShadowTexture;
                if (u.depthMapFar0) u.depthMapFar0.value = window.DEPTH_MAP_FAR || 200;
                if (u.projectionFar0) u.projectionFar0.value = projectorCamera.far;
                if (u.projectorActive0) u.projectorActive0.value = projectorGroup ? projectorGroup.visible : true;
                if (u.shadowViewMatrix0 && depthCamera) {
                    depthCamera.updateMatrixWorld(true);
                    u.shadowViewMatrix0.value.copy(depthCamera.matrixWorldInverse);
                }
                if (u.keystoneV0) {
                    u.keystoneV0.value = keystoneV;
                    u.keystoneH0.value = keystoneH;
                }
                if (u.keystoneTLX0) {
                    u.keystoneTLX0.value = keystoneTLX;
                    u.keystoneTLY0.value = keystoneTLY;
                    u.keystoneTRX0.value = keystoneTRX;
                    u.keystoneTRY0.value = keystoneTRY;
                    u.keystoneBLX0.value = keystoneBLX;
                    u.keystoneBLY0.value = keystoneBLY;
                    u.keystoneBRX0.value = keystoneBRX;
                    u.keystoneBRY0.value = keystoneBRY;
                }
                if (u.softEdgeL0) {
                    u.softEdgeL0.value = softEdgeL;
                    u.softEdgeR0.value = softEdgeR;
                    u.softEdgeT0.value = softEdgeT;
                    u.softEdgeB0.value = softEdgeB;
                    u.softEdgeGamma0.value = softEdgeGamma;
                }
                if (u.numProjectors) u.numProjectors.value = Math.min(projectors.length, 4);
                obj.material.needsUpdate = true;
            }
        });

        if (projectorHelper) projectorHelper.update();
        
        // Update all projector helpers
        projectors.forEach(proj => {
            if (proj.helper) proj.helper.update();
        });
    }

    // Render depth pass for a specific projector instance
    function renderDepthPassForInstance(instance) {
        if (!instance.depthCamera || !instance.depthRenderTarget || !depthMaterial) return;

        const DEPTH_FAR = window.DEPTH_MAP_FAR || 200;

        instance.depthCamera.position.copy(instance.group.position);
        instance.depthCamera.quaternion.copy(instance.group.quaternion);
        instance.depthCamera.fov = throwToFOV(instance.throwRatio);
        instance.depthCamera.aspect = ASPECT;
        instance.depthCamera.near = 0.1;
        instance.depthCamera.far = DEPTH_FAR;
        instance.depthCamera.updateProjectionMatrix();
        instance.depthCamera.updateMatrixWorld(true);

        depthMaterial.uniforms.cameraNear.value = instance.depthCamera.near;
        depthMaterial.uniforms.cameraFar.value = DEPTH_FAR;

        const originalMaterials = new Map();
        const originalVisibility = new Map();
        
        scene.traverse(obj => {
            if (obj.isMesh) {
                originalMaterials.set(obj, obj.material);
                originalVisibility.set(obj, obj.visible);
                
                if (obj.userData.noProjection || obj.userData.isLabel || obj.userData.isProjector || obj.userData.isTarget) {
                    obj.visible = false;
                } else if (obj.castShadow) {
                    obj.material = depthMaterial;
                } else {
                    obj.visible = false;
                }
            }
        });

        projectors.forEach(p => { if (p.helper) p.helper.visible = false; });
        if (transformControls) transformControls.visible = false;

        renderer.setRenderTarget(instance.depthRenderTarget);
        renderer.clear();
        renderer.render(scene, instance.depthCamera);
        renderer.setRenderTarget(null);

        scene.traverse(obj => {
            if (obj.isMesh && originalMaterials.has(obj)) {
                obj.material = originalMaterials.get(obj);
                obj.visible = originalVisibility.get(obj);
            }
        });

        const showFrustum = document.getElementById('show-frustum')?.checked ?? true;
        projectors.forEach(p => { if (p.helper) p.helper.visible = showFrustum; });
        if (transformControls) transformControls.visible = true;
    }

    // Update all projectors
    function updateAllProjectors() {
        projectors.forEach(instance => {
            // If locked to an object, move target mesh to follow object
            if (instance.targetLocked && instance.targetObject) {
                const worldPos = new THREE.Vector3();
                instance.targetObject.getWorldPosition(worldPos);
                targetMesh.position.copy(worldPos);
                instance.target = targetMesh; // Ensure target is the mesh
            }
            
            // Update target lock behavior
            if (instance.targetLocked && instance.userMovedTarget) {
                const targetPos = instance.target.position.clone();
                const projPos = instance.group.position.clone();
                const dir = new THREE.Vector3().subVectors(targetPos, projPos);
                if (dir.length() > 0.01) {
                    const m = new THREE.Matrix4().lookAt(projPos, instance.target.position, new THREE.Vector3(0,1,0));
                    instance.group.quaternion.setFromRotationMatrix(m);
                }
            }
            
            // Render depth pass for this projector
            renderDepthPassForInstance(instance);
            
            // Update projection matrix for this projector
            updateProjectionMatrixForInstance(instance);
            
            // Update helper
            if (instance.helper) instance.helper.update();
        });
    }

    // Update projection matrix for a specific instance
    function updateProjectionMatrixForInstance(instance) {
        if (!instance.camera || !instance.shadowLight) return;

        instance.camera.position.set(0, 0, 0);
        instance.shadowLight.position.set(0, 0, 0);
        
        instance.camera.updateMatrixWorld(true);
        instance.camera.updateProjectionMatrix();
        applyLensShiftToCamera(instance.camera, instance.lensShiftH / 100, instance.lensShiftV / 100);

        const projMatrix = new THREE.Matrix4();
        projMatrix.multiplyMatrices(instance.camera.projectionMatrix, instance.camera.matrixWorldInverse);

        const worldPos = new THREE.Vector3();
        instance.camera.getWorldPosition(worldPos);

        const fov = throwToFOV(instance.throwRatio);
        instance.shadowLight.angle = THREE.MathUtils.degToRad(fov / 2);
        instance.shadowLight.shadow.camera.fov = fov;
        instance.shadowLight.shadow.camera.aspect = ASPECT;
        instance.shadowLight.shadow.camera.near = instance.camera.near;
        instance.shadowLight.shadow.camera.far = instance.frustumFar;
        instance.shadowLight.shadow.bias = -0.0001;
        instance.shadowLight.shadow.camera.updateProjectionMatrix();
        applyLensShiftToCamera(instance.shadowLight.shadow.camera, instance.lensShiftH / 100, instance.lensShiftV / 100);

        instance.shadowLight.updateMatrixWorld(true);
        instance.shadowLight.shadow.camera.updateMatrixWorld(true);

        instance.depthCamera.position.copy(instance.group.position);
        instance.depthCamera.quaternion.copy(instance.group.quaternion);
        instance.depthCamera.fov = fov;
        instance.depthCamera.aspect = ASPECT;
        instance.depthCamera.near = instance.camera.near;
        instance.depthCamera.far = window.DEPTH_MAP_FAR || 200;
        instance.depthCamera.updateProjectionMatrix();
        instance.depthCamera.updateMatrixWorld(true);
        
        const shadowMatrix = new THREE.Matrix4();
        shadowMatrix.multiplyMatrices(instance.depthCamera.projectionMatrix, instance.depthCamera.matrixWorldInverse);

        const dist = instance.projDistance;
        const width = dist / instance.throwRatio;
        const height = width / ASPECT;
        const shiftOffsetV = (instance.lensShiftV / 100) * height;
        const shiftOffsetH = (instance.lensShiftH / 100) * width;
        const localCenter = new THREE.Vector3(shiftOffsetH, shiftOffsetV, -dist);
        if (instance.mesh.userData.shadowTarget) {
            instance.mesh.userData.shadowTarget.position.copy(localCenter);
        }

        // Update materials for ALL projectors using indexed uniforms
        const projIndex = projectors.indexOf(instance);
        if (projIndex >= 0 && projIndex < 4) {
            const i = projIndex;
            projectedObjects.forEach(obj => {
                if (obj.userData?.noProjection) return;
                if (obj.material?.uniforms) {
                    const u = obj.material.uniforms;
                    if (u[`projMatrix${i}`]) u[`projMatrix${i}`].value.copy(projMatrix);
                    if (u[`projPosition${i}`]) u[`projPosition${i}`].value.copy(worldPos);
                    if (u[`hasTexture${i}`]) u[`hasTexture${i}`].value = !!instance.projectionTexture;
                    // Apply stack multiplier to intensity for lumens multiplication
                    // If stack is bypassed, use multiplier = 1 (no stacking)
                    const stackMultiplier = stackBypassed ? 1 : (instance.stackMultiplier || 1);
                    const effectiveIntensity = instance.projectionIntensity * stackMultiplier;
                    if (u[`intensity${i}`]) u[`intensity${i}`].value = effectiveIntensity;
                    if (u[`shadowSoftness${i}`]) u[`shadowSoftness${i}`].value = instance.shadowSoftness;
                    if (u[`shadowBias${i}`]) u[`shadowBias${i}`].value = instance.shadowBias;
                    if (u[`shadowCameraFar${i}`]) u[`shadowCameraFar${i}`].value = instance.frustumFar;
                    if (u[`projTexture${i}`] && instance.projectionTexture) u[`projTexture${i}`].value = instance.projectionTexture;
                    if (u[`shadowMatrix${i}`]) u[`shadowMatrix${i}`].value.copy(shadowMatrix);
                    if (u[`shadowMap${i}`]) u[`shadowMap${i}`].value = instance.depthRenderTarget ? instance.depthRenderTarget.texture : defaultShadowTexture;
                    if (u[`depthMapFar${i}`]) u[`depthMapFar${i}`].value = window.DEPTH_MAP_FAR || 200;
                    if (u[`projectionFar${i}`]) u[`projectionFar${i}`].value = PROJECTOR_CAMERA_FAR;
                    if (u[`projectorActive${i}`]) u[`projectorActive${i}`].value = instance.group ? instance.group.visible : true;
                    if (u[`shadowViewMatrix${i}`] && instance.depthCamera) u[`shadowViewMatrix${i}`].value.copy(instance.depthCamera.matrixWorldInverse);
                    if (u[`keystoneV${i}`]) {
                        // Apply bypass
                        u[`keystoneV${i}`].value = keystoneBypassed ? 0 : instance.keystoneV;
                        u[`keystoneH${i}`].value = keystoneBypassed ? 0 : instance.keystoneH;
                    }
                    if (u[`keystoneTLX${i}`]) {
                        // Apply bypass
                        u[`keystoneTLX${i}`].value = keystoneBypassed ? 0 : (instance.keystoneTLX || 0);
                        u[`keystoneTLY${i}`].value = keystoneBypassed ? 0 : (instance.keystoneTLY || 0);
                        u[`keystoneTRX${i}`].value = keystoneBypassed ? 0 : (instance.keystoneTRX || 0);
                        u[`keystoneTRY${i}`].value = keystoneBypassed ? 0 : (instance.keystoneTRY || 0);
                        u[`keystoneBLX${i}`].value = keystoneBypassed ? 0 : (instance.keystoneBLX || 0);
                        u[`keystoneBLY${i}`].value = keystoneBypassed ? 0 : (instance.keystoneBLY || 0);
                        u[`keystoneBRX${i}`].value = keystoneBypassed ? 0 : (instance.keystoneBRX || 0);
                        u[`keystoneBRY${i}`].value = keystoneBypassed ? 0 : (instance.keystoneBRY || 0);
                    }
                    if (u[`softEdgeL${i}`]) {
                        // Apply bypass
                        u[`softEdgeL${i}`].value = softEdgeBypassed ? 0 : instance.softEdgeL;
                        u[`softEdgeR${i}`].value = softEdgeBypassed ? 0 : instance.softEdgeR;
                        u[`softEdgeT${i}`].value = softEdgeBypassed ? 0 : instance.softEdgeT;
                        u[`softEdgeB${i}`].value = softEdgeBypassed ? 0 : instance.softEdgeB;
                        u[`softEdgeGamma${i}`].value = softEdgeBypassed ? 2.2 : instance.softEdgeGamma;
                    }
                    if (u[`cornerPinTLX${i}`]) {
                        u[`cornerPinTLX${i}`].value = instance.cornerPinTLX || 0;
                        u[`cornerPinTLY${i}`].value = instance.cornerPinTLY || 0;
                        u[`cornerPinTRX${i}`].value = instance.cornerPinTRX || 0;
                        u[`cornerPinTRY${i}`].value = instance.cornerPinTRY || 0;
                        u[`cornerPinBLX${i}`].value = instance.cornerPinBLX || 0;
                        u[`cornerPinBLY${i}`].value = instance.cornerPinBLY || 0;
                        u[`cornerPinBRX${i}`].value = instance.cornerPinBRX || 0;
                        u[`cornerPinBRY${i}`].value = instance.cornerPinBRY || 0;
                    }
                    if (u.useHighQualityPCF) u.useHighQualityPCF.value = useHighQualityPCF;
                    if (u.numProjectors) u.numProjectors.value = Math.min(projectors.length, 4);
                    obj.material.needsUpdate = true;
                }
            });
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        
        try {
            controls.update();

            // Sync state to active projector before updates
            syncToActiveProjector();

            // Handle transform controls dragging for active projector
            if (activeProjector && activeProjector.group && activeProjector.target) {
                if (activeProjector.targetLocked) {
                    if (activeProjector.userMovedTarget) {
                        const targetPos = activeProjector.target.position.clone();
                        const projPos = activeProjector.group.position.clone();
                        const dir = new THREE.Vector3().subVectors(targetPos, projPos);
                        if (dir.length() > 0.01) {
                            const m = new THREE.Matrix4().lookAt(projPos, activeProjector.target.position, new THREE.Vector3(0,1,0));
                            activeProjector.group.quaternion.setFromRotationMatrix(m);
                        }
                    }
                } else {
                    if (transformControls.object === activeProjector.group && transformControls.dragging) {
                        const dir = new THREE.Vector3(0,0,-1).applyQuaternion(activeProjector.group.quaternion);
                        activeProjector.target.position.copy(activeProjector.group.position.clone().add(dir.multiplyScalar(activeProjector.projDistance)));
                        activeProjector.userMovedTarget = true;
                    }
                }

                if (transformControls.dragging && transformControls.object === activeProjector.target) {
                    activeProjector.projDistance = activeProjector.target.position.distanceTo(activeProjector.group.position);
                    projDistance = activeProjector.projDistance;
                }
            }

            // Update all projectors (render depth passes and projection matrices)
            updateAllProjectors();
            
            // Update all cameras
            updateAllCameras();
            
            // Update properties panel if object is being dragged
            if (transformControls.dragging) {
                updatePropertiesPanel();
            }
            
            // Update measurements for active projector
            updateMeasurements();
            
            // Update photometric analysis if enabled
            if (photometricMode) {
                updatePhotometric();
            }

            renderer.render(scene, camera);
        } catch (error) {
            console.error('‚ùå Error in animate():', error);
            console.error('Stack trace:', error.stack);
            // Continue animation even if there's an error
        }
    }

    
    // ========== MODERN INTERFACE FUNCTIONS ==========
    
    // Toggle collapsible panel
    window.togglePan = function(panelId) {
        const panel = document.getElementById(panelId);
        if (panel) {
            panel.classList.toggle('collapsed');
        }
    };
    
    // Switch navigation tabs
    window.switchTab = function(tabName) {
        console.log('üîÑ Switching to tab:', tabName);
        
        // Update active tab button
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.classList.remove('active');
            const tabText = tab.textContent.toLowerCase();
            if (tabText === tabName.toLowerCase()) {
                tab.classList.add('active');
            }
        });
        
        // Show/hide panels based on tab
        const allPanels = document.querySelectorAll('.collapsible-panel[data-tab]');
        let visibleCount = 0;
        let hiddenCount = 0;
        
        allPanels.forEach(panel => {
            const panelTab = panel.getAttribute('data-tab');
            
            if (tabName === 'setup' && panelTab === 'setup') {
                panel.style.display = 'block';
                visibleCount++;
            } else if (tabName === 'calibration' && panelTab === 'calibration') {
                panel.style.display = 'block';
                visibleCount++;
            } else if (tabName === 'export') {
                // Export tab: hide all panels for now, will add export panel later
                panel.style.display = 'none';
                hiddenCount++;
            } else {
                panel.style.display = 'none';
                hiddenCount++;
            }
        });
        
        console.log(`‚úÖ Tab switched: ${visibleCount} panels visible, ${hiddenCount} hidden`);
        
        // Show special message for Export tab
        if (tabName === 'export') {
            showExportTab();
        }
    };
    
    // Show Export tab content
    function showExportTab() {
        const sidebar = document.querySelector('.modern-sidebar-left');
        if (!sidebar) return;
        
        // Check if export panel already exists
        let exportPanel = document.getElementById('panel-export');
        if (!exportPanel) {
            // Create export panel dynamically
            exportPanel = document.createElement('div');
            exportPanel.id = 'panel-export';
            exportPanel.className = 'collapsible-panel';
            exportPanel.setAttribute('data-tab', 'export');
            exportPanel.innerHTML = `
                <div class="panel-header" onclick="togglePan('panel-export')">
                    <div class="panel-title">
                        <span class="panel-icon">üì§</span>
                        <span>Export</span>
                    </div>
                    <span class="panel-chevron">‚ñº</span>
                </div>
                <div class="panel-content" id="panel-export-content" style="display: block;">
                    <div style="padding: 16px; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 12px;">üì§</div>
                        <div style="color: #0d9488; font-size: 14px; font-weight: 600; margin-bottom: 8px;">Export Project</div>
                        <div style="color: #888; font-size: 11px; margin-bottom: 20px;">Save your configuration</div>
                        
                        <button class="btn-modern btn-modern-primary" style="width: 100%; margin-bottom: 8px;" onclick="toggleFloatingWindow('export-window')">
                            üìÑ Export PDF
                        </button>
                        
                        <button class="btn-modern btn-modern-secondary" style="width: 100%; margin-bottom: 8px;" onclick="renderViewportSnapshot()">
                            üì∑ Screenshot PNG
                        </button>
                        
                        <button class="btn-modern btn-modern-secondary" style="width: 100%;" onclick="alert('üíæ Save/Load JSON - Coming soon!')">
                            üíæ Save Project JSON
                        </button>
                    </div>
                </div>
            `;
            
            // Insert after search box
            const searchBox = sidebar.querySelector('.sidebar-header');
            if (searchBox) {
                searchBox.after(exportPanel);
            }
        } else {
            exportPanel.style.display = 'block';
        }
    }
    
    // Global search
    window.globalSearch = function(query) {
        query = query.toLowerCase();
        console.log('Searching for:', query);
        
        // TODO: Filter projectors, primitives, etc.
        // This will be implemented when we populate the panels
    };
    
    // Save project (placeholder)
    window.saveProject = function() {
        alert('üíæ Save functionality - coming soon!\n\nFor now, use Export PDF to save your configuration.');
    };
    
    // Update properties panel
    window.updatePropertiesPanel = function() {
        if (!document.querySelector('.modern-interface')) return;
        
        const selectionEl = document.getElementById('prop-selection');
        const modelEl = document.getElementById('prop-model');
        const positionEl = document.getElementById('prop-position');
        const rotationEl = document.getElementById('prop-rotation');
        const lumensEl = document.getElementById('prop-lumens');
        const lumensGroup = document.getElementById('prop-lumens-group');
        
        if (selectedObject) {
            const name = selectedObject.userData.name || 'Unknown';
            const type = selectedObject.userData.type || 'object';
            
            if (selectionEl) selectionEl.textContent = name;
            
            // Position
            if (positionEl) {
                const pos = selectedObject.position;
                positionEl.textContent = `X: ${pos.x.toFixed(2)} Y: ${pos.y.toFixed(2)} Z: ${pos.z.toFixed(2)}`;
            }
            
            // Rotation
            if (rotationEl) {
                const rot = selectedObject.rotation;
                const degX = (rot.x * 180 / Math.PI).toFixed(1);
                const degY = (rot.y * 180 / Math.PI).toFixed(1);
                const degZ = (rot.z * 180 / Math.PI).toFixed(1);
                rotationEl.textContent = `X: ${degX}¬∞ Y: ${degY}¬∞ Z: ${degZ}¬∞`;
            }
            
            // If projector
            if (type === 'projector' && selectedObject === activeProjector) {
                const model = selectedObject.userData.projectorModel || 'Unknown';
                if (modelEl) modelEl.textContent = model;
                
                // Lumens
                if (lumensEl && lumensGroup) {
                    const baseLumens = PROJECTOR_DATABASE[model]?.lumens || 0;
                    const multiplier = selectedObject.stackMultiplier || 1;
                    const totalLumens = baseLumens * multiplier;
                    
                    lumensEl.textContent = totalLumens.toLocaleString() + ' lm';
                    if (multiplier > 1) {
                        lumensEl.textContent += ` (Stack √ó${multiplier})`;
                    }
                    lumensGroup.style.display = 'block';
                }
            } else if (type === 'camera' && selectedObject.userData.cameraInstance) {
                // Camera properties
                const cam = selectedObject.userData.cameraInstance;
                if (modelEl) modelEl.textContent = `Camera (${cam.orthographic ? 'Ortho' : 'Perspective'})`;
                if (lumensGroup) lumensGroup.style.display = 'none';
                
                // Add camera controls in properties if not exist
                let cameraControls = document.getElementById('camera-controls');
                if (!cameraControls) {
                    cameraControls = document.createElement('div');
                    cameraControls.id = 'camera-controls';
                    cameraControls.style.cssText = 'margin-top: 16px; padding: 12px; background: rgba(13,148,136,0.05); border: 1px solid #0d9488; border-radius: 6px;';
                    cameraControls.innerHTML = `
                        <div style="font-size: 11px; font-weight: 600; color: #0d9488; margin-bottom: 12px;">üì∑ Camera Controls</div>
                        
                        <div style="margin-bottom: 12px;">
                            <label style="font-size: 10px; color: #888;">Focal Length (mm)</label>
                            <input type="number" id="cam-focal" value="35" min="10" max="200" style="width: 100%; padding: 6px; background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #fff;">
                        </div>
                        
                        <div style="margin-bottom: 12px;">
                            <label style="font-size: 10px; color: #888;">Roll (degrees)</label>
                            <input type="number" id="cam-roll" value="0" min="-180" max="180" style="width: 100%; padding: 6px; background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #fff;">
                        </div>
                        
                        <div style="margin-bottom: 12px;">
                            <label style="font-size: 10px; color: #888;">Target Position</label>
                            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 4px;">
                                <input type="number" id="cam-target-x" placeholder="X" step="0.1" style="padding: 6px; background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #fff; font-size: 10px;">
                                <input type="number" id="cam-target-y" placeholder="Y" step="0.1" style="padding: 6px; background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #fff; font-size: 10px;">
                                <input type="number" id="cam-target-z" placeholder="Z" step="0.1" style="padding: 6px; background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #fff; font-size: 10px;">
                            </div>
                        </div>
                        
                        <button onclick="toggleCameraOrthographic(selectedObject.userData.cameraInstance)" style="width: 100%; padding: 8px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #fff; cursor: pointer; font-size: 11px; margin-bottom: 8px;">
                            üî≤ Toggle Orthographic
                        </button>
                        
                        <button onclick="lookFromCamera(selectedObject.userData.cameraInstance)" style="width: 100%; padding: 8px; background: rgba(13,148,136,0.1); border: 1px solid #0d9488; border-radius: 4px; color: #0d9488; cursor: pointer; font-size: 11px; font-weight: 600;">
                            üëÅÔ∏è Look From Camera
                        </button>
                    `;
                    
                    // Find properties section and append
                    const propsSection = document.querySelector('.modern-sidebar-right');
                    if (propsSection) {
                        propsSection.appendChild(cameraControls);
                    }
                    
                    // Add event listeners
                    document.getElementById('cam-focal').oninput = (e) => {
                        if (selectedObject.userData.cameraInstance) {
                            updateCameraFocalLength(selectedObject.userData.cameraInstance, parseFloat(e.target.value));
                        }
                    };
                    
                    document.getElementById('cam-roll').oninput = (e) => {
                        if (selectedObject.userData.cameraInstance) {
                            updateCameraRoll(selectedObject.userData.cameraInstance, parseFloat(e.target.value));
                        }
                    };
                    
                    ['x', 'y', 'z'].forEach(axis => {
                        document.getElementById(`cam-target-${axis}`).onchange = () => {
                            if (selectedObject.userData.cameraInstance) {
                                const x = parseFloat(document.getElementById('cam-target-x').value) || 0;
                                const y = parseFloat(document.getElementById('cam-target-y').value) || 0;
                                const z = parseFloat(document.getElementById('cam-target-z').value) || 0;
                                updateCameraTarget(selectedObject.userData.cameraInstance, x, y, z);
                            }
                        };
                    });
                }
                
                // Update camera control values
                if (cameraControls) {
                    cameraControls.style.display = 'block';
                    document.getElementById('cam-focal').value = cam.focalLength;
                    document.getElementById('cam-roll').value = cam.roll;
                    document.getElementById('cam-target-x').value = cam.target.position.x.toFixed(2);
                    document.getElementById('cam-target-y').value = cam.target.position.y.toFixed(2);
                    document.getElementById('cam-target-z').value = cam.target.position.z.toFixed(2);
                }
            } else {
                if (modelEl) modelEl.textContent = type;
                if (lumensGroup) lumensGroup.style.display = 'none';
                const cameraControls = document.getElementById('camera-controls');
                if (cameraControls) cameraControls.style.display = 'none';
            }
        } else {
            if (selectionEl) selectionEl.textContent = 'None';
            if (modelEl) modelEl.textContent = '-';
            if (positionEl) positionEl.textContent = 'X: - Y: - Z: -';
            if (rotationEl) rotationEl.textContent = 'X: - Y: - Z: -';
            if (lumensGroup) lumensGroup.style.display = 'none';
        }
    };
    
    // Move canvas to modern viewport on init
    window.initModernInterface = function() {
        if (!document.querySelector('.modern-interface')) return;
        
        const canvas = renderer.domElement;
        const viewport = document.getElementById('modern-viewport');
        
        if (canvas && viewport) {
            viewport.appendChild(canvas);
            console.log('‚úÖ Canvas moved to modern viewport');
        }
        
        // Update projector count
        updateProjectorCount();
        populateProjectorsPanel();
        
        // Populate scene hierarchy (C4D style)
        populateSceneHierarchy();
        
        // Populate scene objects panel
        populateScenePanel();
        
        // Initialize with Setup tab active
        switchTab('setup');
    };
    
    // Update projector count badge
    window.updateProjectorCount = function() {
        const countEl = document.getElementById('projector-count');
        if (countEl) {
            const count = projectors.length;
            countEl.textContent = `(${count})`;
        }
    };
    
    // Populate scene objects panel
    window.populateScenePanel = function() {
        const panel = document.getElementById('panel-scene-content');
        if (!panel) return;
        
        panel.innerHTML = '';
        
        // Add scene objects (screens, primitives, etc.)
        projectedObjects.forEach(obj => {
            if (obj.userData && obj.userData.name) {
                const item = document.createElement('div');
                item.className = 'projector-card';
                item.style.cssText = 'padding:8px 12px; background:rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.1); border-radius:6px; margin-bottom:6px; cursor:pointer; font-size:12px;';
                item.textContent = obj.userData.name;
                item.onclick = () => selectObject(obj);
                panel.appendChild(item);
            }
        });
        
        if (projectedObjects.length === 0) {
            panel.innerHTML = '<p style="color:#666; font-size:11px; text-align:center; padding:20px 0;">No objects in scene</p>';
        }
        
        // Also populate right panel
        populateSceneHierarchy();
    };
    
    // Populate Scene Objects in RIGHT panel
    // Populate Scene Hierarchy (C4D Style) with parent-child relationships
    window.populateSceneHierarchy = function() {
        const hierarchy = document.getElementById('scene-hierarchy');
        if (!hierarchy) return;
        
        hierarchy.innerHTML = '';
        
        // Add header
        const header = document.createElement('div');
        header.className = 'hierarchy-header';
        header.innerHTML = `
            <div class="hierarchy-header-name">Name</div>
            <div style="text-align: center;">S</div>
            <div style="text-align: center;">V</div>
        `;
        hierarchy.appendChild(header);
        
        // Build hierarchy structure
        const items = [];
        
        // Add all scene objects first
        projectedObjects.forEach(obj => {
            if (obj.userData && obj.userData.name && !obj.userData.isProjector && !obj.userData.isTarget) {
                const item = {
                    object: obj,
                    name: obj.userData.name,
                    type: obj.userData.type || 'object',
                    icon: getObjectIcon(obj),
                    children: []
                };
                
                // Find locked projectors targeting this object
                projectors.forEach(proj => {
                    if (proj.targetLocked && proj.targetObject === obj) {
                        const projName = proj.config?.name || proj.modelId || 'Projector';
                        item.children.push({
                            object: proj.group || proj.mesh,
                            name: `${projName} #${proj.id}`,
                            type: 'projector',
                            icon: 'üìΩÔ∏è',
                            projector: proj,
                            isChild: true
                        });
                    }
                });
                
                items.push(item);
            }
        });
        
        // Add unlocked projectors (not children of any object)
        projectors.forEach(proj => {
            if (!proj.targetLocked || !proj.targetObject) {
                const projName = proj.config?.name || proj.modelId || 'Projector';
                items.push({
                    object: proj.group || proj.mesh,
                    name: `${projName} #${proj.id}`,
                    type: 'projector',
                    icon: 'üìΩÔ∏è',
                    projector: proj,
                    children: []
                });
            }
        });
        
        // Add cameras
        cameras.forEach(cam => {
            items.push({
                object: cam.group,
                name: cam.name,
                type: 'camera',
                icon: 'üì∑',
                camera: cam,
                children: []
            });
        });
        
        // Render hierarchy
        if (items.length === 0) {
            hierarchy.innerHTML += '<p style="color:#666; font-size:11px; text-align:center; padding:20px 0;">No objects in scene</p>';
            return;
        }
        
        items.forEach(item => {
            renderHierarchyItem(hierarchy, item, false);
            
            // Render children (locked projectors)
            item.children.forEach(child => {
                renderHierarchyItem(hierarchy, child, true);
            });
        });
    };
    
    // Solo system
    let soloedObjects = new Set();
    
    function toggleSolo(obj, projector) {
        const objId = obj.uuid;
        
        if (soloedObjects.has(objId)) {
            // Un-solo
            soloedObjects.delete(objId);
        } else {
            // Solo this object
            soloedObjects.add(objId);
        }
        
        // Update visibility based on solo state
        if (soloedObjects.size > 0) {
            // Solo mode active - hide everything except soloed
            projectedObjects.forEach(o => {
                if (!o.userData.isProjector && !o.userData.isTarget) {
                    o.visible = soloedObjects.has(o.uuid);
                }
            });
            
            projectors.forEach(proj => {
                const projObj = proj.group || proj.mesh;
                const isSoloed = soloedObjects.has(projObj.uuid);
                projObj.visible = isSoloed;
                if (proj.helper) proj.helper.visible = isSoloed;
                if (proj.shadowLight) proj.shadowLight.visible = isSoloed;
            });
        } else {
            // No solo - show all
            projectedObjects.forEach(o => {
                if (!o.userData.isProjector && !o.userData.isTarget) {
                    o.visible = true;
                }
            });
            
            projectors.forEach(proj => {
                const projObj = proj.group || proj.mesh;
                projObj.visible = true;
                if (proj.helper) proj.helper.visible = true;
                if (proj.shadowLight) proj.shadowLight.visible = true;
            });
        }
        
        // Update hierarchy UI
        populateSceneHierarchy();
        
        // Update solo button states
        document.querySelectorAll('.hierarchy-btn').forEach((btn, index) => {
            if (btn.textContent === 'S') {
                const item = getAllHierarchyItems()[Math.floor(index / 2)];
                if (item && soloedObjects.has(item.object.uuid)) {
                    btn.classList.add('solo-active');
                } else {
                    btn.classList.remove('solo-active');
                }
            }
        });
    }
    
    function getAllHierarchyItems() {
        // Helper to get all items for solo button update
        const items = [];
        projectedObjects.forEach(obj => {
            if (obj.userData && obj.userData.name && !obj.userData.isProjector && !obj.userData.isTarget) {
                items.push({ object: obj });
            }
        });
        projectors.forEach(proj => {
            items.push({ object: proj.group || proj.mesh });
        });
        return items;
    }
    
    function getObjectIcon(obj) {
        if (!obj.userData) return 'üì¶';
        const type = obj.userData.type;
        if (type === 'primitive') return 'üî∑';
        if (type === 'model') return 'üì¶';
        if (type === 'object') {
            const name = obj.userData.name.toLowerCase();
            if (name.includes('cube')) return 'üî≤';
            if (name.includes('sphere') || name.includes('sph√®re')) return '‚ö™';
            if (name.includes('cylinder') || name.includes('cylindre')) return '‚ö´';
            if (name.includes('plane') || name.includes('plan')) return '‚ñ≠';
            if (name.includes('cone') || name.includes('c√¥ne')) return 'üî∫';
            if (name.includes('torus') || name.includes('tore')) return '‚≠ï';
            if (name.includes('mannequin') || name.includes('human')) return 'üö∂';
        }
        return 'üì¶';
    }
    
    function renderHierarchyItem(container, item, isChild) {
        const div = document.createElement('div');
        div.className = 'hierarchy-item' + (isChild ? ' child' : '');
        
        // Column 1: Name (icon + text)
        const nameCol = document.createElement('div');
        nameCol.className = 'hierarchy-item-name';
        
        const icon = document.createElement('span');
        icon.className = 'hierarchy-item-icon';
        icon.textContent = item.icon;
        
        const text = document.createElement('span');
        text.className = 'hierarchy-item-text';
        text.textContent = item.name;
        
        nameCol.appendChild(icon);
        nameCol.appendChild(text);
        
        // Column 2: Solo button (S) OR Look From for cameras
        let col2Btn;
        if (item.type === 'camera' && item.camera) {
            // Camera: Show "Look From" button (eye icon)
            col2Btn = document.createElement('div');
            col2Btn.className = 'hierarchy-btn';
            col2Btn.textContent = 'üëÅÔ∏è';
            col2Btn.title = 'Look From Camera';
            col2Btn.onclick = (e) => {
                e.stopPropagation();
                lookFromCamera(item.camera);
            };
        } else {
            // Regular object/projector: Show Solo button
            col2Btn = document.createElement('div');
            col2Btn.className = 'hierarchy-btn';
            col2Btn.textContent = 'S';
            col2Btn.title = 'Solo';
            col2Btn.onclick = (e) => {
                e.stopPropagation();
                toggleSolo(item.object, item.projector);
            };
        }
        
        // Column 3: Visibility button (V)
        const visBtn = document.createElement('div');
        visBtn.className = 'hierarchy-btn';
        const isVisible = item.object.visible;
        visBtn.textContent = 'V';
        visBtn.title = 'Visibility';
        if (isVisible) {
            visBtn.classList.add('active');
        }
        visBtn.onclick = (e) => {
            e.stopPropagation();
            if (item.camera) {
                // Toggle camera helper visibility
                item.camera.helper.visible = !item.camera.helper.visible;
                item.camera.target.visible = !item.camera.target.visible;
                visBtn.classList.toggle('active');
            } else {
                toggleObjectVisibility(item.object, item.projector);
            }
        };
        
        div.appendChild(nameCol);
        div.appendChild(col2Btn);
        div.appendChild(visBtn);
        
        // Click to select
        div.onclick = () => {
            // Remove previous selection
            document.querySelectorAll('.hierarchy-item').forEach(el => el.classList.remove('selected'));
            div.classList.add('selected');
            
            if (item.projector) {
                setActiveProjector(item.projector);
            }
            selectObject(item.object);
        };
        
        // Double-click to rename
        div.ondblclick = (e) => {
            e.stopPropagation();
            renameObject(item.object, text, item.projector);
        };
        
        container.appendChild(div);
    }
    
    function renameObject(obj, textElement, projector) {
        const currentName = textElement.textContent;
        
        // Create input
        const input = document.createElement('input');
        input.type = 'text';
        input.value = currentName;
        input.style.cssText = `
            width: 100%;
            background: rgba(13, 148, 136, 0.2);
            border: 1px solid #0d9488;
            border-radius: 3px;
            color: #fff;
            font-size: 11px;
            padding: 2px 4px;
            outline: none;
        `;
        
        // Replace text with input
        textElement.replaceWith(input);
        input.focus();
        input.select();
        
        // Save on Enter or blur
        const save = () => {
            const newName = input.value.trim();
            if (newName && newName !== currentName) {
                // Update object name
                if (projector) {
                    projector.config.name = newName;
                } else {
                    obj.userData.name = newName;
                }
                console.log(`‚úèÔ∏è Renamed to: ${newName}`);
            }
            
            // Refresh hierarchy
            populateSceneHierarchy();
        };
        
        input.onblur = save;
        input.onkeydown = (e) => {
            if (e.key === 'Enter') {
                save();
            } else if (e.key === 'Escape') {
                populateSceneHierarchy();
            }
        };
    }
    
    function toggleObjectVisibility(obj, projector) {
        obj.visible = !obj.visible;
        
        // If it's a projector, also toggle helper and light
        if (projector) {
            if (projector.helper) projector.helper.visible = obj.visible;
            if (projector.shadowLight) projector.shadowLight.visible = obj.visible;
            if (projector.dummyProjectors) {
                projector.dummyProjectors.forEach(dummy => {
                    dummy.mesh.visible = obj.visible;
                    dummy.helper.visible = obj.visible;
                    if (dummy.light) dummy.light.visible = obj.visible;
                });
            }
        }
        
        populateSceneHierarchy();
    }
    
    // Keep old function for compatibility but redirect to new one
    window.populateSceneObjectsList = function() {
        populateSceneHierarchy();
    };
    
    // Populate projectors panel (modern UI)
    window.populateProjectorsPanel = function() {
        const panel = document.getElementById('panel-projectors-content');
        if (!panel) return;
        
        panel.innerHTML = '';
        
        if (projectors.length === 0) {
            panel.innerHTML = '<p style="color:#666; font-size:11px; text-align:center; padding:20px 0;">No projectors yet.<br>Click "+ New Projector" to add one.</p>';
            return;
        }
        
        // Create card for each projector
        projectors.forEach((proj, index) => {
            const card = document.createElement('div');
            card.className = 'projector-card-modern';
            card.style.cssText = `
                padding: 12px;
                background: ${proj === activeProjector ? 'rgba(13,148,136,0.15)' : 'rgba(255,255,255,0.03)'};
                border: 1px solid ${proj === activeProjector ? '#0d9488' : 'rgba(255,255,255,0.1)'};
                border-radius: 8px;
                margin-bottom: 8px;
                cursor: pointer;
                transition: all 0.2s;
            `;
            
            const model = proj.projectorModel || 'Unknown';
            const lumens = PROJECTOR_DATABASE[model]?.lumens || 0;
            const multiplier = proj.stackMultiplier || 1;
            const totalLumens = lumens * multiplier;
            
            card.innerHTML = `
                <div style="font-size: 13px; font-weight: 600; color: #e0e0e0; margin-bottom: 4px;">
                    ${model} #${proj.id}
                </div>
                <div style="font-size: 11px; color: #888;">
                    ${totalLumens.toLocaleString()} lm${multiplier > 1 ? ' ‚Ä¢ Stack √ó' + multiplier : ''}
                </div>
            `;
            
            card.onclick = () => {
                setActiveProjector(proj);
                selectObject(proj.mesh || proj.group);
                populateProjectorsPanel(); // Refresh to update active state
            };
            
            card.onmouseenter = () => {
                if (proj !== activeProjector) {
                    card.style.background = 'rgba(255,255,255,0.05)';
                    card.style.borderColor = '#0d9488';
                }
            };
            
            card.onmouseleave = () => {
                if (proj !== activeProjector) {
                    card.style.background = 'rgba(255,255,255,0.03)';
                    card.style.borderColor = 'rgba(255,255,255,0.1)';
                }
            };
            
            panel.appendChild(card);
        });
    };
    
    window.addEventListener('DOMContentLoaded', init);

    // ========== SCENE HIERARCHY FUNCTIONS ==========
    function updateSceneHierarchy() {
        const projectorsContainer = document.getElementById('hierarchy-projectors');
        const objectsContainer = document.getElementById('hierarchy-objects');
        
        if (!projectorsContainer || !objectsContainer) return;
        
        // Update projectors list
        if (projectors.length === 0) {
            projectorsContainer.innerHTML = '<div class="hierarchy-empty">Aucun projecteur</div>';
        } else {
            projectorsContainer.innerHTML = projectors.map(proj => {
                const isSelected = selectedObject && selectedObject.userData.projectorInstance === proj;
                const isActive = activeProjector === proj;
                const isVisible = proj.group ? proj.group.visible : true;
                return `
                    <div class="hierarchy-item projector ${isSelected ? 'selected' : ''}" 
                         style="${isActive ? 'border-color:#0d9488;' : ''}">
                        <span class="hierarchy-item-icon" onclick="selectProjectorFromHierarchy(${proj.id})">üìΩÔ∏è</span>
                        <span class="hierarchy-item-name" onclick="selectProjectorFromHierarchy(${proj.id})">${proj.config.name} #${proj.id}</span>
                        <div class="hierarchy-item-actions">
                            <button class="hierarchy-action-btn ${!isVisible ? 'hidden-state' : ''}" 
                                    onclick="event.stopPropagation(); toggleProjectorVisibility(${proj.id})" 
                                    title="${isVisible ? 'Masquer' : 'Afficher'}">
                                ${isVisible ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è'}
                            </button>
                            <button class="hierarchy-action-btn danger" 
                                    onclick="event.stopPropagation(); deleteProjector(${proj.id})" 
                                    title="Supprimer">
                                üóëÔ∏è
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Update objects list
        const sceneObjects = selectableObjects.filter(obj => 
            !obj.userData.isProjector && !obj.userData.isTarget
        );
        
        if (sceneObjects.length === 0) {
            objectsContainer.innerHTML = '<div class="hierarchy-empty">Aucun objet</div>';
        } else {
            objectsContainer.innerHTML = sceneObjects.map((obj, idx) => {
                const isSelected = selectedObject === obj;
                const name = obj.userData.name || obj.name || `Objet ${idx + 1}`;
                const isVisible = obj.visible;
                let icon = 'üì¶';
                if (obj.userData.type === 'primitive') icon = 'üî∑';
                if (obj.userData.type === 'wall') icon = 'üß±';
                if (obj.userData.type === 'human') icon = 'üßç';
                if (obj.userData.fileName) icon = 'üìÅ';
                
                return `
                    <div class="hierarchy-item object ${isSelected ? 'selected' : ''}">
                        <span class="hierarchy-item-icon" onclick="selectObjectFromHierarchy(${idx})">${icon}</span>
                        <span class="hierarchy-item-name" onclick="selectObjectFromHierarchy(${idx})">${name}</span>
                        <div class="hierarchy-item-actions">
                            <button class="hierarchy-action-btn ${!isVisible ? 'hidden-state' : ''}" 
                                    onclick="event.stopPropagation(); toggleObjectVisibility(${idx})" 
                                    title="${isVisible ? 'Masquer' : 'Afficher'}">
                                ${isVisible ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è'}
                            </button>
                            <button class="hierarchy-action-btn danger" 
                                    onclick="event.stopPropagation(); deleteObject(${idx})" 
                                    title="Supprimer">
                                üóëÔ∏è
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Update scene info
        const projCountEl = document.getElementById('scene-projector-count');
        const objCountEl = document.getElementById('scene-object-count');
        if (projCountEl) projCountEl.textContent = projectors.length;
        if (objCountEl) objCountEl.textContent = sceneObjects.length;
        
        // Update controls panel visibility
        updateControlsPanelVisibility();
    }
    
    // Toggle projector visibility
    window.toggleProjectorVisibility = function(projId) {
        const proj = projectors.find(p => p.id === projId);
        if (proj && proj.group) {
            proj.group.visible = !proj.group.visible;
            if (proj.frustumHelper) proj.frustumHelper.visible = proj.group.visible;
            if (proj.target) proj.target.visible = proj.group.visible;
            
            // Update projectorActive uniform to turn off projection light
            const projIndex = projectors.indexOf(proj);
            if (projIndex >= 0 && projIndex < 4) {
                const isActive = proj.group.visible;
                projectedObjects.forEach(obj => {
                    if (obj.material?.uniforms) {
                        const u = obj.material.uniforms;
                        if (u[`projectorActive${projIndex}`]) {
                            u[`projectorActive${projIndex}`].value = isActive;
                        }
                        obj.material.needsUpdate = true;
                    }
                });
            }
            
            updateSceneHierarchy();
        }
    };
    
    // Toggle object visibility
    window.toggleObjectVisibility = function(idx) {
        const sceneObjects = selectableObjects.filter(obj => 
            !obj.userData.isProjector && !obj.userData.isTarget
        );
        if (sceneObjects[idx]) {
            sceneObjects[idx].visible = !sceneObjects[idx].visible;
            updateSceneHierarchy();
        }
    };
    
    // Delete projector
    window.deleteProjector = function(projId) {
        console.log('üóëÔ∏è DELETE PROJECTOR CALLED:', projId);
        const projIdx = projectors.findIndex(p => p.id === projId);
        if (projIdx === -1) {
            console.error('‚ùå Projector not found');
            return;
        }
        
        const proj = projectors[projIdx];
        console.log('üì¶ Deleting projector:', proj);
        
        // Record for undo before deletion
        pushHistory({
            type: 'delete_projector',
            projectorData: cloneProjectorState(proj),
            projectorId: proj.id
        });
        
        // Remove from scene - COMPLETE CLEANUP
        if (proj.group) {
            console.log('‚úÖ Removing group');
            scene.remove(proj.group);
        }
        if (proj.helper) {
            console.log('‚úÖ Removing helper (frustum)');
            scene.remove(proj.helper);
        } else {
            console.warn('‚ö†Ô∏è No helper found');
        }
        if (proj.frustumHelper) {
            console.log('‚úÖ Removing frustumHelper');
            scene.remove(proj.frustumHelper);
        }
        if (proj.target) {
            console.log('‚úÖ Removing target');
            scene.remove(proj.target);
        }
        if (proj.shadowLight) {
            console.log('‚úÖ Removing shadowLight');
            scene.remove(proj.shadowLight);
            if (proj.shadowLight.target) scene.remove(proj.shadowLight.target);
        }
        
        // Remove measurement sprites
        if (proj.spriteWidth) {
            console.log('‚úÖ Removing spriteWidth');
            scene.remove(proj.spriteWidth);
        }
        if (proj.spriteHeight) {
            console.log('‚úÖ Removing spriteHeight');
            scene.remove(proj.spriteHeight);
        }
        if (proj.spriteTR) {
            console.log('‚úÖ Removing spriteTR');
            scene.remove(proj.spriteTR);
        }
        if (proj.spriteInfo) {
            console.log('‚úÖ Removing spriteInfo');
            scene.remove(proj.spriteInfo);
        }
        
        if (proj.mesh) {
            const meshIdx = selectableObjects.indexOf(proj.mesh);
            if (meshIdx > -1) selectableObjects.splice(meshIdx, 1);
        }
        
        // Dispose render targets
        if (proj.depthRenderTarget) {
            proj.depthRenderTarget.dispose();
        }
        
        // Remove from projectors array
        projectors.splice(projIdx, 1);
        console.log('‚úÖ Projector deleted. Remaining:', projectors.length);
        
        // Update active projector
        if (activeProjector === proj) {
            if (projectors.length > 0) {
                setActiveProjector(projectors[0]);
                selectObject(projectors[0].mesh);
            } else {
                activeProjector = null;
                selectedObject = null;
                transformControls.detach();
            }
        }
        
        // Deselect if this was selected
        if (selectedObject === proj.mesh) {
            selectedObject = null;
            transformControls.detach();
        }
        
        updateSceneHierarchy();
        updateProjectionMatrix();
    };
    
    // Delete object
    window.deleteObject = function(idx) {
        const sceneObjects = selectableObjects.filter(obj => 
            !obj.userData.isProjector && !obj.userData.isTarget
        );
        
        if (!sceneObjects[idx]) return;
        
        const obj = sceneObjects[idx];
        
        // Record for undo before deletion
        pushHistory({
            type: 'delete_object',
            object: obj,
            objectType: obj.userData?.type || 'object'
        });
        
        // Remove from scene
        scene.remove(obj);
        
        // Remove from selectableObjects
        const mainIdx = selectableObjects.indexOf(obj);
        if (mainIdx > -1) selectableObjects.splice(mainIdx, 1);
        
        // Remove from projectedObjects if present
        const projIdx = projectedObjects.indexOf(obj);
        if (projIdx > -1) projectedObjects.splice(projIdx, 1);
        
        // Deselect if this was selected
        if (selectedObject === obj) {
            selectedObject = null;
            transformControls.detach();
        }
        
        updateSceneHierarchy();
    };
    
    window.selectProjectorFromHierarchy = function(projId) {
        const proj = projectors.find(p => p.id === projId);
        if (proj) {
            setActiveProjector(proj);
            selectObject(proj.mesh);
            updateSceneHierarchy();
        }
    };
    
    window.selectObjectFromHierarchy = function(idx) {
        const sceneObjects = selectableObjects.filter(obj => 
            !obj.userData.isProjector && !obj.userData.isTarget
        );
        if (sceneObjects[idx]) {
            selectObject(sceneObjects[idx]);
            updateSceneHierarchy();
        }
    };
    
    function updateControlsPanelVisibility() {
        const controlsPanel = document.getElementById('controls');
        const noProjectorMsg = document.getElementById('no-projector-msg');
        
        if (projectors.length === 0) {
            if (controlsPanel) controlsPanel.classList.add('hidden');
            if (noProjectorMsg) noProjectorMsg.style.display = 'block';
        } else {
            if (controlsPanel) controlsPanel.classList.remove('hidden');
            if (noProjectorMsg) noProjectorMsg.style.display = 'none';
        }
    }

    // ========== CALCULATEUR ==========
    let wsUnit = 'meter';
    let wsMode = 'landscape'; // landscape, portrait, square
    
    // Open mode selection modal first
    window.openWidescreenCalculator = function() {
        document.getElementById('widescreen-mode-modal').classList.add('show');
    };
    
    window.closeWidescreenModeModal = function() {
        document.getElementById('widescreen-mode-modal').classList.remove('show');
    };
    
    window.openWidescreenModeModal = function() {
        document.getElementById('widescreen-mode-modal').classList.add('show');
    };
    
    // Select mode and open calculator
    window.selectWSMode = function(mode) {
        wsMode = mode;
        document.getElementById('widescreen-mode-modal').classList.remove('show');
        
        // Update mode display
        const modeDisplay = document.getElementById('ws-mode-display');
        const matrixModeLabel = document.getElementById('ws-matrix-mode-label');
        if (modeDisplay) modeDisplay.textContent = mode.toUpperCase();
        if (matrixModeLabel) matrixModeLabel.textContent = mode.toUpperCase();
        
        // Configure UI based on mode
        configureWSMode(mode);
        
        document.getElementById('widescreen-modal').classList.add('show');
        calculateWS();
    };
    
    function configureWSMode(mode) {
        const projHGroup = document.getElementById('ws-proj-h-group');
        const projVGroup = document.getElementById('ws-proj-v-group');
        const projHLabel = document.getElementById('ws-proj-h-label');
        const projVLabel = document.getElementById('ws-proj-v-label');
        const overlapLabel = document.getElementById('ws-overlap-label');
        const verticalRow = document.getElementById('ws-vertical-row');
        const squareSelector = document.getElementById('ws-square-selector');
        const projH = document.getElementById('ws-proj-h');
        const projV = document.getElementById('ws-proj-v');
        const overlap = document.getElementById('ws-overlap');
        const overlapV = document.getElementById('ws-overlap-v');
        
        // Reset visibility
        if (verticalRow) verticalRow.style.display = '';
        if (squareSelector) squareSelector.style.display = 'none';
        if (projHGroup) projHGroup.style.display = '';
        
        switch(mode) {
            case 'landscape':
                // Horizontal dominant layout: can have multiple rows but horizontal is primary
                if (projHLabel) projHLabel.textContent = 'N. Proj. Horizontal';
                if (projVLabel) projVLabel.textContent = 'N. Proj. Vertical';
                if (overlapLabel) overlapLabel.textContent = 'Overlap H (px)';
                projH.value = 3;
                projH.min = 1;
                projH.max = 20;
                projH.disabled = false;
                projV.value = 2;
                projV.min = 1;
                projV.max = 20;
                projV.disabled = false;
                overlap.value = 600;
                overlap.disabled = false;
                overlapV.value = 400;
                overlapV.disabled = false;
                break;
                
            case 'portrait':
                // Vertical dominant layout: can have multiple columns but vertical is primary
                if (projHLabel) projHLabel.textContent = 'N. Proj. Horizontal';
                if (projVLabel) projVLabel.textContent = 'N. Proj. Vertical';
                if (overlapLabel) overlapLabel.textContent = 'Overlap H (px)';
                projH.value = 2;
                projH.min = 1;
                projH.max = 20;
                projH.disabled = false;
                projV.value = 3;
                projV.min = 1;
                projV.max = 20;
                projV.disabled = false;
                overlap.value = 400;
                overlap.disabled = false;
                overlapV.value = 600;
                overlapV.disabled = false;
                break;
                
            case 'square':
                // Square layout: projH = projV, controlled by selector
                if (verticalRow) verticalRow.style.display = 'none';
                if (squareSelector) squareSelector.style.display = 'block';
                if (projHGroup) projHGroup.style.display = 'none';
                projH.value = 2;
                projV.value = 2;
                projH.disabled = true;
                projV.disabled = true;
                overlap.value = 400;
                overlap.disabled = false;
                overlapV.value = 400;
                overlapV.disabled = false;
                setSquareConfig();
                break;
        }
    }
    
    window.setSquareConfig = function() {
        const config = document.getElementById('ws-square-config').value;
        const [h, v] = config.split('x').map(Number);
        document.getElementById('ws-proj-h').value = h;
        document.getElementById('ws-proj-v').value = v;
        calculateWS();
    };
    
    window.closeWidescreenCalculator = function() {
        document.getElementById('widescreen-modal').classList.remove('show');
        // Re-enable all inputs
        document.getElementById('ws-proj-h').disabled = false;
        document.getElementById('ws-proj-v').disabled = false;
        document.getElementById('ws-overlap').disabled = false;
        document.getElementById('ws-overlap-v').disabled = false;
    };
    
    window.setWSUnit = function(unit) {
        wsUnit = unit;
        document.getElementById('ws-unit-meter').classList.toggle('active', unit === 'meter');
        document.getElementById('ws-unit-inch').classList.toggle('active', unit === 'inch');
        
        // Update unit labels
        document.querySelectorAll('.ws-unit').forEach(el => {
            el.textContent = unit === 'meter' ? 'm' : 'in';
        });
        
        calculateWS();
    };
    
    window.calculateWS = function() {
        const autoMode = document.getElementById('ws-auto-mode').checked;
        const resolution = document.getElementById('ws-resolution').value.split('x').map(Number);
        const resW = resolution[0];
        const resH = resolution[1];
        const screenW = parseFloat(document.getElementById('ws-screen-w').value) || 18;
        const screenH = parseFloat(document.getElementById('ws-screen-h').value) || 6;
        const lensFactor = parseFloat(document.getElementById('ws-lens-factor').value) || 1.36;
        const lumens = parseInt(document.getElementById('ws-lumens').value) || 20000;
        
        let projH, projV, overlapH, overlapV;
        
        if (autoMode) {
            // AUTO MODE: Calculate optimal projector count and overlap based on mode
            const optimalOverlapPercent = 0.20; // 20% overlap
            const optimalPixelSize = 5; // mm
            const optimalProjWidth = (resW * optimalPixelSize) / 1000; // meters
            const optimalProjHeight = (resH * optimalPixelSize) / 1000; // meters
            const projAspect = resW / resH;
            
            switch(wsMode) {
                case 'landscape':
                    // Calculate both horizontal and vertical projectors needed (horizontal dominant)
                    projH = Math.max(1, Math.ceil(screenW / (optimalProjWidth * (1 - optimalOverlapPercent / 2))));
                    projV = Math.max(1, Math.ceil(screenH / (optimalProjHeight * (1 - optimalOverlapPercent / 2))));
                    overlapH = projH > 1 ? Math.round(resW * optimalOverlapPercent) : 0;
                    overlapV = projV > 1 ? Math.round(resH * optimalOverlapPercent) : 0;
                    break;
                    
                case 'portrait':
                    // Calculate both horizontal and vertical projectors needed (vertical dominant)
                    projH = Math.max(1, Math.ceil(screenW / (optimalProjWidth * (1 - optimalOverlapPercent / 2))));
                    projV = Math.max(1, Math.ceil(screenH / (optimalProjHeight * (1 - optimalOverlapPercent / 2))));
                    overlapH = projH > 1 ? Math.round(resW * optimalOverlapPercent) : 0;
                    overlapV = projV > 1 ? Math.round(resH * optimalOverlapPercent) : 0;
                    break;
                    
                case 'square':
                    // Calculate square grid (equal H and V)
                    const avgDim = Math.max(screenW, screenH);
                    const projCount = Math.max(2, Math.ceil(avgDim / (optimalProjWidth * (1 - optimalOverlapPercent / 2))));
                    // Round to even number for square mode
                    projH = projV = projCount % 2 === 0 ? projCount : projCount + 1;
                    overlapH = projH > 1 ? Math.round(resW * optimalOverlapPercent) : 0;
                    overlapV = projV > 1 ? Math.round(resH * optimalOverlapPercent) : 0;
                    break;
            }
            
            // Update UI with calculated values
            document.getElementById('ws-proj-h').value = projH;
            document.getElementById('ws-proj-v').value = projV;
            document.getElementById('ws-overlap').value = overlapH;
            document.getElementById('ws-overlap-v').value = overlapV;
            
            // Update square selector if in square mode
            if (wsMode === 'square') {
                const squareConfig = document.getElementById('ws-square-config');
                if (squareConfig) {
                    const configVal = `${projH}x${projV}`;
                    // Find matching option or set to 2x2
                    const options = Array.from(squareConfig.options).map(o => o.value);
                    if (options.includes(configVal)) {
                        squareConfig.value = configVal;
                    }
                }
            }
        } else {
            projH = parseInt(document.getElementById('ws-proj-h').value) || 1;
            projV = parseInt(document.getElementById('ws-proj-v').value) || 1;
            overlapH = parseInt(document.getElementById('ws-overlap').value) || 0;
            overlapV = parseInt(document.getElementById('ws-overlap-v').value) || 0;
            
            // Enforce mode constraints - only square mode requires equal H/V
            if (wsMode === 'square') {
                projV = projH;
            }
            // landscape and portrait modes now allow free H/V configuration
        }
        
        // Calculate total resolution
        const totalResW = (projH * resW) - ((projH - 1) * overlapH);
        const totalResV = (projV * resH) - ((projV - 1) * overlapV);
        
        // Calculate screen ratio
        const screenRatio = screenW / screenH;
        document.getElementById('ws-screen-ratio').value = screenRatio.toFixed(2);
        
        // Calculate pixel size
        const pixelSize = (screenW * 1000) / totalResW; // in mm
        
        // Recalculate actual projector image width based on resolution
        const singleProjW = (resW / totalResW) * screenW;
        const singleProjH = (resH / totalResV) * screenH;
        
        // Calculate throw distance
        const throwDistance = singleProjW * lensFactor;
        
        // Calculate lux
        const totalArea = screenW * screenH;
        const totalLumens = lumens * projH * projV;
        const lux = totalLumens / totalArea;
        
        // Calculate lens axis (center of each projector)
        const lensAxisX = singleProjW / 2;
        const lensAxisY = singleProjH / 2;
        
        // Calculate lost image (overlap area)
        const overlapAreaH = projH > 1 ? (overlapH / resW) * singleProjW * singleProjH * (projH - 1) : 0;
        const overlapAreaV = projV > 1 ? (overlapV / resH) * singleProjH * screenW * (projV - 1) : 0;
        const lostImage = overlapAreaH + overlapAreaV;
        
        // Get projector placement parameters
        const projHeight = parseFloat(document.getElementById('ws-proj-height').value) || 0;
        const projDistance = parseFloat(document.getElementById('ws-proj-distance').value) || throwDistance;
        const screenZ = -projDistance;
        
        // Update UI
        const unit = wsUnit === 'meter' ? 'm' : 'in';
        const factor = wsUnit === 'inch' ? 39.3701 : 1;
        
        document.getElementById('ws-throw-calc').value = (throwDistance * factor).toFixed(2) + ' ' + unit;
        document.getElementById('ws-res-total').textContent = `${totalResW} x ${totalResV} px`;
        document.getElementById('ws-pixel-size').textContent = pixelSize.toFixed(2) + ' mm';
        document.getElementById('ws-lost-image').textContent = (lostImage * factor * factor).toFixed(2) + ' ' + unit + '¬≤';
        document.getElementById('ws-total-size').textContent = `${(screenW * factor).toFixed(2)} x ${(screenH * factor).toFixed(2)} ${unit}`;
        document.getElementById('ws-util-size').textContent = `${(screenW * factor).toFixed(2)} x ${(screenH * factor).toFixed(2)} ${unit}`;
        document.getElementById('ws-lens-axis').textContent = `x: ${(lensAxisX * factor).toFixed(2)} y: ${(lensAxisY * factor).toFixed(2)} ${unit}`;
        document.getElementById('ws-lux').textContent = lux.toFixed(2);
        document.getElementById('ws-screen-z').value = (screenZ * factor).toFixed(2) + ' ' + unit;
        
        // Store calculated values for blueprint/patterns (including total resolution)
        window.wsCalculatedData = {
            projH, projV, resW, resH, overlapH, overlapV,
            screenW, screenH, singleProjW, singleProjH,
            totalResW, totalResV, throwDistance, lux, pixelSize,
            lensFactor, lumens, wsMode, projHeight, projDistance
        };
    };
    
    window.applyWSCalculation = function() {
        const projH = parseInt(document.getElementById('ws-proj-h').value) || 1;
        const projV = parseInt(document.getElementById('ws-proj-v').value) || 1;
        const screenW = parseFloat(document.getElementById('ws-screen-w').value) || 18;
        const screenH = parseFloat(document.getElementById('ws-screen-h').value) || 6;
        const overlapH = parseInt(document.getElementById('ws-overlap').value) || 0;
        const overlapV = parseInt(document.getElementById('ws-overlap-v').value) || 0;
        const resolution = document.getElementById('ws-resolution').value.split('x').map(Number);
        const resW = resolution[0];
        const resH = resolution[1];
        
        // Get projector placement parameters
        const projectorHeight = parseFloat(document.getElementById('ws-proj-height').value) || 0;
        const projDistance = parseFloat(document.getElementById('ws-proj-distance').value) || 12;
        const screenZ = -projDistance;
        
        // Calculate soft edge percentages from overlap
        const softEdgePercentH = Math.round((overlapH / resW) * 100);
        const softEdgePercentV = Math.round((overlapV / resH) * 100);
        
        // Create projectors in grid
        const totalProj = projH * projV;
        const projWidth = screenW / projH;
        const projHeightDim = screenH / projV;
        
        // Create a wall (screen) at the target position
        addWall();
        
        // Get the wall and position it at screenZ
        const walls = selectableObjects.filter(o => o.userData.type === 'wall');
        if (walls.length > 0) {
            const wall = walls[walls.length - 1];
            wall.scale.set(screenW / 10, screenH / 5, 1);
            // Position wall at screenZ, centered vertically at half screen height
            wall.position.set(0, screenH / 2, screenZ);
            wall.userData.name = '√âcran Calculateur';
        }
        
        // Calculate target center position on screen
        const screenCenterY = screenH / 2;
        
        // Create projectors
        for (let v = 0; v < projV; v++) {
            for (let h = 0; h < projH; h++) {
                // Calculate projector position to cover screen zone
                // X position: spread projectors horizontally
                const xOffset = (h - (projH - 1) / 2) * projWidth * 0.8;
                // Y position: projectors at specified height
                const yPos = projectorHeight;
                
                // Calculate target position on the screen (wall)
                const targetX = (h - (projH - 1) / 2) * (projWidth - (overlapH / resW) * projWidth);
                const targetY = screenCenterY + (v - (projV - 1) / 2) * (projHeightDim - (overlapV / resH) * projHeightDim);
                
                const instance = createProjectorInstance('PT-RQ25K');
                instance.targetLocked = false;
                instance.userMovedTarget = false;
                
                // Set soft edge for overlap
                if (softEdgePercentH > 0 || softEdgePercentV > 0) {
                    instance.softEdgeL = h > 0 ? softEdgePercentH : 0;
                    instance.softEdgeR = h < projH - 1 ? softEdgePercentH : 0;
                    instance.softEdgeT = v > 0 ? softEdgePercentV : 0;
                    instance.softEdgeB = v < projV - 1 ? softEdgePercentV : 0;
                }
                
                // Position projector at specified height and Z=0
                const spawnPos = new THREE.Vector3(xOffset, yPos, 0);
                createProjectorObjects(instance, spawnPos);
                projectors.push(instance);
                
                // Point target at the correct position on the screen
                instance.target.position.set(targetX, targetY, screenZ);
                instance.projDistance = projDistance;
                instance.targetLocked = true;
                instance.userMovedTarget = true;
            }
        }
        
        // Set first projector as active
        if (projectors.length > 0) {
            setActiveProjector(projectors[projectors.length - totalProj]);
            selectObject(projectors[projectors.length - totalProj].mesh);
        }
        
        updateSceneHierarchy();
        closeWidescreenCalculator();
        
        const avgSoftEdge = Math.max(softEdgePercentH, softEdgePercentV);
        alert(`${totalProj} projecteur(s) cr√©√©(s) avec ${avgSoftEdge}% de soft edge pour le recouvrement.`);
    };

    // ========== OVERRIDE FUNCTIONS TO UPDATE HIERARCHY ==========
    // Store original functions
    const originalSelectObject = selectObject;
    selectObject = function(obj) {
        originalSelectObject(obj);
        updateSceneHierarchy();
    };
    
    // Call updateSceneHierarchy after init
    const originalInit = init;
    init = function() {
        originalInit();
        updateSceneHierarchy();
    };

    // ========== BLUEPRINT FUNCTIONS ==========
    window.openBlueprintModal = function() {
        document.getElementById('blueprint-modal').classList.add('show');
        generateBlueprint();
    };
    
    window.closeBlueprintModal = function() {
        document.getElementById('blueprint-modal').classList.remove('show');
    };
    
    function generateBlueprint() {
        const canvas = document.getElementById('blueprint-canvas');
        const ctx = canvas.getContext('2d');
        const data = window.wsCalculatedData || {};
        
        const { projH = 2, projV = 1, screenW = 18, screenH = 6, singleProjW = 9, singleProjH = 6,
                overlapH = 0, overlapV = 0, resW = 1920, resH = 1080, throwDistance = 12,
                totalResW = 3240, totalResV = 1080, lux = 500, pixelSize = 5.5 } = data;
        
        // Clear canvas with blueprint background
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw grid
        ctx.strokeStyle = '#e0e8f0';
        ctx.lineWidth = 0.5;
        for (let x = 0; x < canvas.width; x += 20) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
        }
        for (let y = 0; y < canvas.height; y += 20) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }
        
        // Title
        ctx.fillStyle = '#1a365d';
        ctx.font = 'bold 24px Arial';
        ctx.fillText('BLUEPRINT - Multi-Projector Setup', 40, 50);
        
        ctx.font = '12px Arial';
        ctx.fillStyle = '#4a5568';
        ctx.fillText(`Date: ${new Date().toLocaleDateString()}`, 40, 70);
        
        // Screen outline
        const padding = 100;
        const maxW = canvas.width - padding * 2 - 300;
        const maxH = canvas.height - padding * 2 - 150;
        const scale = Math.min(maxW / screenW, maxH / screenH);
        
        const drawW = screenW * scale;
        const drawH = screenH * scale;
        const startX = padding;
        const startY = 120;
        
        // Screen border
        ctx.strokeStyle = '#1a365d';
        ctx.lineWidth = 3;
        ctx.strokeRect(startX, startY, drawW, drawH);
        
        // Screen dimensions
        ctx.fillStyle = '#1a365d';
        ctx.font = 'bold 14px Arial';
        ctx.fillText(`${screenW.toFixed(2)} m`, startX + drawW / 2 - 30, startY - 10);
        
        ctx.save();
        ctx.translate(startX - 10, startY + drawH / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText(`${screenH.toFixed(2)} m`, -30, 0);
        ctx.restore();
        
        // Draw projector zones
        const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#dfe6e9', '#fd79a8', '#a29bfe'];
        const projZoneW = drawW / projH;
        const projZoneH = drawH / projV;
        const overlapWDraw = (overlapH / resW) * projZoneW;
        const overlapHDraw = (overlapV / resH) * projZoneH;
        
        let projNum = 1;
        for (let v = 0; v < projV; v++) {
            for (let h = 0; h < projH; h++) {
                const x = startX + h * (projZoneW - (h > 0 ? overlapWDraw : 0));
                const y = startY + v * (projZoneH - (v > 0 ? overlapHDraw : 0));
                
                // Fill projector zone
                ctx.fillStyle = colors[(projNum - 1) % colors.length] + '40';
                ctx.fillRect(x, y, projZoneW, projZoneH);
                
                // Border
                ctx.strokeStyle = colors[(projNum - 1) % colors.length];
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, projZoneW, projZoneH);
                
                // Number circle
                const cx = x + projZoneW / 2;
                const cy = y + projZoneH / 2;
                ctx.beginPath();
                ctx.arc(cx, cy, 25, 0, Math.PI * 2);
                ctx.fillStyle = colors[(projNum - 1) % colors.length];
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(projNum.toString(), cx, cy);
                ctx.textAlign = 'left';
                ctx.textBaseline = 'alphabetic';
                
                projNum++;
            }
        }
        
        // Draw overlap zones (darker)
        if (overlapH > 0 && projH > 1) {
            ctx.fillStyle = 'rgba(255, 193, 7, 0.4)';
            for (let h = 1; h < projH; h++) {
                const x = startX + h * projZoneW - h * overlapWDraw - overlapWDraw;
                ctx.fillRect(x, startY, overlapWDraw * 2, drawH);
            }
        }
        
        // Info panel
        const infoX = startX + drawW + 40;
        const infoY = startY;
        
        ctx.fillStyle = '#f7fafc';
        ctx.fillRect(infoX, infoY, 240, 400);
        ctx.strokeStyle = '#e2e8f0';
        ctx.lineWidth = 1;
        ctx.strokeRect(infoX, infoY, 240, 400);
        
        ctx.fillStyle = '#1a365d';
        ctx.font = 'bold 14px Arial';
        ctx.fillText('SPECIFICATIONS', infoX + 10, infoY + 25);
        
        ctx.font = '11px Arial';
        ctx.fillStyle = '#4a5568';
        let lineY = infoY + 50;
        const lineH = 22;
        
        const specs = [
            ['Projecteurs:', `${projH} x ${projV} = ${projH * projV}`],
            ['√âcran:', `${screenW.toFixed(2)} x ${screenH.toFixed(2)} m`],
            ['R√©solution:', `${totalResW} x ${totalResV} px`],
            ['Taille Pixel:', `${pixelSize.toFixed(2)} mm`],
            ['Overlap H:', `${overlapH} px (${((overlapH/resW)*100).toFixed(0)}%)`],
            ['Overlap V:', `${overlapV} px (${((overlapV/resH)*100).toFixed(0)}%)`],
            ['Throw Distance:', `${throwDistance.toFixed(2)} m`],
            ['Luminosit√©:', `${lux.toFixed(0)} lux`],
            ['Image/Proj:', `${singleProjW?.toFixed(2) || '-'} x ${singleProjH?.toFixed(2) || '-'} m`],
        ];
        
        specs.forEach(([label, value]) => {
            ctx.fillStyle = '#718096';
            ctx.fillText(label, infoX + 10, lineY);
            ctx.fillStyle = '#2d3748';
            ctx.font = 'bold 11px Arial';
            ctx.fillText(value, infoX + 100, lineY);
            ctx.font = '11px Arial';
            lineY += lineH;
        });
        
        // Legend
        lineY += 20;
        ctx.fillStyle = '#1a365d';
        ctx.font = 'bold 12px Arial';
        ctx.fillText('L√âGENDE', infoX + 10, lineY);
        lineY += 20;
        
        for (let i = 0; i < Math.min(projH * projV, 8); i++) {
            ctx.fillStyle = colors[i];
            ctx.fillRect(infoX + 10, lineY - 10, 15, 15);
            ctx.fillStyle = '#4a5568';
            ctx.font = '10px Arial';
            ctx.fillText(`Projecteur ${i + 1}`, infoX + 30, lineY);
            lineY += 18;
        }
        
        // Overlap legend
        ctx.fillStyle = 'rgba(255, 193, 7, 0.6)';
        ctx.fillRect(infoX + 10, lineY - 10, 15, 15);
        ctx.fillStyle = '#4a5568';
        ctx.fillText('Zone de recouvrement', infoX + 30, lineY);
        
        // Footer
        ctx.fillStyle = '#a0aec0';
        ctx.font = '10px Arial';
        ctx.fillText('G√©n√©r√© par Projector Studio - Calculateur', 40, canvas.height - 20);
    }
    
    window.downloadBlueprint = function() {
        const canvas = document.getElementById('blueprint-canvas');
        const link = document.createElement('a');
        link.download = `blueprint_${Date.now()}.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();
    };

    // ========== TEST PATTERN FUNCTIONS ==========
    window.openTestPatternModal = function() {
        document.getElementById('testpattern-modal').classList.add('show');
        generateTestPatterns();
    };
    
    window.closeTestPatternModal = function() {
        document.getElementById('testpattern-modal').classList.remove('show');
    };
    
    function generateTestPatterns() {
        const container = document.getElementById('testpattern-preview');
        const data = window.wsCalculatedData || {};
        const { projH = 2, projV = 1, resW = 1920, resH = 1080, overlapH = 0, overlapV = 0, totalResW = 3240, totalResV = 1080 } = data;
        
        container.innerHTML = '';
        
        // Add info header showing total resolution
        const infoHeader = document.createElement('div');
        infoHeader.style.cssText = 'width:100%; text-align:center; padding:10px; margin-bottom:15px; background:#1a1a1a; border-radius:6px; grid-column: 1/-1;';
        infoHeader.innerHTML = `
            <div style="color:#0d9488; font-size:12px; font-weight:bold;">R√âSOLUTION TOTALE DE L'IMAGE</div>
            <div style="color:#fff; font-size:24px; font-weight:bold; margin:5px 0;">${totalResW} √ó ${totalResV} px</div>
            <div style="color:#888; font-size:10px;">Projecteurs: ${projH}√ó${projV} | R√©solution native: ${resW}√ó${resH} | Overlap H: ${overlapH}px V: ${overlapV}px</div>
        `;
        container.appendChild(infoHeader);
        
        // Patterns for full resolution image (single combined mire)
        const fullPatterns = [
            { name: 'Mire Compl√®te - Grille Num√©rot√©e', generator: generateFullNumberedGrid, isFull: true },
            { name: 'Mire Compl√®te - Grille Color√©e', generator: generateFullColorGrid, isFull: true },
            { name: 'Mire Compl√®te - Croix Calibration', generator: generateFullCrossPattern, isFull: true },
            { name: 'Mire Compl√®te - Cercles', generator: generateFullCirclePattern, isFull: true },
        ];
        
        // Per-projector patterns  
        const projPatterns = [
            { name: 'Grille Num√©rot√©e', generator: generateNumberedGrid },
            { name: 'Grille Color√©e', generator: generateColorGrid },
            { name: 'Croix de Calibration', generator: generateCrossPattern },
            { name: 'D√©grad√© Overlap', generator: generateOverlapGradient },
            { name: 'Cercles Concentriques', generator: generateCirclePattern },
            { name: 'Damier', generator: generateCheckerboard },
        ];
        
        // Section for full resolution patterns
        const fullSection = document.createElement('div');
        fullSection.style.cssText = 'width:100%; margin-bottom:20px; grid-column: 1/-1;';
        fullSection.innerHTML = '<div style="color:#0d9488; font-size:11px; text-transform:uppercase; margin-bottom:10px; padding-bottom:6px; border-bottom:1px solid #333;">Mires R√©solution Totale (image combin√©e)</div>';
        container.appendChild(fullSection);
        
        const fullGrid = document.createElement('div');
        fullGrid.style.cssText = 'display:grid; grid-template-columns:repeat(auto-fill, minmax(200px, 1fr)); gap:12px; width:100%; grid-column: 1/-1;';
        
        fullPatterns.forEach((pattern) => {
            const card = document.createElement('div');
            card.className = 'pattern-card';
            card.onclick = () => downloadFullPattern(pattern.name, pattern.generator, data);
            
            const canvas = document.createElement('canvas');
            // Preview at scaled aspect ratio
            const aspect = totalResW / totalResV;
            canvas.width = 320;
            canvas.height = Math.round(320 / aspect);
            
            pattern.generator(canvas.getContext('2d'), canvas.width, canvas.height, data);
            
            const label = document.createElement('div');
            label.className = 'pattern-card-label';
            label.textContent = pattern.name;
            
            card.appendChild(canvas);
            card.appendChild(label);
            fullGrid.appendChild(card);
        });
        container.appendChild(fullGrid);
        
        // Section for per-projector patterns
        const projSection = document.createElement('div');
        projSection.style.cssText = 'width:100%; margin-top:20px; margin-bottom:10px; grid-column: 1/-1;';
        projSection.innerHTML = '<div style="color:#f59e0b; font-size:11px; text-transform:uppercase; margin-bottom:10px; padding-bottom:6px; border-bottom:1px solid #333;">Mires Par Projecteur</div>';
        container.appendChild(projSection);
        
        const totalProj = projH * projV;
        
        for (let p = 0; p < totalProj; p++) {
            const col = p % projH;
            const row = Math.floor(p / projH);
            
            projPatterns.forEach((pattern, patIdx) => {
                const card = document.createElement('div');
                card.className = 'pattern-card';
                card.onclick = () => downloadPattern(p + 1, pattern.name, pattern.generator, data);
                
                const canvas = document.createElement('canvas');
                canvas.width = 320;
                canvas.height = 180;
                
                pattern.generator(canvas.getContext('2d'), canvas.width, canvas.height, p + 1, col, row, projH, projV, overlapH, overlapV, resW, resH);
                
                const label = document.createElement('div');
                label.className = 'pattern-card-label';
                label.textContent = `Proj ${p + 1} - ${pattern.name}`;
                
                card.appendChild(canvas);
                card.appendChild(label);
                container.appendChild(card);
            });
        }
    }
    
    // Full resolution pattern generators (combined image with overlap)
    function generateFullNumberedGrid(ctx, w, h, data) {
        const { projH = 2, projV = 1, totalResW = 3240, totalResV = 1080, resW = 1920, resH = 1080, overlapH = 0, overlapV = 0 } = data;
        const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#a29bfe', '#fd79a8', '#00cec9'];
        
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, w, h);
        
        // Calculate actual projector zones with overlap
        const scaleX = w / totalResW;
        const scaleY = h / totalResV;
        const projPixelW = resW * scaleX;
        const projPixelH = resH * scaleY;
        const overlapPixelH = overlapH * scaleX;
        const overlapPixelV = overlapV * scaleY;
        
        let num = 1;
        for (let pv = 0; pv < projV; pv++) {
            for (let ph = 0; ph < projH; ph++) {
                // Calculate projector position with overlap offset
                const x = ph * (projPixelW - overlapPixelH);
                const y = pv * (projPixelH - overlapPixelV);
                const color = colors[(num - 1) % colors.length];
                
                // Draw projector zone (slightly transparent for overlap visibility)
                ctx.fillStyle = color + '40';
                ctx.fillRect(x, y, projPixelW, projPixelH);
                
                // Zone border
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.strokeRect(x + 2, y + 2, projPixelW - 4, projPixelH - 4);
                
                // Grid lines in zone
                ctx.strokeStyle = color + '60';
                ctx.lineWidth = 1;
                for (let gx = 1; gx < 4; gx++) {
                    ctx.beginPath();
                    ctx.moveTo(x + (projPixelW / 4) * gx, y);
                    ctx.lineTo(x + (projPixelW / 4) * gx, y + projPixelH);
                    ctx.stroke();
                }
                for (let gy = 1; gy < 3; gy++) {
                    ctx.beginPath();
                    ctx.moveTo(x, y + (projPixelH / 3) * gy);
                    ctx.lineTo(x + projPixelW, y + (projPixelH / 3) * gy);
                    ctx.stroke();
                }
                
                // Number circle
                const cx = x + projPixelW / 2;
                const cy = y + projPixelH / 2;
                const radius = Math.min(projPixelW, projPixelH) * 0.15;
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${radius * 0.8}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(num.toString(), cx, cy);
                
                num++;
            }
        }
        
        // Highlight overlap zones
        ctx.fillStyle = 'rgba(255, 193, 7, 0.3)';
        ctx.strokeStyle = '#ffc107';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        
        // Horizontal overlaps
        if (overlapH > 0 && projH > 1) {
            for (let ph = 1; ph < projH; ph++) {
                const overlapX = ph * (projPixelW - overlapPixelH) - overlapPixelH;
                ctx.fillRect(overlapX + overlapPixelH, 0, overlapPixelH, h);
                ctx.strokeRect(overlapX + overlapPixelH, 0, overlapPixelH, h);
            }
        }
        
        // Vertical overlaps
        if (overlapV > 0 && projV > 1) {
            for (let pv = 1; pv < projV; pv++) {
                const overlapY = pv * (projPixelH - overlapPixelV) - overlapPixelV;
                ctx.fillRect(0, overlapY + overlapPixelV, w, overlapPixelV);
                ctx.strokeRect(0, overlapY + overlapPixelV, w, overlapPixelV);
            }
        }
        ctx.setLineDash([]);
        
        // Total resolution label
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`${totalResW} √ó ${totalResV} | Overlap: ${overlapH}√ó${overlapV}px`, w / 2, 20);
    }
    
    function generateFullColorGrid(ctx, w, h, data) {
        const { projH = 2, projV = 1, totalResW = 3240, totalResV = 1080, resW = 1920, resH = 1080, overlapH = 0, overlapV = 0 } = data;
        const colors = ['#e74c3c', '#f39c12', '#f1c40f', '#2ecc71', '#1abc9c', '#3498db', '#9b59b6', '#e91e63'];
        
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, w, h);
        
        const scaleX = w / totalResW;
        const scaleY = h / totalResV;
        const projPixelW = resW * scaleX;
        const projPixelH = resH * scaleY;
        const overlapPixelH = overlapH * scaleX;
        const overlapPixelV = overlapV * scaleY;
        
        let num = 1;
        for (let pv = 0; pv < projV; pv++) {
            for (let ph = 0; ph < projH; ph++) {
                const x = ph * (projPixelW - overlapPixelH);
                const y = pv * (projPixelH - overlapPixelV);
                
                ctx.fillStyle = colors[(num - 1) % colors.length] + 'cc';
                ctx.fillRect(x, y, projPixelW, projPixelH);
                
                // White grid
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                for (let gx = 0; gx <= 4; gx++) {
                    ctx.beginPath();
                    ctx.moveTo(x + (projPixelW / 4) * gx, y);
                    ctx.lineTo(x + (projPixelW / 4) * gx, y + projPixelH);
                    ctx.stroke();
                }
                for (let gy = 0; gy <= 3; gy++) {
                    ctx.beginPath();
                    ctx.moveTo(x, y + (projPixelH / 3) * gy);
                    ctx.lineTo(x + projPixelW, y + (projPixelH / 3) * gy);
                    ctx.stroke();
                }
                
                // Number
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${Math.min(projPixelW, projPixelH) * 0.3}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(num.toString(), x + projPixelW / 2, y + projPixelH / 2);
                
                num++;
            }
        }
        
        // Overlap zone markers
        if (overlapH > 0 || overlapV > 0) {
            ctx.fillStyle = '#fff';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Overlap: ${overlapH}√ó${overlapV}px`, w / 2, h - 10);
        }
    }
    
    function generateFullCrossPattern(ctx, w, h, data) {
        const { projH = 2, projV = 1, totalResW = 3240, totalResV = 1080, resW = 1920, resH = 1080, overlapH = 0, overlapV = 0 } = data;
        
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, w, h);
        
        const scaleX = w / totalResW;
        const scaleY = h / totalResV;
        const projPixelW = resW * scaleX;
        const projPixelH = resH * scaleY;
        const overlapPixelH = overlapH * scaleX;
        const overlapPixelV = overlapV * scaleY;
        
        // Main cross
        ctx.strokeStyle = '#0f0';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(w / 2, 0);
        ctx.lineTo(w / 2, h);
        ctx.moveTo(0, h / 2);
        ctx.lineTo(w, h / 2);
        ctx.stroke();
        
        // Diagonals
        ctx.strokeStyle = '#f00';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(w, h);
        ctx.moveTo(w, 0);
        ctx.lineTo(0, h);
        ctx.stroke();
        
        // Projector zone boundaries (with overlap consideration)
        const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#a29bfe'];
        ctx.lineWidth = 2;
        
        let num = 1;
        for (let pv = 0; pv < projV; pv++) {
            for (let ph = 0; ph < projH; ph++) {
                const x = ph * (projPixelW - overlapPixelH);
                const y = pv * (projPixelH - overlapPixelV);
                
                ctx.strokeStyle = colors[(num - 1) % colors.length];
                ctx.strokeRect(x, y, projPixelW, projPixelH);
                
                // Center cross for each projector
                ctx.beginPath();
                ctx.moveTo(x + projPixelW / 2, y);
                ctx.lineTo(x + projPixelW / 2, y + projPixelH);
                ctx.moveTo(x, y + projPixelH / 2);
                ctx.lineTo(x + projPixelW, y + projPixelH / 2);
                ctx.stroke();
                
                num++;
            }
        }
        
        // Highlight overlap zones
        if (overlapH > 0 && projH > 1) {
            ctx.fillStyle = 'rgba(255, 193, 7, 0.2)';
            for (let ph = 1; ph < projH; ph++) {
                const overlapX = ph * (projPixelW - overlapPixelH);
                ctx.fillRect(overlapX - overlapPixelH, 0, overlapPixelH * 2, h);
            }
        }
        
        // Center circle
        ctx.beginPath();
        ctx.arc(w / 2, h / 2, Math.min(w, h) * 0.1, 0, Math.PI * 2);
        ctx.strokeStyle = '#ff0';
        ctx.lineWidth = 2;
        ctx.stroke();
    }
    
    function generateFullCirclePattern(ctx, w, h, data) {
        const { projH = 2, projV = 1, totalResW = 3240, totalResV = 1080, resW = 1920, resH = 1080, overlapH = 0, overlapV = 0 } = data;
        
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, w, h);
        
        const scaleX = w / totalResW;
        const scaleY = h / totalResV;
        const projPixelW = resW * scaleX;
        const projPixelH = resH * scaleY;
        const overlapPixelH = overlapH * scaleX;
        const overlapPixelV = overlapV * scaleY;
        
        const colors = ['#e74c3c', '#f39c12', '#2ecc71', '#3498db', '#9b59b6'];
        const cx = w / 2;
        const cy = h / 2;
        const maxRadius = Math.min(w, h) * 0.45;
        
        for (let i = 5; i >= 1; i--) {
            ctx.beginPath();
            ctx.arc(cx, cy, maxRadius * (i / 5), 0, Math.PI * 2);
            ctx.strokeStyle = colors[i - 1];
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        // Projector zone boundaries with overlap
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.setLineDash([10, 5]);
        
        for (let pv = 0; pv < projV; pv++) {
            for (let ph = 0; ph < projH; ph++) {
                const x = ph * (projPixelW - overlapPixelH);
                const y = pv * (projPixelH - overlapPixelV);
                ctx.strokeRect(x, y, projPixelW, projPixelH);
            }
        }
        ctx.setLineDash([]);
        
        // Highlight overlap zones
        if (overlapH > 0 && projH > 1) {
            ctx.fillStyle = 'rgba(255, 193, 7, 0.15)';
            for (let ph = 1; ph < projH; ph++) {
                const overlapX = ph * (projPixelW - overlapPixelH);
                ctx.fillRect(overlapX - overlapPixelH, 0, overlapPixelH * 2, h);
            }
        }
        
        // Resolution label
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`${totalResW} √ó ${totalResV}`, cx, 25);
    }
    
    // Download full resolution pattern
    function downloadFullPattern(name, generator, data) {
        const { totalResW = 3240, totalResV = 1080 } = data;
        
        const canvas = document.createElement('canvas');
        canvas.width = totalResW;
        canvas.height = totalResV;
        const ctx = canvas.getContext('2d');
        
        generator(ctx, totalResW, totalResV, data);
        
        const link = document.createElement('a');
        link.download = `mire_${totalResW}x${totalResV}_${name.replace(/\s/g, '_').replace(/-/g, '')}.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();
    }
    
    function generateNumberedGrid(ctx, w, h, num, col, row, projH, projV, overlapH, overlapV, resW, resH) {
        const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#a29bfe', '#fd79a8', '#00cec9'];
        const color = colors[(num - 1) % colors.length];
        
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, w, h);
        
        // Calculate overlap zones in pixels (scaled to canvas)
        const overlapWPercent = overlapH / resW;
        const overlapHPercent = overlapV / resH;
        const overlapWPx = w * overlapWPercent;
        const overlapHPx = h * overlapHPercent;
        
        // Draw overlap zones on edges
        ctx.fillStyle = 'rgba(255, 193, 7, 0.25)';
        
        // Left overlap (if not first column)
        if (col > 0 && overlapH > 0) {
            ctx.fillRect(0, 0, overlapWPx, h);
        }
        // Right overlap (if not last column)
        if (col < projH - 1 && overlapH > 0) {
            ctx.fillRect(w - overlapWPx, 0, overlapWPx, h);
        }
        // Top overlap (if not first row)
        if (row > 0 && overlapV > 0) {
            ctx.fillRect(0, 0, w, overlapHPx);
        }
        // Bottom overlap (if not last row)
        if (row < projV - 1 && overlapV > 0) {
            ctx.fillRect(0, h - overlapHPx, w, overlapHPx);
        }
        
        // Grid lines
        ctx.strokeStyle = color + '60';
        ctx.lineWidth = 1;
        for (let x = 0; x <= w; x += w / 8) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, h);
            ctx.stroke();
        }
        for (let y = 0; y <= h; y += h / 6) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(w, y);
            ctx.stroke();
        }
        
        // Overlap zone markers (dashed lines)
        ctx.strokeStyle = '#ffc107';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        if (col > 0 && overlapH > 0) {
            ctx.beginPath();
            ctx.moveTo(overlapWPx, 0);
            ctx.lineTo(overlapWPx, h);
            ctx.stroke();
        }
        if (col < projH - 1 && overlapH > 0) {
            ctx.beginPath();
            ctx.moveTo(w - overlapWPx, 0);
            ctx.lineTo(w - overlapWPx, h);
            ctx.stroke();
        }
        if (row > 0 && overlapV > 0) {
            ctx.beginPath();
            ctx.moveTo(0, overlapHPx);
            ctx.lineTo(w, overlapHPx);
            ctx.stroke();
        }
        if (row < projV - 1 && overlapV > 0) {
            ctx.beginPath();
            ctx.moveTo(0, h - overlapHPx);
            ctx.lineTo(w, h - overlapHPx);
            ctx.stroke();
        }
        ctx.setLineDash([]);
        
        // Border
        ctx.strokeStyle = color;
        ctx.lineWidth = 4;
        ctx.strokeRect(2, 2, w - 4, h - 4);
        
        // Center number
        ctx.beginPath();
        ctx.arc(w / 2, h / 2, 40, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 36px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(num.toString(), w / 2, h / 2);
        
        // Corner markers with overlap info
        ctx.font = '12px Arial';
        ctx.fillStyle = color;
        const hasLeft = col > 0 && overlapH > 0;
        const hasRight = col < projH - 1 && overlapH > 0;
        const hasTop = row > 0 && overlapV > 0;
        const hasBottom = row < projV - 1 && overlapV > 0;
        
        ctx.fillText(hasTop || hasLeft ? '‚Üó' : 'TL', 20, 20);
        ctx.fillText(hasTop || hasRight ? '‚Üñ' : 'TR', w - 25, 20);
        ctx.fillText(hasBottom || hasLeft ? '‚Üò' : 'BL', 20, h - 10);
        ctx.fillText(hasBottom || hasRight ? '‚Üô' : 'BR', w - 25, h - 10);
        
        // Overlap percentage label
        if (overlapH > 0 || overlapV > 0) {
            ctx.fillStyle = '#ffc107';
            ctx.font = '10px Arial';
            ctx.fillText(`Overlap: ${Math.round(overlapWPercent*100)}%H ${Math.round(overlapHPercent*100)}%V`, w/2, h - 10);
        }
    }
    
    function generateColorGrid(ctx, w, h, num, col, row, projH, projV, overlapH, overlapV, resW, resH) {
        const colors = ['#e74c3c', '#f39c12', '#f1c40f', '#2ecc71', '#1abc9c', '#3498db', '#9b59b6', '#e91e63'];
        
        ctx.fillStyle = colors[(num - 1) % colors.length];
        ctx.fillRect(0, 0, w, h);
        
        // Calculate overlap zones
        const overlapWPercent = overlapH / resW;
        const overlapHPercent = overlapV / resH;
        const overlapWPx = w * overlapWPercent;
        const overlapHPx = h * overlapHPercent;
        
        // Draw overlap zones with darker shade
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        if (col > 0 && overlapH > 0) ctx.fillRect(0, 0, overlapWPx, h);
        if (col < projH - 1 && overlapH > 0) ctx.fillRect(w - overlapWPx, 0, overlapWPx, h);
        if (row > 0 && overlapV > 0) ctx.fillRect(0, 0, w, overlapHPx);
        if (row < projV - 1 && overlapV > 0) ctx.fillRect(0, h - overlapHPx, w, overlapHPx);
        
        // White grid
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        for (let x = 0; x <= w; x += w / 4) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, h);
            ctx.stroke();
        }
        for (let y = 0; y <= h; y += h / 3) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(w, y);
            ctx.stroke();
        }
        
        // Overlap zone markers
        ctx.strokeStyle = '#ffc107';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        if (col > 0 && overlapH > 0) {
            ctx.beginPath();
            ctx.moveTo(overlapWPx, 0);
            ctx.lineTo(overlapWPx, h);
            ctx.stroke();
        }
        if (col < projH - 1 && overlapH > 0) {
            ctx.beginPath();
            ctx.moveTo(w - overlapWPx, 0);
            ctx.lineTo(w - overlapWPx, h);
            ctx.stroke();
        }
        ctx.setLineDash([]);
        
        // Number
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 48px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(num.toString(), w / 2, h / 2);
    }
    
    function generateCrossPattern(ctx, w, h, num, col, row, projH, projV, overlapH, overlapV, resW, resH) {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, w, h);
        
        // Calculate overlap zones
        const overlapWPercent = overlapH / resW;
        const overlapHPercent = overlapV / resH;
        const overlapWPx = w * overlapWPercent;
        const overlapHPx = h * overlapHPercent;
        
        // Draw overlap zones
        ctx.fillStyle = 'rgba(255, 193, 7, 0.15)';
        if (col > 0 && overlapH > 0) ctx.fillRect(0, 0, overlapWPx, h);
        if (col < projH - 1 && overlapH > 0) ctx.fillRect(w - overlapWPx, 0, overlapWPx, h);
        if (row > 0 && overlapV > 0) ctx.fillRect(0, 0, w, overlapHPx);
        if (row < projV - 1 && overlapV > 0) ctx.fillRect(0, h - overlapHPx, w, overlapHPx);
        
        ctx.strokeStyle = '#0f0';
        ctx.lineWidth = 2;
        
        // Center cross
        ctx.beginPath();
        ctx.moveTo(w / 2, 0);
        ctx.lineTo(w / 2, h);
        ctx.moveTo(0, h / 2);
        ctx.lineTo(w, h / 2);
        ctx.stroke();
        
        // Diagonal
        ctx.strokeStyle = '#f00';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(w, h);
        ctx.moveTo(w, 0);
        ctx.lineTo(0, h);
        ctx.stroke();
        
        // Overlap boundary markers
        ctx.strokeStyle = '#ffc107';
        ctx.setLineDash([5, 5]);
        if (col > 0 && overlapH > 0) {
            ctx.beginPath();
            ctx.moveTo(overlapWPx, 0);
            ctx.lineTo(overlapWPx, h);
            ctx.stroke();
        }
        if (col < projH - 1 && overlapH > 0) {
            ctx.beginPath();
            ctx.moveTo(w - overlapWPx, 0);
            ctx.lineTo(w - overlapWPx, h);
            ctx.stroke();
        }
        ctx.setLineDash([]);
        
        // Center circle
        ctx.beginPath();
        ctx.arc(w / 2, h / 2, 30, 0, Math.PI * 2);
        ctx.strokeStyle = '#ff0';
        ctx.stroke();
        
        ctx.fillStyle = '#ff0';
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(num.toString(), w / 2, h / 2);
    }
    
    function generateOverlapGradient(ctx, w, h, num, col, row, projH, projV, overlapH, overlapV, resW, resH) {
        // Base color for this projector
        const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#a29bfe'];
        const baseColor = colors[(num - 1) % colors.length];
        
        ctx.fillStyle = baseColor + '40';
        ctx.fillRect(0, 0, w, h);
        
        const overlapPercentH = overlapH / resW;
        const overlapPercentV = overlapV / resH;
        const overlapWPx = w * overlapPercentH;
        const overlapHPx = h * overlapPercentV;
        
        // Left gradient (if not first column)
        if (col > 0 && overlapH > 0) {
            const grad = ctx.createLinearGradient(0, 0, overlapWPx, 0);
            grad.addColorStop(0, 'rgba(0,0,0,1)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, overlapWPx, h);
        }
        
        // Right gradient (if not last column)
        if (col < projH - 1 && overlapH > 0) {
            const grad = ctx.createLinearGradient(w - overlapWPx, 0, w, 0);
            grad.addColorStop(0, 'rgba(0,0,0,0)');
            grad.addColorStop(1, 'rgba(0,0,0,1)');
            ctx.fillStyle = grad;
            ctx.fillRect(w - overlapWPx, 0, overlapWPx, h);
        }
        
        // Top gradient (if not first row)
        if (row > 0 && overlapV > 0) {
            const grad = ctx.createLinearGradient(0, 0, 0, overlapHPx);
            grad.addColorStop(0, 'rgba(0,0,0,1)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, overlapHPx);
        }
        
        // Bottom gradient (if not last row)
        if (row < projV - 1 && overlapV > 0) {
            const grad = ctx.createLinearGradient(0, h - overlapHPx, 0, h);
            grad.addColorStop(0, 'rgba(0,0,0,0)');
            grad.addColorStop(1, 'rgba(0,0,0,1)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, h - overlapHPx, w, overlapHPx);
        }
        
        // Overlap zone markers
        ctx.strokeStyle = '#ffc107';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        if (col > 0 && overlapH > 0) {
            ctx.beginPath();
            ctx.moveTo(overlapWPx, 0);
            ctx.lineTo(overlapWPx, h);
            ctx.stroke();
        }
        if (col < projH - 1 && overlapH > 0) {
            ctx.beginPath();
            ctx.moveTo(w - overlapWPx, 0);
            ctx.lineTo(w - overlapWPx, h);
            ctx.stroke();
        }
        ctx.setLineDash([]);
        
        // Number and info
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 36px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(num.toString(), w / 2, h / 2);
        
        // Overlap percentage
        ctx.font = '11px Arial';
        ctx.fillText(`Soft Edge: ${Math.round(overlapPercentH * 100)}%`, w / 2, h / 2 + 35);
    }
    
    function generateCirclePattern(ctx, w, h, num, col, row, projH, projV, overlapH, overlapV, resW, resH) {
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, w, h);
        
        // Calculate overlap zones
        const overlapWPercent = overlapH / resW;
        const overlapHPercent = overlapV / resH;
        const overlapWPx = w * overlapWPercent;
        const overlapHPx = h * overlapHPercent;
        
        // Draw overlap zones
        ctx.fillStyle = 'rgba(255, 193, 7, 0.15)';
        if (col > 0 && overlapH > 0) ctx.fillRect(0, 0, overlapWPx, h);
        if (col < projH - 1 && overlapH > 0) ctx.fillRect(w - overlapWPx, 0, overlapWPx, h);
        
        const colors = ['#e74c3c', '#f39c12', '#2ecc71', '#3498db', '#9b59b6'];
        const cx = w / 2;
        const cy = h / 2;
        
        for (let i = 5; i >= 1; i--) {
            ctx.beginPath();
            ctx.arc(cx, cy, (h / 2) * (i / 5), 0, Math.PI * 2);
            ctx.strokeStyle = colors[i - 1];
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 30px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(num.toString(), cx, cy);
    }
    
    function generateCheckerboard(ctx, w, h, num, col, row, projH, projV, overlapH, overlapV, resW, resH) {
        const size = w / 16;
        
        for (let y = 0; y < h; y += size) {
            for (let x = 0; x < w; x += size) {
                const isWhite = ((x / size) + (y / size)) % 2 === 0;
                ctx.fillStyle = isWhite ? '#fff' : '#000';
                ctx.fillRect(x, y, size, size);
            }
        }
        
        // Calculate overlap zones
        const overlapWPercent = overlapH / resW;
        const overlapHPercent = overlapV / resH;
        const overlapWPx = w * overlapWPercent;
        const overlapHPx = h * overlapHPercent;
        
        // Draw overlap zone markers
        ctx.strokeStyle = '#ffc107';
        ctx.lineWidth = 3;
        ctx.setLineDash([8, 4]);
        if (col > 0 && overlapH > 0) {
            ctx.beginPath();
            ctx.moveTo(overlapWPx, 0);
            ctx.lineTo(overlapWPx, h);
            ctx.stroke();
        }
        if (col < projH - 1 && overlapH > 0) {
            ctx.beginPath();
            ctx.moveTo(w - overlapWPx, 0);
            ctx.lineTo(w - overlapWPx, h);
            ctx.stroke();
        }
        ctx.setLineDash([]);
        
        // Center number
        ctx.fillStyle = '#0d9488';
        ctx.beginPath();
        ctx.arc(w / 2, h / 2, 30, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(num.toString(), w / 2, h / 2);
    }
    
    function downloadPattern(num, name, generator, data) {
        const { resW = 1920, resH = 1080, projH = 2, projV = 1, overlapH = 0, overlapV = 0 } = data;
        const col = (num - 1) % projH;
        const row = Math.floor((num - 1) / projH);
        
        const canvas = document.createElement('canvas');
        canvas.width = resW;
        canvas.height = resH;
        const ctx = canvas.getContext('2d');
        
        generator(ctx, resW, resH, num, col, row, projH, projV, overlapH, overlapV, resW, resH);
        
        const link = document.createElement('a');
        link.download = `mire_proj${num}_${name.replace(/\s/g, '_')}.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();
    }
    
    window.downloadAllPatterns = function() {
        const data = window.wsCalculatedData || {};
        const { projH = 2, projV = 1, resW = 1920, resH = 1080, overlapH = 0, overlapV = 0 } = data;
        const totalProj = projH * projV;
        
        const patterns = [
            { name: 'Grille_Numerotee', generator: generateNumberedGrid },
            { name: 'Grille_Coloree', generator: generateColorGrid },
        ];
        
        for (let p = 0; p < totalProj; p++) {
            const col = p % projH;
            const row = Math.floor(p / projH);
            
            patterns.forEach(pattern => {
                setTimeout(() => {
                    downloadPattern(p + 1, pattern.name, pattern.generator, data);
                }, p * 300);
            });
        }
    };

    </script>
    
    <!-- Context Menu -->
    <div id="context-menu">
        <div class="context-menu-item" onclick="setAsTargetFromContextMenu()">
            <span class="icon">üéØ</span>
            <span>Set as Target</span>
        </div>
        <div class="context-menu-item" onclick="deleteObjectFromContextMenu()">
            <span class="icon">üóëÔ∏è</span>
            <span>Delete</span>
        </div>
    </div>

</body>
</html>