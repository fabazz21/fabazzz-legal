<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G√©n√©rateur d'≈íuvres d'Art par IA</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .header {
            color: white;
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.95;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .api-config {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 25px;
            border-left: 4px solid #667eea;
        }

        .api-config h3 {
            color: #667eea;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .api-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .api-option {
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            background: white;
        }

        .api-option:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }

        .api-option.active {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .api-option h4 {
            color: #333;
            margin-bottom: 5px;
        }

        .api-option p {
            font-size: 0.85em;
            color: #666;
        }

        .api-key-input {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .api-key-input input {
            flex: 1;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-size: 0.9em;
            color: #555;
            font-weight: 600;
        }

        input, select, textarea, button {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            font-family: inherit;
        }

        textarea {
            resize: vertical;
            min-height: 80px;
        }

        button {
            cursor: pointer;
            border: none;
            font-weight: 600;
            transition: all 0.3s;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-success {
            background: #2ecc71;
            color: white;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .workspace {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 20px;
        }

        .canvas-wrapper {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .canvas-wrapper h3 {
            color: #333;
            font-size: 1.3em;
            text-align: center;
        }

        canvas {
            width: 100%;
            max-width: 600px;
            height: auto;
            aspect-ratio: 1;
            border: 3px solid #667eea;
            border-radius: 10px;
            cursor: crosshair;
            background: white;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            margin: 0 auto;
            display: block;
        }

        #artworkCanvas {
            cursor: default;
            background: #f8f9fa;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
            color: #667eea;
            font-size: 1.2em;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .info {
            background: #e8f4f8;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }

        .info h4 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }

        .alert.show {
            display: block;
        }

        .alert-info {
            background: #d1ecf1;
            border-left: 4px solid #0c5460;
            color: #0c5460;
        }

        .alert-error {
            background: #f8d7da;
            border-left: 4px solid #721c24;
            color: #721c24;
        }

        .alert-success {
            background: #d4edda;
            border-left: 4px solid #155724;
            color: #155724;
        }

        @media (max-width: 1024px) {
            .workspace {
                grid-template-columns: 1fr;
            }
        }

        .quick-prompts {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .quick-prompt {
            padding: 6px 12px;
            background: white;
            border: 1px solid #667eea;
            color: #667eea;
            border-radius: 20px;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.3s;
        }

        .quick-prompt:hover {
            background: #667eea;
            color: white;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üé® G√©n√©rateur d'≈íuvres d'Art par IA</h1>
        <p>Dessinez simplement et laissez l'IA cr√©er une ≈ìuvre d'art magnifique</p>
    </div>

    <div class="container">
        <div id="alert" class="alert"></div>

        <div class="api-config">
            <h3>‚öôÔ∏è Configuration de l'IA</h3>
            <div class="api-selector">
                <div class="api-option active" data-api="huggingface">
                    <h4>ü§ó Hugging Face</h4>
                    <p>Gratuit - Stable Diffusion</p>
                </div>
                <div class="api-option" data-api="replicate">
                    <h4>üîÑ Replicate</h4>
                    <p>API cloud - SDXL</p>
                </div>
                <div class="api-option" data-api="local">
                    <h4>üíª Mode Local</h4>
                    <p>Simulation avanc√©e</p>
                </div>
            </div>
            <div class="api-key-input">
                <input type="password" id="apiKey" placeholder="Cl√© API (optionnelle pour mode local)">
                <button class="btn-primary" id="saveApiKey">üíæ Sauvegarder</button>
            </div>
            <p style="margin-top: 10px; font-size: 0.9em; color: #666;">
                <strong>Mode Local :</strong> Fonctionne sans cl√© API avec des effets artistiques avanc√©s.<br>
                <strong>Hugging Face :</strong> Obtenez une cl√© gratuite sur <a href="https://huggingface.co/settings/tokens" target="_blank">huggingface.co</a><br>
                <strong>Replicate :</strong> Cl√© API sur <a href="https://replicate.com/account" target="_blank">replicate.com</a>
            </p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="artStyle">Style Artistique</label>
                <select id="artStyle">
                    <option value="oil painting">Peinture √† l'huile</option>
                    <option value="watercolor">Aquarelle</option>
                    <option value="digital art">Art num√©rique</option>
                    <option value="impressionist">Impressionniste</option>
                    <option value="renaissance">Renaissance</option>
                    <option value="modern art">Art moderne</option>
                    <option value="anime">Anime/Manga</option>
                    <option value="photorealistic">Photo-r√©aliste</option>
                    <option value="abstract">Abstrait</option>
                    <option value="surrealist">Surr√©aliste</option>
                </select>
            </div>

            <div class="control-group">
                <label for="brushSize">Taille du pinceau</label>
                <input type="range" id="brushSize" min="2" max="30" value="8">
            </div>

            <div class="control-group">
                <label for="brushColor">Couleur</label>
                <input type="color" id="brushColor" value="#000000">
            </div>

            <div class="control-group">
                <label>&nbsp;</label>
                <button class="btn-danger" id="clearBtn">üóëÔ∏è Effacer</button>
            </div>
        </div>

        <div class="control-group" style="margin-bottom: 20px; padding: 0 20px;">
            <label for="additionalPrompt">Description suppl√©mentaire (optionnel)</label>
            <textarea id="additionalPrompt" placeholder="Ex: avec des couleurs vives, dans un style baroque, avec des d√©tails dor√©s..."></textarea>
            <div class="quick-prompts">
                <span class="quick-prompt" data-prompt="avec des couleurs vives et √©clatantes">Couleurs vives</span>
                <span class="quick-prompt" data-prompt="dans un style baroque avec des d√©tails dor√©s">Style baroque</span>
                <span class="quick-prompt" data-prompt="ambiance sombre et myst√©rieuse">Sombre et myst√©rieux</span>
                <span class="quick-prompt" data-prompt="avec des effets de lumi√®re dramatiques">Lumi√®re dramatique</span>
                <span class="quick-prompt" data-prompt="tr√®s d√©taill√© et r√©aliste">Tr√®s d√©taill√©</span>
                <span class="quick-prompt" data-prompt="minimaliste et √©pur√©">Minimaliste</span>
            </div>
        </div>

        <div class="workspace">
            <div class="canvas-wrapper">
                <h3>‚úèÔ∏è Votre Dessin Simple</h3>
                <canvas id="drawingCanvas" width="512" height="512"></canvas>
                <button class="btn-primary" id="generateBtn" style="font-size: 1.1em; padding: 15px;">
                    ‚ú® G√©n√©rer l'≈íuvre d'Art
                </button>
            </div>
            <div class="canvas-wrapper">
                <h3>üé® ≈íuvre d'Art G√©n√©r√©e</h3>
                <canvas id="artworkCanvas" width="512" height="512"></canvas>
                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    <p>L'IA cr√©e votre ≈ìuvre d'art...</p>
                    <p style="font-size: 0.9em; margin-top: 10px;">Cela peut prendre 10-30 secondes</p>
                </div>
                <button class="btn-success" id="saveBtn" style="display: none;">üíæ Sauvegarder l'≈íuvre</button>
            </div>
        </div>

        <div class="info">
            <h4>‚ÑπÔ∏è Comment utiliser</h4>
            <ul style="margin-left: 20px; line-height: 1.8;">
                <li><strong>Mode Local (sans API) :</strong> S√©lectionnez "Mode Local" et dessinez. L'application utilisera des algorithmes avanc√©s pour cr√©er votre ≈ìuvre.</li>
                <li><strong>Avec IA en ligne :</strong> Entrez votre cl√© API Hugging Face ou Replicate pour utiliser de v√©ritables mod√®les d'IA g√©n√©rative.</li>
                <li><strong>Dessinez :</strong> Faites un dessin simple sur le canvas de gauche (formes, silhouettes, croquis).</li>
                <li><strong>Choisissez un style :</strong> S√©lectionnez le style artistique souhait√©.</li>
                <li><strong>G√©n√©rez :</strong> Cliquez sur "G√©n√©rer l'≈íuvre d'Art" et l'IA transformera votre dessin.</li>
                <li><strong>Ajustez :</strong> Utilisez la description suppl√©mentaire pour affiner le r√©sultat.</li>
            </ul>
        </div>
    </div>

    <script>
        // Configuration
        const drawingCanvas = document.getElementById('drawingCanvas');
        const artworkCanvas = document.getElementById('artworkCanvas');
        const drawingCtx = drawingCanvas.getContext('2d');
        const artworkCtx = artworkCanvas.getContext('2d');

        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let currentAPI = 'local';
        let apiKey = '';

        // √âl√©ments
        const apiOptions = document.querySelectorAll('.api-option');
        const apiKeyInput = document.getElementById('apiKey');
        const saveApiKeyBtn = document.getElementById('saveApiKey');
        const artStyleSelect = document.getElementById('artStyle');
        const brushSizeInput = document.getElementById('brushSize');
        const brushColorInput = document.getElementById('brushColor');
        const additionalPromptInput = document.getElementById('additionalPrompt');
        const generateBtn = document.getElementById('generateBtn');
        const clearBtn = document.getElementById('clearBtn');
        const saveBtn = document.getElementById('saveBtn');
        const loading = document.getElementById('loading');
        const alert = document.getElementById('alert');

        // Configuration du canvas de dessin
        drawingCtx.lineCap = 'round';
        drawingCtx.lineJoin = 'round';
        drawingCtx.fillStyle = 'white';
        drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);

        // S√©lection de l'API
        apiOptions.forEach(option => {
            option.addEventListener('click', () => {
                apiOptions.forEach(opt => opt.classList.remove('active'));
                option.classList.add('active');
                currentAPI = option.dataset.api;

                if (currentAPI === 'local') {
                    apiKeyInput.placeholder = 'Cl√© API non requise pour le mode local';
                } else {
                    apiKeyInput.placeholder = `Entrez votre cl√© API ${currentAPI === 'huggingface' ? 'Hugging Face' : 'Replicate'}`;
                }
            });
        });

        // Sauvegarde de la cl√© API
        saveApiKeyBtn.addEventListener('click', () => {
            apiKey = apiKeyInput.value.trim();
            if (currentAPI === 'local' || apiKey) {
                showAlert('Cl√© API sauvegard√©e avec succ√®s !', 'success');
            } else {
                showAlert('Veuillez entrer une cl√© API valide', 'error');
            }
        });

        // Quick prompts
        document.querySelectorAll('.quick-prompt').forEach(prompt => {
            prompt.addEventListener('click', () => {
                const current = additionalPromptInput.value;
                const newPrompt = prompt.dataset.prompt;
                additionalPromptInput.value = current ? `${current}, ${newPrompt}` : newPrompt;
            });
        });

        // Dessin
        drawingCanvas.addEventListener('mousedown', startDrawing);
        drawingCanvas.addEventListener('mousemove', draw);
        drawingCanvas.addEventListener('mouseup', stopDrawing);
        drawingCanvas.addEventListener('mouseout', stopDrawing);

        drawingCanvas.addEventListener('touchstart', handleTouch);
        drawingCanvas.addEventListener('touchmove', handleTouch);
        drawingCanvas.addEventListener('touchend', stopDrawing);

        function startDrawing(e) {
            isDrawing = true;
            const rect = drawingCanvas.getBoundingClientRect();
            const scaleX = drawingCanvas.width / rect.width;
            const scaleY = drawingCanvas.height / rect.height;
            lastX = (e.clientX - rect.left) * scaleX;
            lastY = (e.clientY - rect.top) * scaleY;
        }

        function draw(e) {
            if (!isDrawing) return;

            const rect = drawingCanvas.getBoundingClientRect();
            const scaleX = drawingCanvas.width / rect.width;
            const scaleY = drawingCanvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            drawingCtx.strokeStyle = brushColorInput.value;
            drawingCtx.lineWidth = brushSizeInput.value;

            drawingCtx.beginPath();
            drawingCtx.moveTo(lastX, lastY);
            drawingCtx.lineTo(x, y);
            drawingCtx.stroke();

            lastX = x;
            lastY = y;
        }

        function stopDrawing() {
            isDrawing = false;
        }

        function handleTouch(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent(e.type === 'touchstart' ? 'mousedown' : 'mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            drawingCanvas.dispatchEvent(mouseEvent);
        }

        // Effacer
        clearBtn.addEventListener('click', () => {
            drawingCtx.fillStyle = 'white';
            drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            artworkCtx.fillStyle = '#f8f9fa';
            artworkCtx.fillRect(0, 0, artworkCanvas.width, artworkCanvas.height);
            saveBtn.style.display = 'none';
        });

        // G√©n√©ration de l'≈ìuvre d'art
        generateBtn.addEventListener('click', async () => {
            // V√©rifier si le canvas n'est pas vide
            const imageData = drawingCtx.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height);
            const isBlank = !imageData.data.some((channel, i) => i % 4 !== 3 && channel !== 255);

            if (isBlank) {
                showAlert('Veuillez d\'abord faire un dessin !', 'error');
                return;
            }

            generateBtn.disabled = true;
            loading.classList.add('active');
            saveBtn.style.display = 'none';

            try {
                if (currentAPI === 'local') {
                    await generateLocalArtwork();
                } else if (currentAPI === 'huggingface') {
                    await generateHuggingFaceArtwork();
                } else if (currentAPI === 'replicate') {
                    await generateReplicateArtwork();
                }

                saveBtn.style.display = 'block';
                showAlert('≈íuvre d\'art g√©n√©r√©e avec succ√®s !', 'success');
            } catch (error) {
                showAlert(`Erreur : ${error.message}`, 'error');
                console.error(error);
            } finally {
                generateBtn.disabled = false;
                loading.classList.remove('active');
            }
        });

        // Mode local avec effets artistiques avanc√©s
        async function generateLocalArtwork() {
            return new Promise((resolve) => {
                // Simuler un d√©lai de traitement
                setTimeout(() => {
                    artworkCtx.fillStyle = 'white';
                    artworkCtx.fillRect(0, 0, artworkCanvas.width, artworkCanvas.height);

                    // Copier et transformer le dessin
                    artworkCtx.drawImage(drawingCanvas, 0, 0);

                    const style = artStyleSelect.value;
                    const imageData = artworkCtx.getImageData(0, 0, artworkCanvas.width, artworkCanvas.height);
                    const data = imageData.data;

                    // Appliquer des transformations artistiques avanc√©es
                    applyAdvancedArtStyle(data, style);

                    artworkCtx.putImageData(imageData, 0, 0);

                    // Ajouter des effets de post-traitement
                    applyPostProcessing(style);

                    resolve();
                }, 1500);
            });
        }

        function applyAdvancedArtStyle(data, style) {
            const effects = {
                'oil painting': () => applyOilPainting(data),
                'watercolor': () => applyWatercolor(data),
                'digital art': () => applyDigitalArt(data),
                'impressionist': () => applyImpressionist(data),
                'renaissance': () => applyRenaissance(data),
                'modern art': () => applyModernArt(data),
                'anime': () => applyAnime(data),
                'photorealistic': () => applyPhotorealistic(data),
                'abstract': () => applyAbstract(data),
                'surrealist': () => applySurrealist(data)
            };

            if (effects[style]) {
                effects[style]();
            }
        }

        function applyOilPainting(data) {
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] > 0) {
                    data[i] = Math.min(255, data[i] * 1.3 + 20);
                    data[i + 1] = Math.min(255, data[i + 1] * 1.3 + 15);
                    data[i + 2] = Math.min(255, data[i + 2] * 1.3 + 10);
                }
            }
        }

        function applyWatercolor(data) {
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] > 0) {
                    const rand = Math.random() * 40;
                    data[i] = Math.min(255, data[i] + rand);
                    data[i + 1] = Math.min(255, data[i + 1] + rand * 0.9);
                    data[i + 2] = Math.min(255, data[i + 2] + rand * 0.8);
                    data[i + 3] = Math.max(120, data[i + 3] - 60);
                }
            }
        }

        function applyDigitalArt(data) {
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] > 0) {
                    data[i] = Math.min(255, data[i] * 1.5);
                    data[i + 1] = Math.min(255, data[i + 1] * 1.4);
                    data[i + 2] = Math.min(255, data[i + 2] * 1.6);
                }
            }
        }

        function applyImpressionist(data) {
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] > 0) {
                    const variation = (Math.random() - 0.5) * 120;
                    data[i] = Math.max(0, Math.min(255, data[i] + variation));
                    data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + variation * 0.9));
                    data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + variation * 0.8));
                }
            }
        }

        function applyRenaissance(data) {
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] > 0) {
                    const r = data[i] * 0.9 + 30;
                    const g = data[i + 1] * 0.85 + 20;
                    const b = data[i + 2] * 0.75 + 15;
                    data[i] = Math.min(255, r);
                    data[i + 1] = Math.min(255, g);
                    data[i + 2] = Math.min(255, b);
                }
            }
        }

        function applyModernArt(data) {
            const levels = 4;
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] > 0) {
                    data[i] = Math.round(data[i] / (255 / levels)) * (255 / levels);
                    data[i + 1] = Math.round(data[i + 1] / (255 / levels)) * (255 / levels);
                    data[i + 2] = Math.round(data[i + 2] / (255 / levels)) * (255 / levels);
                }
            }
        }

        function applyAnime(data) {
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] > 0) {
                    data[i] = Math.min(255, data[i] * 1.4);
                    data[i + 1] = Math.min(255, data[i + 1] * 1.3);
                    data[i + 2] = Math.min(255, data[i + 2] * 1.5);
                    data[i + 3] = 255;
                }
            }
        }

        function applyPhotorealistic(data) {
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] > 0) {
                    const noise = (Math.random() - 0.5) * 10;
                    data[i] = Math.max(0, Math.min(255, data[i] * 1.1 + noise));
                    data[i + 1] = Math.max(0, Math.min(255, data[i + 1] * 1.1 + noise));
                    data[i + 2] = Math.max(0, Math.min(255, data[i + 2] * 1.1 + noise));
                }
            }
        }

        function applyAbstract(data) {
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] > 0) {
                    const offset = Math.random() * 200 - 100;
                    data[i] = Math.max(0, Math.min(255, data[i] + offset));
                    data[i + 1] = Math.max(0, Math.min(255, data[i + 1] - offset * 0.5));
                    data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + offset * 0.7));
                }
            }
        }

        function applySurrealist(data) {
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] > 0) {
                    const shift = Math.sin(i / 1000) * 100;
                    data[i] = Math.max(0, Math.min(255, data[i] + shift));
                    data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + Math.cos(i / 1000) * 100));
                    data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + shift * 0.5));
                }
            }
        }

        function applyPostProcessing(style) {
            // Ajouter des textures et effets suppl√©mentaires
            artworkCtx.globalCompositeOperation = 'multiply';
            artworkCtx.globalAlpha = 0.05;

            for (let i = 0; i < 100; i++) {
                const x = Math.random() * artworkCanvas.width;
                const y = Math.random() * artworkCanvas.height;
                const size = Math.random() * 50 + 10;

                artworkCtx.fillStyle = `rgb(${Math.random()*255},${Math.random()*255},${Math.random()*255})`;
                artworkCtx.fillRect(x, y, size, size);
            }

            artworkCtx.globalCompositeOperation = 'source-over';
            artworkCtx.globalAlpha = 1;
        }

        // G√©n√©ration avec Hugging Face
        async function generateHuggingFaceArtwork() {
            if (!apiKey) {
                throw new Error('Veuillez d\'abord configurer votre cl√© API Hugging Face');
            }

            const prompt = buildPrompt();
            const imageBase64 = drawingCanvas.toDataURL('image/png');

            const response = await fetch('https://api-inference.huggingface.co/models/stabilityai/stable-diffusion-xl-base-1.0', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    inputs: prompt,
                    parameters: {
                        num_inference_steps: 30,
                        guidance_scale: 7.5,
                    }
                })
            });

            if (!response.ok) {
                throw new Error(`Erreur API: ${response.status} - ${response.statusText}`);
            }

            const blob = await response.blob();
            const img = new Image();
            img.onload = () => {
                artworkCtx.drawImage(img, 0, 0, artworkCanvas.width, artworkCanvas.height);
            };
            img.src = URL.createObjectURL(blob);
        }

        // G√©n√©ration avec Replicate
        async function generateReplicateArtwork() {
            if (!apiKey) {
                throw new Error('Veuillez d\'abord configurer votre cl√© API Replicate');
            }

            showAlert('Replicate n√©cessite un backend serveur. Utilisez le mode local ou Hugging Face pour l\'instant.', 'info');
            await generateLocalArtwork();
        }

        function buildPrompt() {
            const style = artStyleSelect.value;
            const additional = additionalPromptInput.value.trim();
            let prompt = `${style} artwork`;
            if (additional) {
                prompt += `, ${additional}`;
            }
            prompt += ', masterpiece, high quality, detailed';
            return prompt;
        }

        // Sauvegarde
        saveBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            link.download = `ai-artwork-${artStyleSelect.value.replace(/\s/g, '-')}-${timestamp}.png`;
            link.href = artworkCanvas.toDataURL();
            link.click();
            showAlert('≈íuvre sauvegard√©e !', 'success');
        });

        // Alertes
        function showAlert(message, type) {
            alert.textContent = message;
            alert.className = `alert alert-${type} show`;
            setTimeout(() => {
                alert.classList.remove('show');
            }, 5000);
        }

        // Charger la cl√© API depuis le stockage local
        const savedKey = localStorage.getItem('apiKey');
        if (savedKey) {
            apiKey = savedKey;
            apiKeyInput.value = savedKey;
        }

        saveApiKeyBtn.addEventListener('click', () => {
            localStorage.setItem('apiKey', apiKeyInput.value);
        });
    </script>
</body>
</html>
