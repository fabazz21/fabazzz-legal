<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapping Matter - Projection Mapping Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #1e1e1e;
            color: #cccccc;
            overflow: hidden;
            font-size: 13px;
        }

        /* Top Menu Bar */
        #menubar {
            background: #2d2d2d;
            border-bottom: 1px solid #1a1a1a;
            padding: 0;
            display: flex;
            align-items: center;
            height: 36px;
        }

        .menu-item {
            padding: 0 15px;
            height: 100%;
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
            transition: background 0.2s;
        }

        .menu-item:hover {
            background: #3e3e3e;
        }

        .menu-separator {
            width: 1px;
            height: 24px;
            background: #3a3a3a;
            margin: 0 5px;
        }

        /* Main Container */
        #main-container {
            display: flex;
            height: calc(100vh - 36px);
        }

        /* Left Panel - Scene Objects */
        #left-panel {
            width: 260px;
            background: #252526;
            border-right: 1px solid #1a1a1a;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            background: #2d2d2d;
            padding: 8px 12px;
            border-bottom: 1px solid #1a1a1a;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #scene-objects-list {
            flex: 1;
            overflow-y: auto;
            padding: 4px;
        }

        .scene-object-item {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            margin: 2px 0;
            cursor: pointer;
            border-radius: 3px;
            transition: background 0.2s;
        }

        .scene-object-item:hover {
            background: #2a2d2e;
        }

        .scene-object-item.selected {
            background: #094771;
        }

        .object-visibility {
            width: 16px;
            height: 16px;
            margin-right: 6px;
            cursor: pointer;
            opacity: 0.6;
        }

        .object-visibility:hover {
            opacity: 1;
        }

        .object-lock {
            width: 14px;
            height: 14px;
            margin-left: auto;
            cursor: pointer;
            opacity: 0.4;
        }

        .object-lock:hover {
            opacity: 1;
        }

        .object-icon {
            width: 16px;
            height: 16px;
            margin-right: 6px;
            opacity: 0.7;
        }

        .object-name {
            flex: 1;
            font-size: 12px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Center - Viewport */
        #viewport-container {
            flex: 1;
            position: relative;
            background: #1a1a1a;
        }

        #stats-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.75);
            padding: 10px 12px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.6;
            pointer-events: none;
            z-index: 10;
        }

        .stat-line {
            margin: 2px 0;
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            color: #0d9488;
            margin-left: 8px;
        }

        /* Viewport Mode Switcher */
        #viewport-mode {
            position: absolute;
            top: 10px;
            right: 280px;
            background: rgba(0, 0, 0, 0.75);
            padding: 6px;
            border-radius: 4px;
            display: flex;
            gap: 4px;
            z-index: 10;
        }

        .view-mode-btn {
            padding: 6px 12px;
            background: #2d2d2d;
            border: 1px solid #3a3a3a;
            color: #cccccc;
            cursor: pointer;
            border-radius: 3px;
            font-size: 11px;
            transition: all 0.2s;
        }

        .view-mode-btn:hover {
            background: #3e3e3e;
        }

        .view-mode-btn.active {
            background: #0d9488;
            border-color: #0d9488;
            color: white;
        }

        /* Right Panel - Properties */
        #right-panel {
            width: 320px;
            background: #252526;
            border-left: 1px solid #1a1a1a;
            display: flex;
            flex-direction: column;
        }

        #properties-panel {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .property-section {
            background: #2d2d2d;
            margin-bottom: 8px;
            border-radius: 4px;
            overflow: hidden;
        }

        .property-section-header {
            padding: 10px 12px;
            background: #323233;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            font-weight: 600;
            font-size: 12px;
        }

        .property-section-header:hover {
            background: #3a3a3a;
        }

        .section-toggle {
            margin-right: 8px;
            transition: transform 0.2s;
        }

        .property-section.collapsed .section-toggle {
            transform: rotate(-90deg);
        }

        .property-section-content {
            padding: 12px;
        }

        .property-section.collapsed .property-section-content {
            display: none;
        }

        .property-row {
            margin-bottom: 12px;
        }

        .property-label {
            display: block;
            margin-bottom: 4px;
            font-size: 11px;
            color: #9d9d9d;
        }

        .property-input {
            width: 100%;
            padding: 6px 8px;
            background: #1e1e1e;
            border: 1px solid #3a3a3a;
            color: #cccccc;
            border-radius: 3px;
            font-size: 12px;
        }

        .property-input:focus {
            outline: none;
            border-color: #0d9488;
        }

        .property-input-group {
            display: flex;
            gap: 4px;
        }

        .property-input-group .property-input {
            flex: 1;
        }

        .axis-label {
            width: 20px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #2d2d2d;
            border: 1px solid #3a3a3a;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
        }

        .axis-label.x { color: #ef4444; }
        .axis-label.y { color: #22c55e; }
        .axis-label.z { color: #3b82f6; }

        .property-slider {
            width: 100%;
            margin-top: 4px;
        }

        .property-color {
            width: 100%;
            height: 32px;
            border: 1px solid #3a3a3a;
            border-radius: 3px;
            cursor: pointer;
        }

        .property-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .property-checkbox input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .property-select {
            width: 100%;
            padding: 6px 8px;
            background: #1e1e1e;
            border: 1px solid #3a3a3a;
            color: #cccccc;
            border-radius: 3px;
            font-size: 12px;
            cursor: pointer;
        }

        /* Buttons */
        .btn {
            padding: 8px 16px;
            background: #0d9488;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 500;
            transition: background 0.2s;
            width: 100%;
            margin-top: 8px;
        }

        .btn:hover {
            background: #0f766e;
        }

        .btn-secondary {
            background: #3a3a3a;
        }

        .btn-secondary:hover {
            background: #4a4a4a;
        }

        .btn-danger {
            background: #dc2626;
        }

        .btn-danger:hover {
            background: #b91c1c;
        }

        /* Layers Panel */
        #layers-panel {
            background: #2d2d2d;
            border-top: 1px solid #1a1a1a;
            height: 180px;
            padding: 8px;
        }

        .layers-header {
            font-size: 11px;
            font-weight: 600;
            margin-bottom: 8px;
            text-transform: uppercase;
            color: #9d9d9d;
        }

        .layer-item {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            background: #252526;
            margin-bottom: 4px;
            border-radius: 3px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .layer-item:hover {
            background: #2a2d2e;
        }

        .layer-item.active {
            background: #094771;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: #1e1e1e;
        }

        ::-webkit-scrollbar-thumb {
            background: #3a3a3a;
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #4a4a4a;
        }

        /* Value Display */
        .value-display {
            float: right;
            color: #0d9488;
            font-weight: 600;
        }

        /* Transform Gizmo Mode Buttons */
        #gizmo-mode {
            position: absolute;
            top: 60px;
            right: 280px;
            background: rgba(0, 0, 0, 0.75);
            padding: 6px;
            border-radius: 4px;
            display: flex;
            gap: 4px;
            z-index: 10;
        }

        .gizmo-btn {
            width: 32px;
            height: 32px;
            background: #2d2d2d;
            border: 1px solid #3a3a3a;
            color: #cccccc;
            cursor: pointer;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: all 0.2s;
        }

        .gizmo-btn:hover {
            background: #3e3e3e;
        }

        .gizmo-btn.active {
            background: #0d9488;
            border-color: #0d9488;
            color: white;
        }

        /* File Input */
        input[type="file"] {
            display: none;
        }

        .file-upload-label {
            display: block;
            padding: 8px 16px;
            background: #3a3a3a;
            text-align: center;
            border-radius: 3px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .file-upload-label:hover {
            background: #4a4a4a;
        }

        /* Dropdown Menu */
        .dropdown {
            position: relative;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: #2d2d2d;
            border: 1px solid #1a1a1a;
            border-radius: 4px;
            min-width: 160px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            z-index: 1000;
        }

        .dropdown:hover .dropdown-content {
            display: block;
        }

        .dropdown-item {
            padding: 8px 12px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .dropdown-item:hover {
            background: #3e3e3e;
        }

        /* Number Spinner */
        .number-spinner {
            display: flex;
            align-items: center;
        }

        .number-spinner input {
            flex: 1;
            text-align: center;
        }

        .spinner-btn {
            width: 24px;
            height: 14px;
            background: #2d2d2d;
            border: 1px solid #3a3a3a;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            user-select: none;
        }

        .spinner-btn:hover {
            background: #3e3e3e;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: #2d2d2d;
            border-radius: 8px;
            width: 90%;
            max-width: 800px;
            max-height: 85vh;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 16px 20px;
            background: #323233;
            border-bottom: 1px solid #1a1a1a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 16px;
            font-weight: 600;
            color: #0d9488;
        }

        .modal-close {
            background: none;
            border: none;
            color: #999;
            font-size: 24px;
            cursor: pointer;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .modal-close:hover {
            background: #3e3e3e;
            color: #fff;
        }

        .modal-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .modal-footer {
            padding: 16px 20px;
            background: #252526;
            border-top: 1px solid #1a1a1a;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .modal-footer .btn {
            width: auto;
            margin-top: 0;
        }

        /* Projector Library Grid */
        .projector-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }

        .projector-card {
            background: #252526;
            border: 2px solid #3a3a3a;
            border-radius: 6px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .projector-card:hover {
            border-color: #0d9488;
            background: #2a2d2e;
        }

        .projector-card.selected {
            border-color: #0d9488;
            background: #094771;
        }

        .projector-brand {
            font-size: 10px;
            color: #999;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .projector-model {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .projector-specs {
            font-size: 10px;
            color: #666;
            line-height: 1.4;
        }

        /* Lens Selection */
        .lens-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .lens-item {
            background: #252526;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            padding: 10px 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .lens-item:hover {
            border-color: #0d9488;
            background: #2a2d2e;
        }

        .lens-item.selected {
            border-color: #0d9488;
            background: #094771;
        }

        .lens-name {
            font-size: 12px;
            font-weight: 500;
        }

        .lens-specs {
            font-size: 10px;
            color: #666;
        }

        .modal-section {
            margin-bottom: 24px;
        }

        .modal-section-title {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #0d9488;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Target Point Indicator */
        .target-point {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #ff0000 0%, rgba(255,0,0,0.3) 70%, transparent 100%);
            border: 2px solid #ff0000;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
        }

        .target-point::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 6px;
            background: #ff0000;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        /* Projector Info Overlay */
        .projector-info-overlay {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            padding: 8px 10px;
            border-radius: 4px;
            font-size: 10px;
            pointer-events: none;
            white-space: nowrap;
            border: 1px solid #0d9488;
        }

        .projector-info-overlay .info-line {
            margin: 2px 0;
        }

        .projector-info-overlay .info-label {
            color: #999;
        }

        .projector-info-overlay .info-value {
            color: #0d9488;
            font-weight: 600;
            margin-left: 4px;
        }

        /* Search Input */
        .search-input {
            width: 100%;
            padding: 10px 12px;
            background: #1e1e1e;
            border: 1px solid #3a3a3a;
            color: #cccccc;
            border-radius: 4px;
            font-size: 13px;
            margin-bottom: 16px;
        }

        .search-input:focus {
            outline: none;
            border-color: #0d9488;
        }

        .search-input::placeholder {
            color: #666;
        }
    </style>
</head>
<body>
    <!-- Projector Creation Modal -->
    <div id="projector-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Add Projector</h2>
                <button class="modal-close" onclick="closeProjectorModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="modal-section">
                    <div class="modal-section-title">1. Select Projector Model</div>
                    <input type="text" class="search-input" id="projector-search" placeholder="Search projectors..." oninput="filterProjectors()">
                    <div class="projector-grid" id="projector-grid">
                        <!-- Projectors will be populated here -->
                    </div>
                </div>

                <div class="modal-section" id="lens-section" style="display: none;">
                    <div class="modal-section-title">2. Select Lens</div>
                    <div class="lens-list" id="lens-list">
                        <!-- Lenses will be populated here -->
                    </div>
                </div>

                <div class="modal-section" id="config-section" style="display: none;">
                    <div class="modal-section-title">3. Configuration</div>
                    <div class="property-row">
                        <label class="property-label">Projector Name</label>
                        <input type="text" class="property-input" id="new-projector-name" placeholder="My Projector">
                    </div>
                    <div class="property-row">
                        <label class="property-label">Position</label>
                        <div class="property-input-group">
                            <span class="axis-label x">X</span>
                            <input type="number" class="property-input" id="new-proj-x" value="0" step="0.5">
                            <span class="axis-label y">Y</span>
                            <input type="number" class="property-input" id="new-proj-y" value="5" step="0.5">
                            <span class="axis-label z">Z</span>
                            <input type="number" class="property-input" id="new-proj-z" value="5" step="0.5">
                        </div>
                    </div>
                    <div class="property-row">
                        <label class="property-label">Target Point</label>
                        <div class="property-input-group">
                            <span class="axis-label x">X</span>
                            <input type="number" class="property-input" id="new-target-x" value="0" step="0.5">
                            <span class="axis-label y">Y</span>
                            <input type="number" class="property-input" id="new-target-y" value="0" step="0.5">
                            <span class="axis-label z">Z</span>
                            <input type="number" class="property-input" id="new-target-z" value="0" step="0.5">
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeProjectorModal()">Cancel</button>
                <button class="btn" id="create-projector-btn" onclick="createProjectorFromModal()" disabled>Create Projector</button>
            </div>
        </div>
    </div>

    <!-- Image Import Modal -->
    <div id="image-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Import Projector Image</h2>
                <button class="modal-close" onclick="closeImageModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="modal-section">
                    <div class="modal-section-title">Select Image or Video</div>
                    <input type="file" id="projector-image-input" accept="image/*,video/*" style="display: none;" onchange="handleImageUpload(event)">
                    <label for="projector-image-input" class="file-upload-label" style="display: block;">
                        Choose File
                    </label>
                    <div id="image-preview" style="margin-top: 16px; text-align: center;">
                        <!-- Preview will be shown here -->
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeImageModal()">Cancel</button>
                <button class="btn" onclick="applyProjectorImage()" id="apply-image-btn" disabled>Apply Image</button>
            </div>
        </div>
    </div>

    <!-- Array & Symmetry Modal -->
    <div id="array-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="array-modal-title">Create Array</h2>
                <button class="modal-close" onclick="closeArrayModal()">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Linear Array Settings -->
                <div id="linear-array-settings" style="display: none;">
                    <div class="modal-section">
                        <div class="modal-section-title">Linear Array Settings</div>
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; margin-bottom: 6px; color: #ccc;">Count</label>
                            <input type="number" id="linear-count" value="5" min="2" max="50" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px;">
                        </div>
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; margin-bottom: 6px; color: #ccc;">Direction</label>
                            <select id="linear-direction" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px;">
                                <option value="x">X Axis</option>
                                <option value="y">Y Axis</option>
                                <option value="z">Z Axis</option>
                            </select>
                        </div>
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; margin-bottom: 6px; color: #ccc;">Spacing</label>
                            <input type="number" id="linear-spacing" value="2" min="0.1" step="0.1" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px;">
                        </div>
                    </div>
                </div>

                <!-- Polar Array Settings -->
                <div id="polar-array-settings" style="display: none;">
                    <div class="modal-section">
                        <div class="modal-section-title">Polar Array Settings</div>
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; margin-bottom: 6px; color: #ccc;">Count</label>
                            <input type="number" id="polar-count" value="8" min="2" max="50" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px;">
                        </div>
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; margin-bottom: 6px; color: #ccc;">Axis</label>
                            <select id="polar-axis" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px;">
                                <option value="y">Y Axis (Vertical)</option>
                                <option value="x">X Axis</option>
                                <option value="z">Z Axis</option>
                            </select>
                        </div>
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; margin-bottom: 6px; color: #ccc;">Radius</label>
                            <input type="number" id="polar-radius" value="5" min="0.1" step="0.1" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px;">
                        </div>
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; margin-bottom: 6px; color: #ccc;">Angle (degrees)</label>
                            <input type="number" id="polar-angle" value="360" min="1" max="360" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px;">
                        </div>
                    </div>
                </div>

                <!-- Mirror Symmetry Settings -->
                <div id="mirror-settings" style="display: none;">
                    <div class="modal-section">
                        <div class="modal-section-title">Mirror Symmetry Settings</div>
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; margin-bottom: 6px; color: #ccc;">Mirror Axis</label>
                            <select id="mirror-axis" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px;">
                                <option value="x">X Axis (Left/Right)</option>
                                <option value="y">Y Axis (Up/Down)</option>
                                <option value="z">Z Axis (Front/Back)</option>
                            </select>
                        </div>
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; margin-bottom: 6px; color: #ccc;">Mirror Position</label>
                            <input type="number" id="mirror-position" value="0" step="0.1" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px;">
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeArrayModal()">Cancel</button>
                <button class="btn" id="create-array-btn" onclick="executeArrayOperation()">Create</button>
            </div>
        </div>
    </div>

    <!-- Top Menu Bar -->
    <div id="menubar">
        <div class="menu-item dropdown">
            File
            <div class="dropdown-content">
                <div class="dropdown-item" onclick="newProject()">New Project</div>
                <div class="dropdown-item" onclick="saveProject()">Save Project</div>
                <div class="dropdown-item" onclick="loadProject()">Load Project</div>
                <div class="dropdown-item" onclick="exportScene()">Export Scene</div>
            </div>
        </div>
        <div class="menu-item dropdown">
            Edit
            <div class="dropdown-content">
                <div class="dropdown-item" onclick="undo()">Undo</div>
                <div class="dropdown-item" onclick="redo()">Redo</div>
                <div class="dropdown-item" onclick="duplicateObject()">Duplicate</div>
                <div class="dropdown-item" onclick="deleteSelected()">Delete</div>
            </div>
        </div>
        <div class="menu-item dropdown">
            Viewport
            <div class="dropdown-content">
                <div class="dropdown-item" onclick="setViewMode('perspective')">Perspective</div>
                <div class="dropdown-item" onclick="setViewMode('top')">Top View</div>
                <div class="dropdown-item" onclick="setViewMode('front')">Front View</div>
                <div class="dropdown-item" onclick="setViewMode('side')">Side View</div>
            </div>
        </div>
        <div class="menu-item dropdown">
            Array/Sym.
            <div class="dropdown-content">
                <div class="dropdown-item" onclick="createLinearArray()">Linear Array</div>
                <div class="dropdown-item" onclick="createPolarArray()">Polar Array</div>
                <div class="dropdown-item" onclick="createMirrorSymmetry()">Mirror Symmetry</div>
            </div>
        </div>
        <div class="menu-item dropdown">
            Tools
            <div class="dropdown-content">
                <div class="dropdown-item" onclick="addAnnotation()">Add Annotation (A)</div>
                <div class="dropdown-item" onclick="measureDistance()">Measure Distance (T)</div>
                <div class="dropdown-item" onclick="togglePhotometric()">Photometric Analysis</div>
            </div>
        </div>
        <div class="menu-item dropdown">
            Masking
            <div class="dropdown-content">
                <div class="dropdown-item" onclick="addExclusionBox()">Box Exclusion Zone</div>
                <div class="dropdown-item" onclick="addExclusionSphere()">Sphere Exclusion Zone</div>
                <div class="dropdown-item" onclick="addExclusionCylinder()">Cylinder Exclusion Zone</div>
                <div class="dropdown-item" onclick="addExclusionPlane()">Plane Exclusion Zone</div>
            </div>
        </div>
        <div class="menu-item dropdown">
            Primitives
            <div class="dropdown-content">
                <div class="dropdown-item" onclick="addPrimitive('box')">Box</div>
                <div class="dropdown-item" onclick="addPrimitive('sphere')">Sphere</div>
                <div class="dropdown-item" onclick="addPrimitive('cylinder')">Cylinder</div>
                <div class="dropdown-item" onclick="addPrimitive('plane')">Plane</div>
                <div class="dropdown-item" onclick="addPrimitive('torus')">Torus</div>
            </div>
        </div>
        <div class="menu-separator"></div>
        <div class="menu-item" onclick="openProjectorModal()">+ Add Projector</div>
        <div class="menu-item" onclick="addCamera()">+ Add Camera</div>
    </div>

    <!-- Main Container -->
    <div id="main-container">
        <!-- Left Panel - Scene Objects -->
        <div id="left-panel">
            <div class="panel-header">Scene Objects</div>
            <div id="scene-objects-list">
                <!-- Scene objects will be populated here -->
            </div>
        </div>

        <!-- Center - Viewport -->
        <div id="viewport-container">
            <div id="stats-overlay">
                <div class="stat-line"><span class="stat-label">FPS:</span><span class="stat-value" id="fps">0</span></div>
                <div class="stat-line"><span class="stat-label">Objects:</span><span class="stat-value" id="object-count">0</span></div>
                <div class="stat-line"><span class="stat-label">Projectors:</span><span class="stat-value" id="projector-count">0</span></div>
                <div class="stat-line"><span class="stat-label">Triangles:</span><span class="stat-value" id="tri-count">0</span></div>
            </div>

            <div id="viewport-mode">
                <button class="view-mode-btn" onclick="toggleRenderMode('normal')">Normal</button>
                <button class="view-mode-btn" onclick="toggleRenderMode('illuminance')">Illuminance</button>
                <button class="view-mode-btn" onclick="toggleRenderMode('luminance')">Luminance</button>
            </div>

            <div id="gizmo-mode">
                <button class="gizmo-btn active" onclick="setGizmoMode('translate')" title="Translate (G)">⟷</button>
                <button class="gizmo-btn" onclick="setGizmoMode('rotate')" title="Rotate (R)">↻</button>
                <button class="gizmo-btn" onclick="setGizmoMode('scale')" title="Scale (S)">⊡</button>
            </div>
        </div>

        <!-- Right Panel - Properties -->
        <div id="right-panel">
            <div class="panel-header">Properties</div>
            <div id="properties-panel">
                <div id="no-selection" style="padding: 20px; text-align: center; color: #666;">
                    No object selected
                </div>
                <!-- Properties will be populated when object is selected -->
            </div>

            <!-- Layers Panel -->
            <div id="layers-panel">
                <div class="layers-header">Layers / Layouts</div>
                <div class="layer-item active">
                    <span>● Default Layer</span>
                </div>
                <div class="layer-item">
                    <span>○ Projection Layer</span>
                </div>
                <div class="layer-item">
                    <span>○ Lighting Layer</span>
                </div>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Function to create rectangular projection texture
        function createRectangularProjectionTexture(aspectRatio) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');

            // Clear to black
            ctx.fillStyle = 'rgb(0, 0, 0)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw white rectangle based on aspect ratio
            ctx.fillStyle = 'rgb(255, 255, 255)';

            let rectWidth, rectHeight;

            if (aspectRatio >= 1) {
                // Landscape (16:9, 16:10, etc.)
                rectWidth = canvas.width;
                rectHeight = canvas.width / aspectRatio;
            } else {
                // Portrait (rare)
                rectHeight = canvas.height;
                rectWidth = canvas.height * aspectRatio;
            }

            const x = (canvas.width - rectWidth) / 2;
            const y = (canvas.height - rectHeight) / 2;

            // Fill the rectangle
            ctx.fillRect(x, y, rectWidth, rectHeight);

            // Create texture with proper settings
            const texture = new THREE.CanvasTexture(canvas);
            texture.center.set(0.5, 0.5);
            texture.rotation = 0;
            texture.needsUpdate = true;

            return texture;
        }

        // Custom Rectangular Frustum Helper for Projectors
        class RectangularFrustumHelper extends THREE.LineSegments {
            constructor(light, resolution) {
                // Parse aspect ratio from resolution (e.g., "4096x2160" or "1920x1080")
                const [width, height] = resolution.split('x').map(Number);
                const aspectRatio = width / height;

                const geometry = new THREE.BufferGeometry();
                const material = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    fog: false,
                    toneMapped: false
                });

                super(geometry, material);

                this.light = light;
                this.aspectRatio = aspectRatio;
                this.matrix = light.matrixWorld;
                this.matrixAutoUpdate = false;
                this.color = material.color;

                this.type = 'RectangularFrustumHelper';

                this.update();
            }

            update() {
                const light = this.light;
                const distance = light.distance ? light.distance : 1000;
                const angle = light.angle;
                const penumbra = light.penumbra;

                // Calculate frustum dimensions at distance
                const coneHeight = distance;
                const coneWidth = Math.tan(angle) * distance;

                // Apply aspect ratio to create rectangular frustum
                let width, height;
                if (this.aspectRatio >= 1) {
                    // Landscape (16:9, etc.)
                    width = coneWidth * 2;
                    height = width / this.aspectRatio;
                } else {
                    // Portrait (rare, but handled)
                    height = coneWidth * 2;
                    width = height * this.aspectRatio;
                }

                const positions = [];

                // Apex (projector position)
                const apex = [0, 0, 0];

                // Four corners of rectangle at distance
                const halfWidth = width / 2;
                const halfHeight = height / 2;

                const corners = [
                    [-halfWidth, halfHeight, -coneHeight],   // Top-left
                    [halfWidth, halfHeight, -coneHeight],    // Top-right
                    [halfWidth, -halfHeight, -coneHeight],   // Bottom-right
                    [-halfWidth, -halfHeight, -coneHeight]   // Bottom-left
                ];

                // Lines from apex to each corner
                for (let i = 0; i < 4; i++) {
                    positions.push(...apex);
                    positions.push(...corners[i]);
                }

                // Rectangle at the end (connecting corners)
                for (let i = 0; i < 4; i++) {
                    positions.push(...corners[i]);
                    positions.push(...corners[(i + 1) % 4]);
                }

                // Add penumbra indicator (inner rectangle)
                if (penumbra > 0) {
                    const penumbraScale = 1 - penumbra * 0.5;
                    const penumbraCorners = corners.map(corner => [
                        corner[0] * penumbraScale,
                        corner[1] * penumbraScale,
                        corner[2]
                    ]);

                    for (let i = 0; i < 4; i++) {
                        positions.push(...penumbraCorners[i]);
                        positions.push(...penumbraCorners[(i + 1) % 4]);
                    }
                }

                const positionArray = new Float32Array(positions);
                this.geometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
                this.geometry.computeBoundingSphere();

                // Update color to match light color
                this.color.copy(this.light.color);
            }

            dispose() {
                this.geometry.dispose();
                this.material.dispose();
            }
        }

        // Projector Library Database
        const PROJECTOR_LIBRARY = [
            {
                id: 'barco-uhd-4k32',
                brand: 'Barco',
                model: 'UDX-4K32',
                lumens: 31000,
                resolution: '4096x2160',
                lenses: ['lens-uhd-0.38-0.6', 'lens-uhd-0.73-1.06', 'lens-uhd-1.16-1.49', 'lens-uhd-1.52-2.89', 'lens-uhd-3.0-6.5']
            },
            {
                id: 'christie-m-4k25',
                brand: 'Christie',
                model: 'Griffyn 4K32-RGB',
                lumens: 28000,
                resolution: '4096x2160',
                lenses: ['lens-christie-0.38', 'lens-christie-0.67-0.9', 'lens-christie-0.9-1.18', 'lens-christie-1.18-1.5']
            },
            {
                id: 'panasonic-pt-rz31k',
                brand: 'Panasonic',
                model: 'PT-RZ31K',
                lumens: 31000,
                resolution: '1920x1200',
                lenses: ['lens-pana-et-dle055', 'lens-pana-et-dle085', 'lens-pana-et-dle150', 'lens-pana-et-dle250', 'lens-pana-et-dle350', 'lens-pana-et-dle450']
            },
            {
                id: 'barco-f70',
                brand: 'Barco',
                model: 'F70-4K7',
                lumens: 6500,
                resolution: '3840x2160',
                lenses: ['lens-f70-en11', 'lens-f70-en12', 'lens-f70-en13', 'lens-f70-en14', 'lens-f70-en15']
            },
            {
                id: 'christie-boxer',
                brand: 'Christie',
                model: 'Boxer 4K30',
                lumens: 28500,
                resolution: '4096x2160',
                lenses: ['lens-boxer-0.38', 'lens-boxer-0.67-0.9', 'lens-boxer-1.16-1.49', 'lens-boxer-1.45-2.17']
            },
            {
                id: 'epson-eb-l25000u',
                brand: 'Epson',
                model: 'EB-L25000U',
                lumens: 25000,
                resolution: '1920x1200',
                lenses: ['lens-epson-elplm08', 'lens-epson-elplm09', 'lens-epson-elplm10', 'lens-epson-elplm11', 'lens-epson-elplm15']
            },
            {
                id: 'nec-ph3501ql',
                brand: 'NEC',
                model: 'PH3501QL',
                lumens: 35000,
                resolution: '4096x2160',
                lenses: ['lens-nec-np41zl', 'lens-nec-np42zl', 'lens-nec-np43zl', 'lens-nec-np44zl']
            },
            {
                id: 'sony-srx-r515ds',
                brand: 'Sony',
                model: 'SRX-R515DS',
                lumens: 15000,
                resolution: '4096x2160',
                lenses: ['lens-sony-0.9-1.2', 'lens-sony-1.2-1.85', 'lens-sony-1.85-2.7', 'lens-sony-2.7-4.1']
            },
            {
                id: 'digital-projection-m-vision',
                brand: 'Digital Projection',
                model: 'M-Vision 21000',
                lumens: 21000,
                resolution: '1920x1200',
                lenses: ['lens-dp-0.75-0.93', 'lens-dp-0.93-1.22', 'lens-dp-1.22-1.52', 'lens-dp-1.52-2.92']
            },
            {
                id: 'panasonic-pt-rq50k',
                brand: 'Panasonic',
                model: 'PT-RQ50K',
                lumens: 50000,
                resolution: '4096x2160',
                lenses: ['lens-pana-rq-et-dle055', 'lens-pana-rq-et-dle085', 'lens-pana-rq-et-dle150']
            }
        ];

        const LENS_LIBRARY = {
            // Barco UDX Lenses
            'lens-uhd-0.38-0.6': { name: 'TLD+ 0.38-0.6:1', throwRatio: 0.49, type: 'Ultra Short Throw' },
            'lens-uhd-0.73-1.06': { name: 'TLD+ 0.73-1.06:1', throwRatio: 0.895, type: 'Short Throw' },
            'lens-uhd-1.16-1.49': { name: 'TLD+ 1.16-1.49:1', throwRatio: 1.325, type: 'Standard' },
            'lens-uhd-1.52-2.89': { name: 'TLD+ 1.52-2.89:1', throwRatio: 2.205, type: 'Medium Throw' },
            'lens-uhd-3.0-6.5': { name: 'TLD+ 3.0-6.5:1', throwRatio: 4.75, type: 'Long Throw' },

            // Christie Lenses
            'lens-christie-0.38': { name: '0.38:1 Fixed Ultra Short', throwRatio: 0.38, type: 'Ultra Short Throw' },
            'lens-christie-0.67-0.9': { name: '0.67-0.9:1 Zoom', throwRatio: 0.785, type: 'Short Throw' },
            'lens-christie-0.9-1.18': { name: '0.9-1.18:1 Zoom', throwRatio: 1.04, type: 'Standard' },
            'lens-christie-1.18-1.5': { name: '1.18-1.5:1 Zoom', throwRatio: 1.34, type: 'Standard' },

            // Panasonic Lenses
            'lens-pana-et-dle055': { name: 'ET-DLE055 (0.8:1)', throwRatio: 0.8, type: 'Short Throw' },
            'lens-pana-et-dle085': { name: 'ET-DLE085 (0.8-1.0:1)', throwRatio: 0.9, type: 'Short Throw' },
            'lens-pana-et-dle150': { name: 'ET-DLE150 (1.5-1.8:1)', throwRatio: 1.65, type: 'Standard' },
            'lens-pana-et-dle250': { name: 'ET-DLE250 (2.4-3.7:1)', throwRatio: 3.05, type: 'Medium Throw' },
            'lens-pana-et-dle350': { name: 'ET-DLE350 (3.5-5.4:1)', throwRatio: 4.45, type: 'Long Throw' },
            'lens-pana-et-dle450': { name: 'ET-DLE450 (5.4-8.6:1)', throwRatio: 7.0, type: 'Long Throw' },

            // Barco F70 Lenses
            'lens-f70-en11': { name: 'EN11 (0.8:1)', throwRatio: 0.8, type: 'Short Throw' },
            'lens-f70-en12': { name: 'EN12 (1.16-1.49:1)', throwRatio: 1.325, type: 'Standard' },
            'lens-f70-en13': { name: 'EN13 (1.43-2.17:1)', throwRatio: 1.8, type: 'Standard' },
            'lens-f70-en14': { name: 'EN14 (2.1-3.8:1)', throwRatio: 2.95, type: 'Medium Throw' },
            'lens-f70-en15': { name: 'EN15 (3.5-6.0:1)', throwRatio: 4.75, type: 'Long Throw' },

            // Christie Boxer Lenses
            'lens-boxer-0.38': { name: '0.38:1 Fixed', throwRatio: 0.38, type: 'Ultra Short Throw' },
            'lens-boxer-0.67-0.9': { name: '0.67-0.9:1 Zoom', throwRatio: 0.785, type: 'Short Throw' },
            'lens-boxer-1.16-1.49': { name: '1.16-1.49:1 Zoom', throwRatio: 1.325, type: 'Standard' },
            'lens-boxer-1.45-2.17': { name: '1.45-2.17:1 Zoom', throwRatio: 1.81, type: 'Standard' },

            // Epson Lenses
            'lens-epson-elplm08': { name: 'ELPLM08 (1.45-2.33:1)', throwRatio: 1.89, type: 'Standard' },
            'lens-epson-elplm09': { name: 'ELPLM09 (2.25-3.65:1)', throwRatio: 2.95, type: 'Medium Throw' },
            'lens-epson-elplm10': { name: 'ELPLM10 (3.5-5.5:1)', throwRatio: 4.5, type: 'Long Throw' },
            'lens-epson-elplm11': { name: 'ELPLM11 (5.3-8.7:1)', throwRatio: 7.0, type: 'Long Throw' },
            'lens-epson-elplm15': { name: 'ELPLM15 (0.84:1)', throwRatio: 0.84, type: 'Short Throw' },

            // NEC Lenses
            'lens-nec-np41zl': { name: 'NP41ZL (0.88-1.08:1)', throwRatio: 0.98, type: 'Short Throw' },
            'lens-nec-np42zl': { name: 'NP42ZL (1.16-1.52:1)', throwRatio: 1.34, type: 'Standard' },
            'lens-nec-np43zl': { name: 'NP43ZL (1.50-3.02:1)', throwRatio: 2.26, type: 'Medium Throw' },
            'lens-nec-np44zl': { name: 'NP44ZL (2.99-5.93:1)', throwRatio: 4.46, type: 'Long Throw' },

            // Sony Lenses
            'lens-sony-0.9-1.2': { name: 'VPLL-Z1032 (0.9-1.2:1)', throwRatio: 1.05, type: 'Short Throw' },
            'lens-sony-1.2-1.85': { name: 'VPLL-Z1025 (1.2-1.85:1)', throwRatio: 1.525, type: 'Standard' },
            'lens-sony-1.85-2.7': { name: 'VPLL-Z1045 (1.85-2.7:1)', throwRatio: 2.275, type: 'Medium Throw' },
            'lens-sony-2.7-4.1': { name: 'VPLL-Z1050 (2.7-4.1:1)', throwRatio: 3.4, type: 'Long Throw' },

            // Digital Projection Lenses
            'lens-dp-0.75-0.93': { name: 'Short 0.75-0.93:1', throwRatio: 0.84, type: 'Short Throw' },
            'lens-dp-0.93-1.22': { name: 'Standard 0.93-1.22:1', throwRatio: 1.075, type: 'Standard' },
            'lens-dp-1.22-1.52': { name: 'Medium 1.22-1.52:1', throwRatio: 1.37, type: 'Standard' },
            'lens-dp-1.52-2.92': { name: 'Long 1.52-2.92:1', throwRatio: 2.22, type: 'Medium Throw' },

            // Panasonic RQ Lenses
            'lens-pana-rq-et-dle055': { name: 'ET-DLE055 (0.8:1)', throwRatio: 0.8, type: 'Short Throw' },
            'lens-pana-rq-et-dle085': { name: 'ET-DLE085 (0.8-1.0:1)', throwRatio: 0.9, type: 'Short Throw' },
            'lens-pana-rq-et-dle150': { name: 'ET-DLE150 (1.5-1.8:1)', throwRatio: 1.65, type: 'Standard' }
        };

        // Global State
        let scene, camera, renderer, controls, transformControls;
        let sceneObjects = [];
        let projectors = [];
        let selectedObject = null;
        let gizmoMode = 'translate';
        let renderMode = 'normal';
        let gridHelper, axesHelper;
        let humanReference;

        // Modal State
        let selectedProjectorModel = null;
        let selectedLens = null;
        let currentProjectorImage = null;

        // Performance tracking
        let frameCount = 0;
        let lastTime = performance.now();

        // Initialize
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            scene.fog = new THREE.Fog(0x1a1a1a, 50, 100);

            // Camera
            const container = document.getElementById('viewport-container');
            camera = new THREE.PerspectiveCamera(
                60,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(15, 10, 15);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            container.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 1;
            controls.maxDistance = 100;
            controls.maxPolarAngle = Math.PI / 2;

            // Transform Controls
            transformControls = new TransformControls(camera, renderer.domElement);
            transformControls.addEventListener('dragging-changed', (event) => {
                controls.enabled = !event.value;
            });
            transformControls.addEventListener('objectChange', () => {
                // Check if we're moving a projector target
                const obj = transformControls.object;
                if (obj && obj.userData.type === 'projector_target') {
                    const projector = obj.userData.parentProjector;
                    if (projector && projector.userData.target) {
                        // Update projector's target position
                        projector.userData.target.position.copy(obj.position);
                        projector.target.position.copy(obj.position);

                        // Update helper
                        if (projector.userData.helper) {
                            projector.userData.helper.update();
                        }
                    }
                }
                updatePropertiesPanel();
            });
            scene.add(transformControls);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            // Grid
            gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x222222);
            scene.add(gridHelper);

            // Axes
            axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);

            // Human Reference (180cm tall)
            createHumanReference();

            // Floor
            const floorGeometry = new THREE.PlaneGeometry(100, 100);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a2a2a,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            floor.userData.name = 'Floor';
            floor.userData.type = 'primitive';
            floor.userData.locked = true;
            scene.add(floor);
            sceneObjects.push(floor);

            // Add initial objects
            addDefaultScene();

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);
            renderer.domElement.addEventListener('click', handleDimensionClick);

            // Start animation loop
            animate();

            // Update UI
            updateSceneObjectsList();
            updateStats();
        }

        function createHumanReference() {
            const humanGroup = new THREE.Group();

            // Body
            const bodyGeometry = new THREE.CapsuleGeometry(0.15, 1.4, 8, 16);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xffdd00, roughness: 0.5 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.9;
            body.castShadow = true;
            humanGroup.add(body);

            // Head
            const headGeometry = new THREE.SphereGeometry(0.12, 16, 16);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.y = 1.68;
            head.castShadow = true;
            humanGroup.add(head);

            humanGroup.userData.name = 'Human Reference (180cm)';
            humanGroup.userData.type = 'reference';
            humanGroup.userData.locked = false;

            scene.add(humanGroup);
            sceneObjects.push(humanGroup);
            humanReference = humanGroup;
        }

        function addDefaultScene() {
            // Add a default cube
            const geometry = new THREE.BoxGeometry(3, 3, 3);
            const material = new THREE.MeshStandardMaterial({
                color: 0x666666,
                roughness: 0.7,
                metalness: 0.3
            });
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(0, 1.5, 0);
            cube.castShadow = true;
            cube.receiveShadow = true;
            cube.userData.name = 'Cube';
            cube.userData.type = 'primitive';
            cube.userData.locked = false;
            scene.add(cube);
            sceneObjects.push(cube);

            // Add initial projector
            addProjector();
        }

        // ===== PROJECTOR MODAL FUNCTIONS =====

        function openProjectorModal() {
            selectedProjectorModel = null;
            selectedLens = null;
            document.getElementById('projector-modal').classList.add('show');
            document.getElementById('lens-section').style.display = 'none';
            document.getElementById('config-section').style.display = 'none';
            document.getElementById('create-projector-btn').disabled = true;
            populateProjectorGrid();
        }

        function closeProjectorModal() {
            document.getElementById('projector-modal').classList.remove('show');
        }

        function populateProjectorGrid() {
            const grid = document.getElementById('projector-grid');
            grid.innerHTML = '';

            PROJECTOR_LIBRARY.forEach(proj => {
                const card = document.createElement('div');
                card.className = 'projector-card';
                card.innerHTML = `
                    <div class="projector-brand">${proj.brand}</div>
                    <div class="projector-model">${proj.model}</div>
                    <div class="projector-specs">
                        ${proj.lumens.toLocaleString()} Lumens<br>
                        ${proj.resolution}
                    </div>
                `;
                card.onclick = () => selectProjectorModel(proj);
                grid.appendChild(card);
            });
        }

        function filterProjectors() {
            const search = document.getElementById('projector-search').value.toLowerCase();
            const cards = document.querySelectorAll('.projector-card');

            cards.forEach(card => {
                const text = card.textContent.toLowerCase();
                card.style.display = text.includes(search) ? 'block' : 'none';
            });
        }

        function selectProjectorModel(proj) {
            selectedProjectorModel = proj;

            // Highlight selected
            document.querySelectorAll('.projector-card').forEach(card => {
                card.classList.remove('selected');
            });
            event.target.closest('.projector-card').classList.add('selected');

            // Show lens section
            document.getElementById('lens-section').style.display = 'block';
            populateLenses(proj.lenses);

            // Scroll to lens section
            document.getElementById('lens-section').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function populateLenses(lensIds) {
            const list = document.getElementById('lens-list');
            list.innerHTML = '';

            lensIds.forEach(lensId => {
                const lens = LENS_LIBRARY[lensId];
                const item = document.createElement('div');
                item.className = 'lens-item';
                item.innerHTML = `
                    <div>
                        <div class="lens-name">${lens.name}</div>
                        <div class="lens-specs">${lens.type} • Throw Ratio: ${lens.throwRatio}</div>
                    </div>
                `;
                item.onclick = () => selectLens(lensId, lens);
                list.appendChild(item);
            });
        }

        function selectLens(lensId, lens) {
            selectedLens = { id: lensId, ...lens };

            // Highlight selected
            document.querySelectorAll('.lens-item').forEach(item => {
                item.classList.remove('selected');
            });
            event.target.closest('.lens-item').classList.add('selected');

            // Show configuration section
            document.getElementById('config-section').style.display = 'block';
            document.getElementById('create-projector-btn').disabled = false;

            // Set default name
            const projCount = projectors.length + 1;
            document.getElementById('new-projector-name').value =
                `${selectedProjectorModel.brand} ${selectedProjectorModel.model} #${projCount}`;

            // Scroll to config
            document.getElementById('config-section').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function createProjectorFromModal() {
            if (!selectedProjectorModel || !selectedLens) return;

            const name = document.getElementById('new-projector-name').value ||
                        `${selectedProjectorModel.brand} ${selectedProjectorModel.model}`;

            const posX = parseFloat(document.getElementById('new-proj-x').value);
            const posY = parseFloat(document.getElementById('new-proj-y').value);
            const posZ = parseFloat(document.getElementById('new-proj-z').value);

            const targetX = parseFloat(document.getElementById('new-target-x').value);
            const targetY = parseFloat(document.getElementById('new-target-y').value);
            const targetZ = parseFloat(document.getElementById('new-target-z').value);

            // Create spotlight with specs from library
            const color = new THREE.Color().setHSL(Math.random(), 0.8, 0.6);
            const lumensToIntensity = selectedProjectorModel.lumens / 200; // Scale factor
            const spotlight = new THREE.SpotLight(color, lumensToIntensity);

            spotlight.position.set(posX, posY, posZ);
            spotlight.angle = Math.PI / 6;
            spotlight.penumbra = 0.05; // Sharper edges for rectangular projection
            spotlight.decay = 2;
            spotlight.distance = 50;
            spotlight.castShadow = true;
            spotlight.shadow.mapSize.width = 2048;
            spotlight.shadow.mapSize.height = 2048;

            // Apply rectangular projection texture based on aspect ratio
            const [resWidth, resHeight] = selectedProjectorModel.resolution.split('x').map(Number);
            const aspectRatio = resWidth / resHeight;
            spotlight.map = createRectangularProjectionTexture(aspectRatio);

            // Create and position target
            const target = new THREE.Object3D();
            target.position.set(targetX, targetY, targetZ);
            scene.add(target);
            spotlight.target = target;

            // Make spotlight look at target
            spotlight.lookAt(targetX, targetY, targetZ);

            // Create rectangular frustum helper with proper aspect ratio
            const helper = new RectangularFrustumHelper(spotlight, selectedProjectorModel.resolution);
            scene.add(helper);

            // Create target point indicator (yellow sphere - selectable)
            const targetGeometry = new THREE.SphereGeometry(0.25, 32, 32);
            const targetMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                emissive: 0xffaa00,
                emissiveIntensity: 0.5
            });
            const targetIndicator = new THREE.Mesh(targetGeometry, targetMaterial);
            targetIndicator.position.copy(target.position);

            // Make target indicator selectable and transformable
            targetIndicator.userData = {
                type: 'projector_target',
                name: name + ' Target',
                locked: false,
                parentProjector: null // Will be set after spotlight is added
            };

            scene.add(targetIndicator);
            sceneObjects.push(targetIndicator);

            // Store complete projector data
            spotlight.userData = {
                name: name,
                type: 'projector',
                locked: false,
                helper: helper,
                target: target,
                targetIndicator: targetIndicator,
                lumens: selectedProjectorModel.lumens,
                throwRatio: selectedLens.throwRatio,
                resolution: selectedProjectorModel.resolution,
                lensShiftH: 0,
                lensShiftV: 0,
                brightnessFactor: 1.0,
                projectorModel: selectedProjectorModel,
                lensModel: selectedLens,
                brand: selectedProjectorModel.brand,
                model: selectedProjectorModel.model
            };

            scene.add(spotlight);
            sceneObjects.push(spotlight);
            projectors.push(spotlight);

            // Link target indicator to projector
            targetIndicator.userData.parentProjector = spotlight;

            updateSceneObjectsList();
            updateStats();
            closeProjectorModal();
        }

        // ===== IMAGE IMPORT FUNCTIONS =====

        function openImageModal() {
            if (!selectedObject || selectedObject.userData.type !== 'projector') {
                alert('Please select a projector first');
                return;
            }
            document.getElementById('image-modal').classList.add('show');
            document.getElementById('image-preview').innerHTML = '';
            document.getElementById('apply-image-btn').disabled = true;
        }

        function closeImageModal() {
            document.getElementById('image-modal').classList.remove('show');
            currentProjectorImage = null;
        }

        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const preview = document.getElementById('image-preview');

                if (file.type.startsWith('image/')) {
                    preview.innerHTML = `<img src="${e.target.result}" style="max-width: 100%; max-height: 300px; border-radius: 4px;">`;
                } else if (file.type.startsWith('video/')) {
                    preview.innerHTML = `<video src="${e.target.result}" style="max-width: 100%; max-height: 300px; border-radius: 4px;" controls></video>`;
                }

                currentProjectorImage = e.target.result;
                document.getElementById('apply-image-btn').disabled = false;
            };
            reader.readAsDataURL(file);
        }

        function applyProjectorImage() {
            if (!currentProjectorImage || !selectedObject) return;

            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(currentProjectorImage, (userTexture) => {
                // Get projector aspect ratio
                const resolution = selectedObject.userData.resolution || '1920x1080';
                const [resWidth, resHeight] = resolution.split('x').map(Number);
                const aspectRatio = resWidth / resHeight;

                // Create composite canvas (user image + rectangular mask)
                const canvas = document.createElement('canvas');
                canvas.width = 1024;
                canvas.height = 1024;
                const ctx = canvas.getContext('2d');

                // Calculate rectangle dimensions based on aspect ratio
                let rectWidth, rectHeight;
                if (aspectRatio >= 1) {
                    rectWidth = canvas.width;
                    rectHeight = canvas.width / aspectRatio;
                } else {
                    rectHeight = canvas.height;
                    rectWidth = canvas.height * aspectRatio;
                }

                const x = (canvas.width - rectWidth) / 2;
                const y = (canvas.height - rectHeight) / 2;

                // Clear to black
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Create clipping region for rectangle
                ctx.save();
                ctx.beginPath();
                ctx.rect(x, y, rectWidth, rectHeight);
                ctx.clip();

                // Draw user's image inside the rectangle
                ctx.drawImage(userTexture.image, x, y, rectWidth, rectHeight);
                ctx.restore();

                // Create texture from composite canvas
                const compositeTexture = new THREE.CanvasTexture(canvas);
                compositeTexture.center.set(0.5, 0.5);
                compositeTexture.needsUpdate = true;

                // Apply composite texture to spotlight
                selectedObject.map = compositeTexture;
                selectedObject.userData.projectorTexture = currentProjectorImage;
                selectedObject.userData.hasCustomImage = true;

                closeImageModal();
                updatePropertiesPanel();
            });
        }

        // Add button to properties panel for image import
        window.openImageModal = openImageModal;

        // ===== ARRAY & SYMMETRY FUNCTIONS =====

        let currentArrayType = '';

        function createLinearArray() {
            if (!selectedObject) {
                alert('Please select an object first');
                return;
            }
            currentArrayType = 'linear';
            document.getElementById('array-modal-title').textContent = 'Linear Array';
            document.getElementById('linear-array-settings').style.display = 'block';
            document.getElementById('polar-array-settings').style.display = 'none';
            document.getElementById('mirror-settings').style.display = 'none';
            document.getElementById('array-modal').classList.add('show');
        }

        function createPolarArray() {
            if (!selectedObject) {
                alert('Please select an object first');
                return;
            }
            currentArrayType = 'polar';
            document.getElementById('array-modal-title').textContent = 'Polar Array';
            document.getElementById('linear-array-settings').style.display = 'none';
            document.getElementById('polar-array-settings').style.display = 'block';
            document.getElementById('mirror-settings').style.display = 'none';
            document.getElementById('array-modal').classList.add('show');
        }

        function createMirrorSymmetry() {
            if (!selectedObject) {
                alert('Please select an object first');
                return;
            }
            currentArrayType = 'mirror';
            document.getElementById('array-modal-title').textContent = 'Mirror Symmetry';
            document.getElementById('linear-array-settings').style.display = 'none';
            document.getElementById('polar-array-settings').style.display = 'none';
            document.getElementById('mirror-settings').style.display = 'block';
            document.getElementById('array-modal').classList.add('show');
        }

        function closeArrayModal() {
            document.getElementById('array-modal').classList.remove('show');
            currentArrayType = '';
        }

        function executeArrayOperation() {
            switch(currentArrayType) {
                case 'linear':
                    executeLinearArray();
                    break;
                case 'polar':
                    executePolarArray();
                    break;
                case 'mirror':
                    executeMirrorSymmetry();
                    break;
            }
            closeArrayModal();
        }

        function executeLinearArray() {
            const count = parseInt(document.getElementById('linear-count').value);
            const direction = document.getElementById('linear-direction').value;
            const spacing = parseFloat(document.getElementById('linear-spacing').value);

            const baseObject = selectedObject;
            const createdObjects = [];

            for (let i = 1; i < count; i++) {
                const clone = cloneObject(baseObject);

                // Apply offset based on direction
                const offset = spacing * i;
                switch(direction) {
                    case 'x':
                        clone.position.x += offset;
                        break;
                    case 'y':
                        clone.position.y += offset;
                        break;
                    case 'z':
                        clone.position.z += offset;
                        break;
                }

                scene.add(clone);
                sceneObjects.push(clone);

                // Handle projector-specific elements
                if (clone.isSpotLight && clone.userData.type === 'projector') {
                    projectors.push(clone);
                    if (clone.userData.target) {
                        clone.userData.target.position.copy(clone.target.position);
                        clone.userData.target.position[direction] += offset;
                    }
                    if (clone.userData.targetIndicator) {
                        clone.userData.targetIndicator.position.copy(clone.userData.target.position);
                    }
                }

                createdObjects.push(clone);
            }

            updateSceneObjectsList();
            updateStats();
        }

        function executePolarArray() {
            const count = parseInt(document.getElementById('polar-count').value);
            const axis = document.getElementById('polar-axis').value;
            const radius = parseFloat(document.getElementById('polar-radius').value);
            const totalAngle = parseFloat(document.getElementById('polar-angle').value);

            const baseObject = selectedObject;
            const centerPos = baseObject.position.clone();
            const angleStep = (totalAngle * Math.PI / 180) / count;

            for (let i = 1; i < count; i++) {
                const clone = cloneObject(baseObject);
                const angle = angleStep * i;

                // Calculate new position based on axis
                switch(axis) {
                    case 'y': // Rotate around Y axis (most common)
                        clone.position.x = centerPos.x + Math.cos(angle) * radius;
                        clone.position.z = centerPos.z + Math.sin(angle) * radius;
                        clone.position.y = centerPos.y;
                        clone.rotation.y = angle;
                        break;
                    case 'x': // Rotate around X axis
                        clone.position.y = centerPos.y + Math.cos(angle) * radius;
                        clone.position.z = centerPos.z + Math.sin(angle) * radius;
                        clone.position.x = centerPos.x;
                        clone.rotation.x = angle;
                        break;
                    case 'z': // Rotate around Z axis
                        clone.position.x = centerPos.x + Math.cos(angle) * radius;
                        clone.position.y = centerPos.y + Math.sin(angle) * radius;
                        clone.position.z = centerPos.z;
                        clone.rotation.z = angle;
                        break;
                }

                scene.add(clone);
                sceneObjects.push(clone);

                // Handle projector-specific elements
                if (clone.isSpotLight && clone.userData.type === 'projector') {
                    projectors.push(clone);
                    if (clone.userData.target) {
                        // Keep target pointed at center
                        clone.target.position.copy(centerPos);
                        clone.userData.target.position.copy(centerPos);
                    }
                    if (clone.userData.targetIndicator) {
                        clone.userData.targetIndicator.position.copy(centerPos);
                    }
                }
            }

            updateSceneObjectsList();
            updateStats();
        }

        function executeMirrorSymmetry() {
            const axis = document.getElementById('mirror-axis').value;
            const mirrorPos = parseFloat(document.getElementById('mirror-position').value);

            const baseObject = selectedObject;
            const clone = cloneObject(baseObject);

            // Mirror position
            const offset = mirrorPos - baseObject.position[axis];
            clone.position[axis] = mirrorPos + offset;

            // Mirror rotation
            switch(axis) {
                case 'x':
                    clone.rotation.y = -clone.rotation.y;
                    clone.rotation.z = -clone.rotation.z;
                    break;
                case 'y':
                    clone.rotation.x = -clone.rotation.x;
                    clone.rotation.z = -clone.rotation.z;
                    break;
                case 'z':
                    clone.rotation.x = -clone.rotation.x;
                    clone.rotation.y = -clone.rotation.y;
                    break;
            }

            scene.add(clone);
            sceneObjects.push(clone);

            // Handle projector-specific elements
            if (clone.isSpotLight && clone.userData.type === 'projector') {
                projectors.push(clone);
                if (clone.userData.target && clone.userData.targetIndicator) {
                    const targetOffset = mirrorPos - clone.target.position[axis];
                    clone.userData.target.position[axis] = mirrorPos + targetOffset;
                    clone.userData.targetIndicator.position.copy(clone.userData.target.position);
                }
            }

            updateSceneObjectsList();
            updateStats();
        }

        function cloneObject(obj) {
            let clone;

            if (obj.isSpotLight) {
                // Clone spotlight (projector)
                clone = obj.clone();

                // Clone rectangular projection texture
                if (obj.userData.resolution) {
                    const [resWidth, resHeight] = obj.userData.resolution.split('x').map(Number);
                    const aspectRatio = resWidth / resHeight;
                    clone.map = createRectangularProjectionTexture(aspectRatio);
                }

                // Clone target
                const targetClone = obj.target.clone();
                scene.add(targetClone);
                clone.target = targetClone;

                // Clone helper
                const helperClone = new RectangularFrustumHelper(clone, obj.userData.resolution);
                scene.add(helperClone);

                // Clone target indicator (yellow sphere)
                let targetIndicatorClone = null;
                if (obj.userData.targetIndicator) {
                    targetIndicatorClone = obj.userData.targetIndicator.clone();
                    targetIndicatorClone.userData = {
                        type: 'projector_target',
                        name: obj.userData.name + ' Copy Target',
                        locked: false,
                        parentProjector: null // Will be set after clone is added
                    };
                    scene.add(targetIndicatorClone);
                    sceneObjects.push(targetIndicatorClone);
                }

                // Clone userData
                clone.userData = {
                    ...obj.userData,
                    name: obj.userData.name + ' Copy',
                    target: targetClone,
                    helper: helperClone,
                    targetIndicator: targetIndicatorClone
                };

                // Link cloned target indicator back to cloned projector
                if (targetIndicatorClone) {
                    targetIndicatorClone.userData.parentProjector = clone;
                }

            } else {
                // Clone mesh
                clone = obj.clone();
                clone.userData = {
                    ...obj.userData,
                    name: obj.userData.name + ' Copy'
                };
            }

            return clone;
        }

        // ===== DIMENSION TOOL =====

        let dimensionMode = false;
        let dimensionStartPoint = null;
        const dimensions = [];

        function measureDistance() {
            dimensionMode = true;
            dimensionStartPoint = null;
            document.body.style.cursor = 'crosshair';

            // Show instruction
            const instruction = document.createElement('div');
            instruction.id = 'dimension-instruction';
            instruction.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); padding: 20px 30px; border-radius: 8px; color: white; font-size: 14px; z-index: 9999; pointer-events: none;';
            instruction.textContent = 'Click two points to measure distance. Press ESC to cancel.';
            document.body.appendChild(instruction);
        }

        function cancelDimensionMode() {
            dimensionMode = false;
            dimensionStartPoint = null;
            document.body.style.cursor = 'default';
            const instruction = document.getElementById('dimension-instruction');
            if (instruction) instruction.remove();
        }

        function createDimensionLine(point1, point2) {
            // Create line geometry
            const points = [point1, point2];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: 0x00ffff,
                linewidth: 2,
                depthTest: false
            });
            const line = new THREE.Line(geometry, material);
            line.renderOrder = 999;

            // Calculate distance
            const distance = point1.distanceTo(point2);

            // Create text label
            const midPoint = new THREE.Vector3().addVectors(point1, point2).multiplyScalar(0.5);

            // Create text sprite
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;

            context.fillStyle = 'rgba(0, 0, 0, 0.8)';
            context.fillRect(0, 0, canvas.width, canvas.height);

            context.font = 'Bold 32px Arial';
            context.fillStyle = '#00ffff';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(distance.toFixed(2) + 'm', canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                depthTest: false
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.copy(midPoint);
            sprite.scale.set(2, 0.5, 1);
            sprite.renderOrder = 1000;

            // Create endpoint markers
            const markerGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const markerMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                depthTest: false
            });
            const marker1 = new THREE.Mesh(markerGeometry, markerMaterial);
            const marker2 = new THREE.Mesh(markerGeometry, markerMaterial);
            marker1.position.copy(point1);
            marker2.position.copy(point2);
            marker1.renderOrder = 999;
            marker2.renderOrder = 999;

            // Group everything
            const dimensionGroup = new THREE.Group();
            dimensionGroup.add(line);
            dimensionGroup.add(sprite);
            dimensionGroup.add(marker1);
            dimensionGroup.add(marker2);

            dimensionGroup.userData = {
                type: 'dimension',
                name: 'Dimension ' + (dimensions.length + 1),
                locked: false,
                distance: distance,
                point1: point1,
                point2: point2
            };

            scene.add(dimensionGroup);
            sceneObjects.push(dimensionGroup);
            dimensions.push(dimensionGroup);

            updateSceneObjectsList();
            updateStats();

            return dimensionGroup;
        }

        // Handle dimension tool clicks
        function handleDimensionClick(event) {
            if (dimensionMode) {
                const rect = renderer.domElement.getBoundingClientRect();
                const mouse = new THREE.Vector2(
                    ((event.clientX - rect.left) / rect.width) * 2 - 1,
                    -((event.clientY - rect.top) / rect.height) * 2 + 1
                );

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);

                // Raycast against all visible objects
                const intersects = raycaster.intersectObjects(scene.children, true);

                if (intersects.length > 0) {
                    const point = intersects[0].point;

                    if (!dimensionStartPoint) {
                        // First point
                        dimensionStartPoint = point.clone();

                        // Update instruction
                        const instruction = document.getElementById('dimension-instruction');
                        if (instruction) {
                            instruction.textContent = 'Click second point to complete measurement. Press ESC to cancel.';
                        }
                    } else {
                        // Second point - create dimension
                        createDimensionLine(dimensionStartPoint, point.clone());
                        cancelDimensionMode();
                    }
                }
            } else if (annotationMode) {
                handleAnnotationClick(event);
            }
        }

        // ===== ANNOTATION TOOL =====

        let annotationMode = false;
        const annotations = [];

        function addAnnotation() {
            annotationMode = true;
            document.body.style.cursor = 'crosshair';

            // Show instruction
            const instruction = document.createElement('div');
            instruction.id = 'annotation-instruction';
            instruction.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); padding: 20px 30px; border-radius: 8px; color: white; font-size: 14px; z-index: 9999; pointer-events: none;';
            instruction.textContent = 'Click a point to place annotation. Press ESC to cancel.';
            document.body.appendChild(instruction);
        }

        function cancelAnnotationMode() {
            annotationMode = false;
            document.body.style.cursor = 'default';
            const instruction = document.getElementById('annotation-instruction');
            if (instruction) instruction.remove();
            const input = document.getElementById('annotation-text-input');
            if (input) input.remove();
        }

        function handleAnnotationClick(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            // Raycast against all visible objects
            const intersects = raycaster.intersectObjects(scene.children, true);

            if (intersects.length > 0) {
                const point = intersects[0].point;
                showAnnotationInput(point, event.clientX, event.clientY);
            }
        }

        function showAnnotationInput(point, screenX, screenY) {
            // Remove instruction
            const instruction = document.getElementById('annotation-instruction');
            if (instruction) instruction.remove();

            // Create input dialog
            const inputDialog = document.createElement('div');
            inputDialog.id = 'annotation-text-input';
            inputDialog.style.cssText = `position: fixed; left: ${screenX}px; top: ${screenY}px; background: rgba(0,0,0,0.95); padding: 15px; border-radius: 6px; z-index: 9999; border: 1px solid #444;`;

            const input = document.createElement('input');
            input.type = 'text';
            input.placeholder = 'Enter annotation text...';
            input.style.cssText = 'width: 250px; padding: 8px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 4px; margin-bottom: 10px; display: block;';

            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = 'display: flex; gap: 8px;';

            const createBtn = document.createElement('button');
            createBtn.textContent = 'Create';
            createBtn.className = 'btn';
            createBtn.style.cssText = 'flex: 1; padding: 6px 12px; background: #0d9488; color: white; border: none; border-radius: 4px; cursor: pointer;';
            createBtn.onclick = () => {
                const text = input.value.trim();
                if (text) {
                    createAnnotation(point, text);
                    cancelAnnotationMode();
                }
            };

            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.className = 'btn btn-secondary';
            cancelBtn.style.cssText = 'flex: 1; padding: 6px 12px; background: #444; color: white; border: none; border-radius: 4px; cursor: pointer;';
            cancelBtn.onclick = () => {
                cancelAnnotationMode();
            };

            buttonContainer.appendChild(createBtn);
            buttonContainer.appendChild(cancelBtn);
            inputDialog.appendChild(input);
            inputDialog.appendChild(buttonContainer);
            document.body.appendChild(inputDialog);

            input.focus();

            // Handle Enter key
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    createBtn.click();
                } else if (e.key === 'Escape') {
                    cancelAnnotationMode();
                }
            });
        }

        function createAnnotation(position, text) {
            // Create text sprite
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;

            // Background
            context.fillStyle = 'rgba(255, 200, 50, 1.0)'; // Fully opaque
            context.fillRect(0, 0, canvas.width, canvas.height);

            // Border
            context.strokeStyle = '#ff9800';
            context.lineWidth = 6;
            context.strokeRect(3, 3, canvas.width - 6, canvas.height - 6);

            // Text
            context.font = 'Bold 40px Arial';
            context.fillStyle = '#000000';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                sizeAttenuation: true,
                transparent: true,
                depthTest: true,
                depthWrite: false
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.copy(position);
            sprite.position.y += 0.5; // Raise above the marker
            sprite.scale.set(2, 0.5, 1);

            // Create marker pin
            const markerGeometry = new THREE.ConeGeometry(0.08, 0.5, 8);
            const markerMaterial = new THREE.MeshBasicMaterial({
                color: 0xff9800
            });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.copy(position);
            marker.position.y -= 0.25;
            marker.rotation.x = Math.PI;

            // Create small sphere at base of pin
            const sphereGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const sphere = new THREE.Mesh(sphereGeometry, markerMaterial);
            sphere.position.copy(position);

            // Group
            const annotationGroup = new THREE.Group();
            annotationGroup.add(sprite);
            annotationGroup.add(marker);
            annotationGroup.add(sphere);

            annotationGroup.userData = {
                type: 'annotation',
                name: 'Annotation ' + (annotations.length + 1),
                locked: false,
                text: text,
                position: position.clone()
            };

            scene.add(annotationGroup);
            sceneObjects.push(annotationGroup);
            annotations.push(annotationGroup);

            updateSceneObjectsList();
            updateStats();

            return annotationGroup;
        }

        // ===== EXCLUSION ZONES / MASKING =====

        const exclusionZones = [];
        let exclusionZoneCount = 0;

        function createExclusionZone(type = 'box') {
            let geometry, name;

            switch(type) {
                case 'box':
                    geometry = new THREE.BoxGeometry(2, 2, 2);
                    name = 'Exclusion Box';
                    break;
                case 'sphere':
                    geometry = new THREE.SphereGeometry(1, 32, 32);
                    name = 'Exclusion Sphere';
                    break;
                case 'plane':
                    geometry = new THREE.PlaneGeometry(3, 3);
                    name = 'Exclusion Plane';
                    break;
                case 'cylinder':
                    geometry = new THREE.CylinderGeometry(1, 1, 2, 32);
                    name = 'Exclusion Cylinder';
                    break;
                default:
                    geometry = new THREE.BoxGeometry(2, 2, 2);
                    name = 'Exclusion Box';
            }

            // Semi-transparent red material to indicate exclusion zone
            const material = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide,
                depthWrite: false
            });

            const mesh = new THREE.Mesh(geometry, material);

            // Add wireframe for better visibility
            const wireframe = new THREE.LineSegments(
                new THREE.EdgesGeometry(geometry),
                new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 })
            );
            mesh.add(wireframe);

            // Position randomly or at origin
            mesh.position.set(
                Math.random() * 4 - 2,
                2 + Math.random() * 2,
                Math.random() * 4 - 2
            );

            mesh.userData = {
                type: 'exclusion_zone',
                name: name + ' ' + (++exclusionZoneCount),
                locked: false,
                zoneType: type,
                enabled: true,
                affectedProjectors: [] // List of projector IDs affected by this zone
            };

            scene.add(mesh);
            sceneObjects.push(mesh);
            exclusionZones.push(mesh);

            updateSceneObjectsList();
            updateStats();

            return mesh;
        }

        // Menu handlers for exclusion zones
        window.addExclusionBox = function() {
            createExclusionZone('box');
        }

        window.addExclusionSphere = function() {
            createExclusionZone('sphere');
        }

        window.addExclusionPlane = function() {
            createExclusionZone('plane');
        }

        window.addExclusionCylinder = function() {
            createExclusionZone('cylinder');
        }

        // Toggle photometric analysis mode
        let photometricMode = 'normal';

        window.togglePhotometric = function() {
            const modes = ['normal', 'illuminance', 'luminance'];
            const currentIndex = modes.indexOf(photometricMode);
            photometricMode = modes[(currentIndex + 1) % modes.length];

            // Visual feedback
            console.log('Photometric mode:', photometricMode);

            // In a real implementation, this would change the rendering mode
            // For now, we just toggle between modes
        }

        function addPrimitive(type) {
            let geometry;
            let name = '';

            switch(type) {
                case 'box':
                    geometry = new THREE.BoxGeometry(2, 2, 2);
                    name = 'Box';
                    break;
                case 'sphere':
                    geometry = new THREE.SphereGeometry(1, 32, 32);
                    name = 'Sphere';
                    break;
                case 'cylinder':
                    geometry = new THREE.CylinderGeometry(1, 1, 2, 32);
                    name = 'Cylinder';
                    break;
                case 'plane':
                    geometry = new THREE.PlaneGeometry(4, 4);
                    name = 'Plane';
                    break;
                case 'torus':
                    geometry = new THREE.TorusGeometry(1, 0.4, 16, 100);
                    name = 'Torus';
                    break;
            }

            const material = new THREE.MeshStandardMaterial({
                color: 0x808080,
                roughness: 0.7,
                metalness: 0.3
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(
                Math.random() * 4 - 2,
                2,
                Math.random() * 4 - 2
            );
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData.name = name + ' ' + (sceneObjects.length + 1);
            mesh.userData.type = 'primitive';
            mesh.userData.locked = false;

            scene.add(mesh);
            sceneObjects.push(mesh);
            updateSceneObjectsList();
            updateStats();
        }

        function addProjector() {
            const color = new THREE.Color().setHSL(Math.random(), 1, 0.6);

            // Create spotlight
            const spotlight = new THREE.SpotLight(color, 150);
            spotlight.position.set(
                Math.random() * 8 - 4,
                6 + Math.random() * 4,
                Math.random() * 8 - 4
            );
            spotlight.angle = Math.PI / 6;
            spotlight.penumbra = 0.05; // Sharper edges for rectangular projection
            spotlight.decay = 2;
            spotlight.distance = 50;
            spotlight.castShadow = true;
            spotlight.shadow.mapSize.width = 2048;
            spotlight.shadow.mapSize.height = 2048;
            spotlight.shadow.camera.near = 0.5;
            spotlight.shadow.camera.far = 50;

            // Target helper
            const target = new THREE.Object3D();
            target.position.set(0, 0, 0);
            scene.add(target);
            spotlight.target = target;

            // Set resolution first for helper creation
            const defaultResolution = '1920x1080'; // 16:9 Full HD

            // Apply rectangular projection texture (16:9 aspect ratio)
            spotlight.map = createRectangularProjectionTexture(16/9);

            // Create rectangular frustum helper with proper aspect ratio
            const helper = new RectangularFrustumHelper(spotlight, defaultResolution);
            scene.add(helper);

            // Create target point indicator (yellow sphere - selectable)
            const targetGeometry = new THREE.SphereGeometry(0.25, 32, 32);
            const targetMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                emissive: 0xffaa00,
                emissiveIntensity: 0.5
            });
            const targetIndicator = new THREE.Mesh(targetGeometry, targetMaterial);
            targetIndicator.position.copy(target.position);

            // Make target indicator selectable and transformable
            targetIndicator.userData = {
                type: 'projector_target',
                name: 'Projector ' + (projectors.length + 1) + ' Target',
                locked: false,
                parentProjector: null // Will be set after spotlight is added
            };

            scene.add(targetIndicator);
            sceneObjects.push(targetIndicator);

            // Projector data
            spotlight.userData.name = 'Projector ' + (projectors.length + 1);
            spotlight.userData.type = 'projector';
            spotlight.userData.locked = false;
            spotlight.userData.helper = helper;
            spotlight.userData.target = target;
            spotlight.userData.targetIndicator = targetIndicator;
            spotlight.userData.lumens = 10000;
            spotlight.userData.throwRatio = 1.5;
            spotlight.userData.resolution = defaultResolution;
            spotlight.userData.lensShiftH = 0;
            spotlight.userData.lensShiftV = 0;
            spotlight.userData.brightnessFactor = 1.0;

            scene.add(spotlight);
            sceneObjects.push(spotlight);
            projectors.push(spotlight);

            // Link target indicator to projector
            targetIndicator.userData.parentProjector = spotlight;

            updateSceneObjectsList();
            updateStats();
        }

        function addCamera() {
            const camera = new THREE.PerspectiveCamera(60, 16/9, 0.1, 100);
            camera.position.set(5, 3, 5);
            camera.lookAt(0, 0, 0);

            const helper = new THREE.CameraHelper(camera);
            scene.add(helper);

            camera.userData.name = 'Camera ' + (sceneObjects.filter(o => o.userData.type === 'camera').length + 1);
            camera.userData.type = 'camera';
            camera.userData.locked = false;
            camera.userData.helper = helper;

            scene.add(camera);
            sceneObjects.push(camera);
            updateSceneObjectsList();
            updateStats();
        }

        function updateSceneObjectsList() {
            const list = document.getElementById('scene-objects-list');
            list.innerHTML = '';

            sceneObjects.forEach((obj, index) => {
                const item = document.createElement('div');
                item.className = 'scene-object-item';
                if (selectedObject === obj) {
                    item.className += ' selected';
                }

                const icon = obj.userData.type === 'projector' ? '🔦' :
                             obj.userData.type === 'camera' ? '📷' :
                             obj.userData.type === 'reference' ? '🚶' : '📦';

                item.innerHTML = `
                    <span class="object-visibility" onclick="toggleVisibility(${index})">👁</span>
                    <span class="object-icon">${icon}</span>
                    <span class="object-name">${obj.userData.name || 'Object ' + index}</span>
                    <span class="object-lock" onclick="toggleLock(${index})">${obj.userData.locked ? '🔒' : '🔓'}</span>
                `;

                item.onclick = (e) => {
                    if (!e.target.classList.contains('object-visibility') &&
                        !e.target.classList.contains('object-lock')) {
                        selectObject(obj);
                    }
                };

                list.appendChild(item);
            });
        }

        function selectObject(obj) {
            if (obj.userData.locked) return;

            selectedObject = obj;
            transformControls.attach(obj);
            updateSceneObjectsList();
            updatePropertiesPanel();
        }

        function updatePropertiesPanel() {
            const panel = document.getElementById('properties-panel');

            if (!selectedObject) {
                panel.innerHTML = '<div id="no-selection" style="padding: 20px; text-align: center; color: #666;">No object selected</div>';
                return;
            }

            const obj = selectedObject;
            const isProjector = obj.userData.type === 'projector';
            const isPrimitive = obj.userData.type === 'primitive';

            let html = '';

            // Object Properties Section
            html += `
                <div class="property-section">
                    <div class="property-section-header">
                        <span class="section-toggle">▼</span>
                        Object
                    </div>
                    <div class="property-section-content">
                        <div class="property-row">
                            <label class="property-label">Name</label>
                            <input type="text" class="property-input" value="${obj.userData.name}"
                                onchange="updateObjectName(this.value)">
                        </div>
                        <div class="property-row">
                            <label class="property-label">Type</label>
                            <input type="text" class="property-input" value="${obj.userData.type}" disabled>
                        </div>
                    </div>
                </div>
            `;

            // Transform Section
            html += `
                <div class="property-section">
                    <div class="property-section-header">
                        <span class="section-toggle">▼</span>
                        Transform
                    </div>
                    <div class="property-section-content">
                        <div class="property-row">
                            <label class="property-label">Position</label>
                            <div class="property-input-group">
                                <span class="axis-label x">X</span>
                                <input type="number" class="property-input" step="0.1"
                                    value="${obj.position.x.toFixed(2)}"
                                    onchange="updatePosition('x', parseFloat(this.value))">
                                <span class="axis-label y">Y</span>
                                <input type="number" class="property-input" step="0.1"
                                    value="${obj.position.y.toFixed(2)}"
                                    onchange="updatePosition('y', parseFloat(this.value))">
                                <span class="axis-label z">Z</span>
                                <input type="number" class="property-input" step="0.1"
                                    value="${obj.position.z.toFixed(2)}"
                                    onchange="updatePosition('z', parseFloat(this.value))">
                            </div>
                        </div>
                        <div class="property-row">
                            <label class="property-label">Rotation (degrees)</label>
                            <div class="property-input-group">
                                <span class="axis-label x">X</span>
                                <input type="number" class="property-input" step="0.1"
                                    value="${THREE.MathUtils.radToDeg(obj.rotation.x).toFixed(1)}"
                                    onchange="updateRotation('x', THREE.MathUtils.degToRad(parseFloat(this.value)))">
                                <span class="axis-label y">Y</span>
                                <input type="number" class="property-input" step="0.1"
                                    value="${THREE.MathUtils.radToDeg(obj.rotation.y).toFixed(1)}"
                                    onchange="updateRotation('y', THREE.MathUtils.degToRad(parseFloat(this.value)))">
                                <span class="axis-label z">Z</span>
                                <input type="number" class="property-input" step="0.1"
                                    value="${THREE.MathUtils.radToDeg(obj.rotation.z).toFixed(1)}"
                                    onchange="updateRotation('z', THREE.MathUtils.degToRad(parseFloat(this.value)))">
                            </div>
                        </div>
                        ${!isProjector ? `
                        <div class="property-row">
                            <label class="property-label">Scale</label>
                            <div class="property-input-group">
                                <span class="axis-label x">X</span>
                                <input type="number" class="property-input" step="0.1"
                                    value="${obj.scale.x.toFixed(2)}"
                                    onchange="updateScale('x', parseFloat(this.value))">
                                <span class="axis-label y">Y</span>
                                <input type="number" class="property-input" step="0.1"
                                    value="${obj.scale.y.toFixed(2)}"
                                    onchange="updateScale('y', parseFloat(this.value))">
                                <span class="axis-label z">Z</span>
                                <input type="number" class="property-input" step="0.1"
                                    value="${obj.scale.z.toFixed(2)}"
                                    onchange="updateScale('z', parseFloat(this.value))">
                            </div>
                        </div>
                        ` : ''}
                    </div>
                </div>
            `;

            // Projector-specific properties
            if (isProjector) {
                html += `
                    <div class="property-section">
                        <div class="property-section-header">
                            <span class="section-toggle">▼</span>
                            Projector Settings
                        </div>
                        <div class="property-section-content">
                            <div class="property-row">
                                <label class="property-label">Lumens <span class="value-display">${obj.userData.lumens}</span></label>
                                <input type="range" class="property-slider" min="1000" max="50000" step="100"
                                    value="${obj.userData.lumens}"
                                    oninput="updateProjectorLumens(parseFloat(this.value))">
                            </div>
                            <div class="property-row">
                                <label class="property-label">Brightness Factor <span class="value-display">${obj.userData.brightnessFactor.toFixed(2)}</span></label>
                                <input type="range" class="property-slider" min="0" max="2" step="0.01"
                                    value="${obj.userData.brightnessFactor}"
                                    oninput="updateBrightnessFactor(parseFloat(this.value))">
                            </div>
                            <div class="property-row">
                                <label class="property-label">Intensity <span class="value-display">${obj.intensity.toFixed(0)}</span></label>
                                <input type="range" class="property-slider" min="0" max="500" step="1"
                                    value="${obj.intensity}"
                                    oninput="updateProjectorIntensity(parseFloat(this.value))">
                            </div>
                            <div class="property-row">
                                <label class="property-label">Beam Angle (degrees) <span class="value-display">${THREE.MathUtils.radToDeg(obj.angle).toFixed(1)}</span></label>
                                <input type="range" class="property-slider" min="5" max="120" step="0.5"
                                    value="${THREE.MathUtils.radToDeg(obj.angle)}"
                                    oninput="updateProjectorAngle(THREE.MathUtils.degToRad(parseFloat(this.value)))">
                            </div>
                            <div class="property-row">
                                <label class="property-label">Throw Distance <span class="value-display">${obj.distance.toFixed(1)}m</span></label>
                                <input type="range" class="property-slider" min="1" max="100" step="0.5"
                                    value="${obj.distance}"
                                    oninput="updateProjectorDistance(parseFloat(this.value))">
                            </div>
                            <div class="property-row">
                                <label class="property-label">Throw Ratio <span class="value-display">${obj.userData.throwRatio.toFixed(2)}</span></label>
                                <input type="number" class="property-input" step="0.1"
                                    value="${obj.userData.throwRatio}"
                                    onchange="updateThrowRatio(parseFloat(this.value))">
                            </div>
                            <div class="property-row">
                                <label class="property-label">Penumbra <span class="value-display">${obj.penumbra.toFixed(2)}</span></label>
                                <input type="range" class="property-slider" min="0" max="1" step="0.01"
                                    value="${obj.penumbra}"
                                    oninput="updateProjectorPenumbra(parseFloat(this.value))">
                            </div>
                            <div class="property-row">
                                <label class="property-label">Color</label>
                                <input type="color" class="property-color"
                                    value="#${obj.color.getHexString()}"
                                    onchange="updateProjectorColor(this.value)">
                            </div>
                            <div class="property-row">
                                <label class="property-label">Lens Shift Horizontal <span class="value-display">${obj.userData.lensShiftH.toFixed(2)}</span></label>
                                <input type="range" class="property-slider" min="-2" max="2" step="0.01"
                                    value="${obj.userData.lensShiftH}"
                                    oninput="updateLensShift('h', parseFloat(this.value))">
                            </div>
                            <div class="property-row">
                                <label class="property-label">Lens Shift Vertical <span class="value-display">${obj.userData.lensShiftV.toFixed(2)}</span></label>
                                <input type="range" class="property-slider" min="-2" max="2" step="0.01"
                                    value="${obj.userData.lensShiftV}"
                                    oninput="updateLensShift('v', parseFloat(this.value))">
                            </div>
                            <div class="property-row">
                                <label class="property-label">Resolution</label>
                                <select class="property-select" onchange="updateResolution(this.value)">
                                    <option ${obj.userData.resolution === '1920x1080' ? 'selected' : ''}>1920x1080</option>
                                    <option ${obj.userData.resolution === '1920x1200' ? 'selected' : ''}>1920x1200</option>
                                    <option ${obj.userData.resolution === '2560x1440' ? 'selected' : ''}>2560x1440</option>
                                    <option ${obj.userData.resolution === '3840x2160' ? 'selected' : ''}>3840x2160</option>
                                    <option ${obj.userData.resolution === '4096x2160' ? 'selected' : ''}>4096x2160</option>
                                </select>
                            </div>
                            <div class="property-row">
                                <label class="property-checkbox">
                                    <input type="checkbox" ${obj.castShadow ? 'checked' : ''}
                                        onchange="updateCastShadow(this.checked)">
                                    <span>Cast Shadows</span>
                                </label>
                            </div>
                            <div class="property-row">
                                <label class="property-checkbox">
                                    <input type="checkbox" ${obj.userData.helper?.visible ? 'checked' : ''}
                                        onchange="toggleHelper(this.checked)">
                                    <span>Show Helper</span>
                                </label>
                            </div>
                        </div>
                    </div>

                    ${obj.userData.target ? `
                    <div class="property-section">
                        <div class="property-section-header">
                            <span class="section-toggle">▼</span>
                            Target Point
                        </div>
                        <div class="property-section-content">
                            <div class="property-row">
                                <label class="property-label">Target Position</label>
                                <div class="property-input-group">
                                    <span class="axis-label x">X</span>
                                    <input type="number" class="property-input" step="0.1"
                                        value="${obj.userData.target.position.x.toFixed(2)}"
                                        onchange="updateTargetPosition('x', parseFloat(this.value))">
                                    <span class="axis-label y">Y</span>
                                    <input type="number" class="property-input" step="0.1"
                                        value="${obj.userData.target.position.y.toFixed(2)}"
                                        onchange="updateTargetPosition('y', parseFloat(this.value))">
                                    <span class="axis-label z">Z</span>
                                    <input type="number" class="property-input" step="0.1"
                                        value="${obj.userData.target.position.z.toFixed(2)}"
                                        onchange="updateTargetPosition('z', parseFloat(this.value))">
                                </div>
                            </div>
                            <div class="property-row">
                                <label class="property-checkbox">
                                    <input type="checkbox" ${obj.userData.targetIndicator?.visible !== false ? 'checked' : ''}
                                        onchange="toggleTargetIndicator(this.checked)">
                                    <span>Show Target Indicator</span>
                                </label>
                            </div>
                        </div>
                    </div>
                    ` : ''}

                    <div class="property-section">
                        <div class="property-section-header">
                            <span class="section-toggle">▼</span>
                            Projector Image
                        </div>
                        <div class="property-section-content">
                            <div class="property-row">
                                <button class="btn" onclick="openImageModal()">Import Image / Video</button>
                                ${obj.userData.projectorTexture ? `
                                <div style="margin-top: 10px; font-size: 11px; color: #0d9488;">
                                    ✓ Image loaded
                                </div>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                `;
            }

            // Material Section (for primitives)
            if (isPrimitive && obj.material) {
                html += `
                    <div class="property-section">
                        <div class="property-section-header">
                            <span class="section-toggle">▼</span>
                            Material
                        </div>
                        <div class="property-section-content">
                            <div class="property-row">
                                <label class="property-label">Color</label>
                                <input type="color" class="property-color"
                                    value="#${obj.material.color.getHexString()}"
                                    onchange="updateMaterialColor(this.value)">
                            </div>
                            <div class="property-row">
                                <label class="property-label">Roughness <span class="value-display">${obj.material.roughness.toFixed(2)}</span></label>
                                <input type="range" class="property-slider" min="0" max="1" step="0.01"
                                    value="${obj.material.roughness}"
                                    oninput="updateMaterialRoughness(parseFloat(this.value))">
                            </div>
                            <div class="property-row">
                                <label class="property-label">Metalness <span class="value-display">${obj.material.metalness.toFixed(2)}</span></label>
                                <input type="range" class="property-slider" min="0" max="1" step="0.01"
                                    value="${obj.material.metalness}"
                                    oninput="updateMaterialMetalness(parseFloat(this.value))">
                            </div>
                        </div>
                    </div>
                `;
            }

            // Actions
            html += `
                <button class="btn btn-danger" onclick="deleteSelected()">Delete Object</button>
                <button class="btn btn-secondary" onclick="duplicateObject()">Duplicate</button>
            `;

            panel.innerHTML = html;

            // Make sections collapsible
            document.querySelectorAll('.property-section-header').forEach(header => {
                header.onclick = () => {
                    header.parentElement.classList.toggle('collapsed');
                };
            });
        }

        // Update functions
        window.updateObjectName = (value) => {
            if (selectedObject) {
                selectedObject.userData.name = value;
                updateSceneObjectsList();
            }
        };

        window.updatePosition = (axis, value) => {
            if (selectedObject) {
                selectedObject.position[axis] = value;
            }
        };

        window.updateRotation = (axis, value) => {
            if (selectedObject) {
                selectedObject.rotation[axis] = value;
            }
        };

        window.updateScale = (axis, value) => {
            if (selectedObject) {
                selectedObject.scale[axis] = value;
            }
        };

        window.updateProjectorLumens = (value) => {
            if (selectedObject && selectedObject.userData.type === 'projector') {
                selectedObject.userData.lumens = value;
                document.querySelector('.property-label:has(+ .property-slider) .value-display').textContent = value;
            }
        };

        window.updateBrightnessFactor = (value) => {
            if (selectedObject && selectedObject.userData.type === 'projector') {
                selectedObject.userData.brightnessFactor = value;
                const labels = document.querySelectorAll('.property-label .value-display');
                labels[1].textContent = value.toFixed(2);
            }
        };

        window.updateProjectorIntensity = (value) => {
            if (selectedObject && selectedObject.userData.type === 'projector') {
                selectedObject.intensity = value;
                const labels = document.querySelectorAll('.property-label .value-display');
                labels[2].textContent = value.toFixed(0);
            }
        };

        window.updateProjectorAngle = (value) => {
            if (selectedObject && selectedObject.userData.type === 'projector') {
                selectedObject.angle = value;
                selectedObject.userData.helper.update();
                const labels = document.querySelectorAll('.property-label .value-display');
                labels[3].textContent = THREE.MathUtils.radToDeg(value).toFixed(1);
            }
        };

        window.updateProjectorDistance = (value) => {
            if (selectedObject && selectedObject.userData.type === 'projector') {
                selectedObject.distance = value;
                const labels = document.querySelectorAll('.property-label .value-display');
                labels[4].textContent = value.toFixed(1) + 'm';
            }
        };

        window.updateThrowRatio = (value) => {
            if (selectedObject && selectedObject.userData.type === 'projector') {
                selectedObject.userData.throwRatio = value;
                const labels = document.querySelectorAll('.property-label .value-display');
                labels[5].textContent = value.toFixed(2);
            }
        };

        window.updateProjectorPenumbra = (value) => {
            if (selectedObject && selectedObject.userData.type === 'projector') {
                selectedObject.penumbra = value;
                const labels = document.querySelectorAll('.property-label .value-display');
                labels[6].textContent = value.toFixed(2);
            }
        };

        window.updateProjectorColor = (value) => {
            if (selectedObject && selectedObject.userData.type === 'projector') {
                selectedObject.color.set(value);
            }
        };

        window.updateLensShift = (axis, value) => {
            if (selectedObject && selectedObject.userData.type === 'projector') {
                if (axis === 'h') {
                    selectedObject.userData.lensShiftH = value;
                    const labels = document.querySelectorAll('.property-label .value-display');
                    labels[7].textContent = value.toFixed(2);
                } else {
                    selectedObject.userData.lensShiftV = value;
                    const labels = document.querySelectorAll('.property-label .value-display');
                    labels[8].textContent = value.toFixed(2);
                }
            }
        };

        window.updateResolution = (value) => {
            if (selectedObject && selectedObject.userData.type === 'projector') {
                selectedObject.userData.resolution = value;
            }
        };

        window.updateCastShadow = (value) => {
            if (selectedObject) {
                selectedObject.castShadow = value;
            }
        };

        window.toggleHelper = (value) => {
            if (selectedObject && selectedObject.userData.helper) {
                selectedObject.userData.helper.visible = value;
            }
        };

        window.updateMaterialColor = (value) => {
            if (selectedObject && selectedObject.material) {
                selectedObject.material.color.set(value);
            }
        };

        window.updateMaterialRoughness = (value) => {
            if (selectedObject && selectedObject.material) {
                selectedObject.material.roughness = value;
                document.querySelectorAll('.property-label .value-display')[0].textContent = value.toFixed(2);
            }
        };

        window.updateMaterialMetalness = (value) => {
            if (selectedObject && selectedObject.material) {
                selectedObject.material.metalness = value;
                document.querySelectorAll('.property-label .value-display')[1].textContent = value.toFixed(2);
            }
        };

        window.updateTargetPosition = (axis, value) => {
            if (selectedObject && selectedObject.userData.target) {
                selectedObject.userData.target.position[axis] = value;
                if (selectedObject.userData.targetIndicator) {
                    selectedObject.userData.targetIndicator.position[axis] = value;
                }
                if (selectedObject.userData.helper) {
                    selectedObject.userData.helper.update();
                }
            }
        };

        window.toggleTargetIndicator = (value) => {
            if (selectedObject && selectedObject.userData.targetIndicator) {
                selectedObject.userData.targetIndicator.visible = value;
            }
        };

        window.toggleVisibility = (index) => {
            const obj = sceneObjects[index];
            obj.visible = !obj.visible;
            if (obj.userData.helper) {
                obj.userData.helper.visible = obj.visible;
            }
        };

        window.toggleLock = (index) => {
            const obj = sceneObjects[index];
            obj.userData.locked = !obj.userData.locked;
            updateSceneObjectsList();
        };

        window.deleteSelected = () => {
            if (selectedObject && !selectedObject.userData.locked) {
                scene.remove(selectedObject);
                if (selectedObject.userData.helper) {
                    scene.remove(selectedObject.userData.helper);
                }
                if (selectedObject.userData.target) {
                    scene.remove(selectedObject.userData.target);
                }

                const index = sceneObjects.indexOf(selectedObject);
                if (index > -1) {
                    sceneObjects.splice(index, 1);
                }

                const projIndex = projectors.indexOf(selectedObject);
                if (projIndex > -1) {
                    projectors.splice(projIndex, 1);
                }

                transformControls.detach();
                selectedObject = null;
                updateSceneObjectsList();
                updatePropertiesPanel();
                updateStats();
            }
        };

        window.duplicateObject = () => {
            if (selectedObject && !selectedObject.userData.locked) {
                const clone = selectedObject.clone();
                clone.position.x += 2;
                clone.userData = { ...selectedObject.userData };
                clone.userData.name += ' Copy';
                scene.add(clone);
                sceneObjects.push(clone);
                updateSceneObjectsList();
                updateStats();
            }
        };

        window.setGizmoMode = (mode) => {
            gizmoMode = mode;
            transformControls.setMode(mode);

            document.querySelectorAll('.gizmo-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        };

        window.setViewMode = (mode) => {
            switch(mode) {
                case 'perspective':
                    camera.position.set(15, 10, 15);
                    break;
                case 'top':
                    camera.position.set(0, 30, 0);
                    break;
                case 'front':
                    camera.position.set(0, 5, 30);
                    break;
                case 'side':
                    camera.position.set(30, 5, 0);
                    break;
            }
            camera.lookAt(0, 0, 0);
            controls.update();
        };

        window.toggleRenderMode = (mode) => {
            renderMode = mode;
            document.querySelectorAll('#viewport-mode .view-mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        };

        function updateStats() {
            document.getElementById('object-count').textContent = sceneObjects.length;
            document.getElementById('projector-count').textContent = projectors.length;

            let triangles = 0;
            scene.traverse((obj) => {
                if (obj.geometry) {
                    const positions = obj.geometry.attributes.position;
                    if (positions) {
                        triangles += positions.count / 3;
                    }
                }
            });
            document.getElementById('tri-count').textContent = Math.floor(triangles);
        }

        function onKeyDown(event) {
            switch(event.key) {
                case 'g':
                case 'G':
                    setGizmoMode('translate');
                    break;
                case 'r':
                case 'R':
                    setGizmoMode('rotate');
                    break;
                case 's':
                case 'S':
                    setGizmoMode('scale');
                    break;
                case 't':
                case 'T':
                    measureDistance();
                    break;
                case 'a':
                case 'A':
                    if (!dimensionMode) addAnnotation();
                    break;
                case 'Escape':
                    if (dimensionMode) cancelDimensionMode();
                    if (annotationMode) cancelAnnotationMode();
                    break;
                case 'Delete':
                case 'Backspace':
                    deleteSelected();
                    break;
            }
        }

        function onWindowResize() {
            const container = document.getElementById('viewport-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            controls.update();

            // Update helpers
            projectors.forEach(proj => {
                if (proj.userData.helper && proj.userData.helper.visible) {
                    proj.userData.helper.update();
                }
            });

            renderer.render(scene, camera);

            // FPS counter
            frameCount++;
            const currentTime = performance.now();
            if (currentTime >= lastTime + 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastTime = currentTime;
            }
        }

        // Menu functions
        window.newProject = () => console.log('New Project');
        window.saveProject = () => console.log('Save Project');
        window.loadProject = () => console.log('Load Project');
        window.exportScene = () => console.log('Export Scene');
        window.undo = () => console.log('Undo');
        window.redo = () => console.log('Redo');
        window.createLinearArray = () => console.log('Linear Array');
        window.createPolarArray = () => console.log('Polar Array');
        window.createMirrorSymmetry = () => console.log('Mirror Symmetry');
        window.addAnnotation = () => console.log('Add Annotation');
        window.measureDistance = () => console.log('Measure Distance');
        window.togglePhotometric = () => console.log('Toggle Photometric');
        window.addPrimitive = addPrimitive;
        window.addCamera = addCamera;

        // Projector Modal functions
        window.openProjectorModal = openProjectorModal;
        window.closeProjectorModal = closeProjectorModal;
        window.filterProjectors = filterProjectors;
        window.createProjectorFromModal = createProjectorFromModal;

        // Image Modal functions
        window.closeImageModal = closeImageModal;
        window.handleImageUpload = handleImageUpload;
        window.applyProjectorImage = applyProjectorImage;

        // Initialize
        init();
    </script>
</body>
</html>
