<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Panasonic PT-RQ25K - Professional Shadow-Mapped Projection Shader</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
        }
        #container { width: 100vw; height: 100vh; }

        #controls { position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.95); padding:15px; border-radius:8px; width:300px; max-height:90vh; overflow-y:auto; font-size:11px; }
        .control-group { margin-bottom:12px; padding-bottom:10px; border-bottom:1px solid #333; }
        .control-group h3 { font-size:10px; margin-bottom:8px; color:#0d9488; text-transform:uppercase; }
        .control-row { margin-bottom:8px; }
        label { display:block; font-size:10px; margin-bottom:3px; color:#aaa; }
        input[type="range"] { width:100%; height:3px; background:#333; border-radius:2px; outline:none; }
        input[type="range"]::-webkit-slider-thumb { appearance:none; width:10px; height:10px; border-radius:50%; background:#0d9488; cursor:pointer; }
        input[type="number"], select, input[type="file"] { width:100%; padding:5px; background:#2a2a2a; border:1px solid #444; color:white; border-radius:3px; font-size:11px; }
        button { width:100%; padding:6px; background:#0d9488; color:white; border:none; border-radius:3px; cursor:pointer; font-size:10px; margin-top:4px; }
        button.secondary { background:#444; }
        button.danger { background:#dc2626; }
        .value-display { color:#0d9488; font-weight:600; margin-left:5px; }
        .checkbox-row { display:flex; align-items:center; gap:6px; margin:5px 0; }
        .throw-display { background: linear-gradient(135deg,#0d9488 0%,#065f46 100%); padding:8px; border-radius:5px; text-align:center; margin-bottom:10px; }
        .throw-display .label { font-size:8px; color:rgba(255,255,255,0.7); }
        .throw-display .value { font-size:18px; font-weight:700; }
        .throw-display .sub { font-size:9px; color:rgba(255,255,255,0.6); }
        .measurement-group { display:grid; grid-template-columns:1fr 1fr; gap:6px; }
        .measurement-input { background:#1a1a1a; padding:6px; border-radius:3px; text-align:center; }
        .lens-specs { background:#1a1a1a; padding:5px; border-radius:3px; margin-top:5px; font-size:9px; }
        .projector-model { background: linear-gradient(135deg,#1e3a5f 0%,#0d1b2a 100%); padding:8px; border-radius:5px; margin-bottom:10px; border:1px solid #2a4a6f; }
        .snap-selector { width:50px; height:50px; background:#1a1a1a; border:1px solid #444; border-radius:4px; display:grid; grid-template-columns:repeat(3,1fr); grid-template-rows:repeat(3,1fr); padding:4px; gap:2px; }
        .snap-btn { width:100%; height:100%; border-radius:50%; border:none; cursor:pointer; background:#444; }
        .snap-btn.active { background:#0d9488; }
        .status { padding:4px; border-radius:3px; font-size:9px; margin-top:4px; }
        .status.success { background:rgba(13,148,136,0.2); color:#0d9488; }
        .status.info { background:rgba(59,130,246,0.2); color:#3b82f6; }

        .keyboard-hint { background:#2a2a2a; padding:4px; border-radius:3px; font-size:8px; color:#888; margin-top:5px; }
        .shader-quality-badge {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 8px;
            text-align: center;
            margin-bottom: 8px;
            font-weight: bold;
        }

        /* Transform Parameters Panel */
        #transform-params {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.95);
            padding: 15px;
            border-radius: 8px;
            width: 320px;
            border: 1px solid #0d9488;
            display: none;
        }
        #transform-params.visible { display: block; }
        #transform-params h3 {
            font-size: 11px;
            color: #0d9488;
            margin-bottom: 10px;
            text-transform: uppercase;
        }
        .param-section {
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }
        .param-section:last-child { border-bottom: none; }
        .param-section-title {
            font-size: 9px;
            color: #888;
            margin-bottom: 6px;
            text-transform: uppercase;
        }
        .param-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 4px;
            margin-bottom: 4px;
        }
        .param-input {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .param-input label {
            font-size: 8px;
            margin-bottom: 2px;
            color: #aaa;
        }
        .param-input input {
            width: 100%;
            text-align: center;
            padding: 4px;
            font-size: 10px;
        }

        /* Gizmo Mode Controls */
        #gizmo-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.95);
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #0d9488;
            display: none;
        }
        #gizmo-controls.visible { display: block; }
        #gizmo-controls .title {
            font-size: 9px;
            color: #888;
            margin-bottom: 8px;
            text-transform: uppercase;
            text-align: center;
        }
        .gizmo-mode-buttons {
            display: flex;
            gap: 6px;
        }
        .gizmo-mode-btn {
            flex: 1;
            padding: 8px;
            background: #2a2a2a;
            border: 1px solid #444;
            color: #aaa;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            text-align: center;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        .gizmo-mode-btn:hover {
            background: #333;
            border-color: #0d9488;
        }
        .gizmo-mode-btn.active {
            background: #0d9488;
            border-color: #0d9488;
            color: white;
        }
        .gizmo-mode-btn .icon {
            font-size: 16px;
        }
        .gizmo-mode-btn .label {
            font-size: 8px;
            text-transform: uppercase;
        }
        .gizmo-mode-btn .key {
            font-size: 7px;
            opacity: 0.6;
        }

        /* Popup Menu for Primitives */
        #primitive-popup {
            position: fixed;
            background: rgba(0,0,0,0.98);
            border: 2px solid #0d9488;
            border-radius: 8px;
            padding: 8px;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        #primitive-popup.visible { display: block; }
        .popup-item {
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 11px;
            transition: all 0.2s;
            white-space: nowrap;
        }
        .popup-item:hover {
            background: #0d9488;
        }
        .popup-icon {
            font-size: 18px;
            width: 24px;
            text-align: center;
        }
        .popup-divider {
            height: 1px;
            background: #333;
            margin: 4px 0;
        }

        /* Add Primitive Button */
        .add-primitive-btn {
            background: linear-gradient(135deg, #0d9488 0%, #065f46 100%);
            padding: 10px;
            text-align: center;
            font-weight: bold;
            font-size: 11px;
            cursor: pointer;
            border-radius: 4px;
            margin-top: 8px;
            transition: all 0.2s;
        }
        .add-primitive-btn:hover {
            background: linear-gradient(135deg, #0f9d96 0%, #076e52 100%);
            transform: translateY(-1px);
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <!-- Gizmo Mode Controls -->
    <div id="gizmo-controls">
        <div class="title">üéõÔ∏è Gizmo Mode</div>
        <div class="gizmo-mode-buttons">
            <div class="gizmo-mode-btn active" data-mode="translate" onclick="setGizmoMode('translate')">
                <div class="icon">‚ÜîÔ∏è</div>
                <div class="label">Move</div>
                <div class="key">[G]</div>
            </div>
            <div class="gizmo-mode-btn" data-mode="rotate" onclick="setGizmoMode('rotate')">
                <div class="icon">üîÑ</div>
                <div class="label">Rotate</div>
                <div class="key">[R]</div>
            </div>
            <div class="gizmo-mode-btn" data-mode="scale" onclick="setGizmoMode('scale')">
                <div class="icon">‚§°</div>
                <div class="label">Scale</div>
                <div class="key">[S]</div>
            </div>
        </div>
    </div>

    <!-- Transform Parameters Panel -->
    <div id="transform-params">
        <h3>‚öôÔ∏è Transform Parameters</h3>

        <div class="param-section">
            <div class="param-section-title">Position</div>
            <div class="param-row">
                <div class="param-input">
                    <label>X</label>
                    <input type="number" id="pos-x" step="0.1" onchange="updateTransformFromInputs()">
                </div>
                <div class="param-input">
                    <label>Y</label>
                    <input type="number" id="pos-y" step="0.1" onchange="updateTransformFromInputs()">
                </div>
                <div class="param-input">
                    <label>Z</label>
                    <input type="number" id="pos-z" step="0.1" onchange="updateTransformFromInputs()">
                </div>
            </div>
        </div>

        <div class="param-section">
            <div class="param-section-title">Rotation (degr√©s)</div>
            <div class="param-row">
                <div class="param-input">
                    <label>X</label>
                    <input type="number" id="rot-x" step="1" onchange="updateTransformFromInputs()">
                </div>
                <div class="param-input">
                    <label>Y</label>
                    <input type="number" id="rot-y" step="1" onchange="updateTransformFromInputs()">
                </div>
                <div class="param-input">
                    <label>Z</label>
                    <input type="number" id="rot-z" step="1" onchange="updateTransformFromInputs()">
                </div>
            </div>
        </div>

        <div class="param-section">
            <div class="param-section-title">Scale</div>
            <div class="param-row">
                <div class="param-input">
                    <label>X</label>
                    <input type="number" id="scale-x" step="0.1" min="0.01" onchange="updateTransformFromInputs()">
                </div>
                <div class="param-input">
                    <label>Y</label>
                    <input type="number" id="scale-y" step="0.1" min="0.01" onchange="updateTransformFromInputs()">
                </div>
                <div class="param-input">
                    <label>Z</label>
                    <input type="number" id="scale-z" step="0.1" min="0.01" onchange="updateTransformFromInputs()">
                </div>
            </div>
        </div>

        <button onclick="resetTransform()">Reset Transform</button>
    </div>

    <!-- Primitive Creation Popup -->
    <div id="primitive-popup">
        <div class="popup-item" onclick="addPrimitive('cube')">
            <span class="popup-icon">‚¨õ</span>
            <span>Cube</span>
        </div>
        <div class="popup-item" onclick="addPrimitive('sphere')">
            <span class="popup-icon">‚ö´</span>
            <span>Sph√®re</span>
        </div>
        <div class="popup-item" onclick="addPrimitive('cylinder')">
            <span class="popup-icon">‚¨ú</span>
            <span>Cylindre</span>
        </div>
        <div class="popup-item" onclick="addPrimitive('cone')">
            <span class="popup-icon">üî∫</span>
            <span>C√¥ne</span>
        </div>
        <div class="popup-item" onclick="addPrimitive('torus')">
            <span class="popup-icon">‚≠ï</span>
            <span>Tore</span>
        </div>
        <div class="popup-item" onclick="addPrimitive('plane')">
            <span class="popup-icon">‚ñ≠</span>
            <span>Plan</span>
        </div>
        <div class="popup-divider"></div>
        <div class="popup-item" onclick="addWall()">
            <span class="popup-icon">üß±</span>
            <span>Mur Standard</span>
        </div>
    </div>

    <div id="controls">
        <div class="projector-model">
            <div class="brand">Panasonic</div>
            <div class="model-name">PT-RQ25K</div>
            <div class="specs-summary">20,000 lm ‚Ä¢ 4K ‚Ä¢ 16:10</div>
        </div>

        <div class="shader-quality-badge">
            ‚ú® PROFESSIONAL SHADOW-MAPPED SHADER ‚ú®
        </div>

        <div id="selection-info">S√©lection: <span class="selected-name" id="selected-name">Aucun</span></div>

        <div class="throw-display">
            <div class="label">THROW RATIO</div>
            <div class="value" id="throw-ratio-display">1.36:1</div>
            <div class="sub">Distance: <span id="distance-display">10.00</span> m</div>
        </div>

        <div class="control-group">
            <h3>üìê Dimensions Image</h3>
            <div class="measurement-group">
                <div class="measurement-input">
                    <label>Largeur</label>
                    <input type="number" id="image-width" value="7.35" step="0.1" min="1" max="50" onchange="updateFromWidth()">
                    <div class="unit">m√®tres</div>
                </div>
                <div class="measurement-input">
                    <label>Hauteur</label>
                    <input type="number" id="image-height" value="4.59" step="0.1" min="0.5" max="30" onchange="updateFromHeight()">
                    <div class="unit">m√®tres</div>
                </div>
            </div>
            <div class="control-row" style="margin-top:8px;">
                <label>Frustum Far: <span class="value-display" id="frustum-far-val">15.0 m</span></label>
                <input type="range" id="frustum-far" min="0.5" max="50" step="0.1" value="15" oninput="updateFrustumFar()">
            </div>
        </div>

        <div class="control-group">
            <h3>üî≠ Optique</h3>
            <select id="lens-select" onchange="changeLens()">
                <option value="ET-D3LEU100">ET-D3LEU100 (0.36:1)</option>
                <option value="ET-D3LEW200">ET-D3LEW200 (0.48-0.55:1)</option>
                <option value="ET-D3LEW60">ET-D3LEW60 (0.68-0.80:1)</option>
                <option value="ET-D75LE6">ET-D75LE6 (0.90-1.10:1)</option>
                <option value="ET-D3LEW10">ET-D3LEW10 (1.01-1.30:1)</option>
                <option value="ET-D3LES20" selected>ET-D3LES20 (1.36-1.78:1)</option>
                <option value="ET-D3LET80">ET-D3LET80 (1.81-2.56:1)</option>
                <option value="ET-D75LE95">ET-D75LE95 (0.80:1)</option>
            </select>
            <div class="lens-specs">
                <div class="spec-row"><span>Throw:</span><span class="spec-value" id="spec-throw">1.36-1.78:1</span></div>
                <div class="spec-row"><span>Shift V:</span><span class="spec-value" id="spec-shift-v">¬±66%</span></div>
                <div class="spec-row"><span>Shift H:</span><span class="spec-value" id="spec-shift-h">¬±24%</span></div>
            </div>
            <div class="control-row" style="margin-top:6px;">
                <label>Zoom: <span class="value-display" id="zoom-val">1.36:1</span></label>
                <input type="range" id="zoom" min="1.36" max="1.78" step="0.01" value="1.36" oninput="updateZoom()">
            </div>
        </div>

        <div class="control-group">
            <h3>üìê Lens Shift</h3>
            <div class="control-row">
                <label>Vertical: <span class="value-display" id="shift-v-val">0%</span></label>
                <input type="range" id="shift-v" min="-66" max="66" step="1" value="0" oninput="updateLensShift()">
            </div>
            <div class="control-row">
                <label>Horizontal: <span class="value-display" id="shift-h-val">0%</span></label>
                <input type="range" id="shift-h" min="-24" max="24" step="1" value="0" oninput="updateLensShift()">
            </div>
            <button class="secondary" onclick="resetLensShift()">Reset</button>
        </div>

        <div class="control-group">
            <h3>üåì Shadow Quality</h3>
            <div class="control-row">
                <label>Shadow Softness: <span class="value-display" id="shadow-softness-val">1.0</span></label>
                <input type="range" id="shadow-softness" min="0" max="3" step="0.1" value="1.0" oninput="updateShadowQuality()">
            </div>
            <div class="control-row">
                <label>Shadow Bias: <span class="value-display" id="shadow-bias-val">0.003</span></label>
                <input type="range" id="shadow-bias" min="0.0001" max="0.01" step="0.0001" value="0.003" oninput="updateShadowQuality()">
            </div>
            <div class="control-row">
                <label>Projection Intensity: <span class="value-display" id="proj-intensity-val">1.0</span></label>
                <input type="range" id="proj-intensity" min="0" max="2" step="0.1" value="1.0" oninput="updateProjectionIntensity()">
            </div>
        </div>

        <div class="control-group">
            <h3>üéØ Options</h3>
            <div class="checkbox-row">
                <input type="checkbox" id="target-locked" checked onchange="toggleTargetLock()">
                <span>Lock Aim to Target</span>
            </div>
            <div class="checkbox-row">
                <input type="checkbox" id="show-frustum" onchange="toggleFrustum()">
                <span>Frustum Helper</span>
            </div>
            <div class="checkbox-row">
                <input type="checkbox" id="show-measurements" checked onchange="toggleMeasurements()">
                <span>Mesures Viewport</span>
            </div>
            <div class="checkbox-row">
                <input type="checkbox" id="high-quality-pcf" checked onchange="togglePCFQuality()">
                <span>High Quality PCF (Poisson)</span>
            </div>

            <div style="margin-top:8px;">
                <label style="margin-bottom:4px;">Snap Target:</label>
                <div style="display:flex; align-items:center; gap:8px;">
                    <div class="snap-selector">
                        <button class="snap-btn corner" data-snap="tl" onclick="setSnapPoint('tl')"></button>
                        <button class="snap-btn corner" data-snap="tr" onclick="setSnapPoint('tr')"></button>
                        <button class="snap-btn center active" data-snap="c" onclick="setSnapPoint('c')"></button>
                        <button class="snap-btn corner" data-snap="bl" onclick="setSnapPoint('bl')"></button>
                        <button class="snap-btn corner" data-snap="br" onclick="setSnapPoint('br')"></button>
                    </div>
                    <button class="secondary" style="flex:1; margin-top:0;" onclick="setSelectedAsTarget()">Appliquer</button>
                </div>
            </div>
        </div>

        <div class="control-group">
            <h3>üñºÔ∏è Contenu</h3>
            <input type="file" id="image-upload" accept="image/*" onchange="loadImage()">
            <button class="secondary" onclick="removeImage()">Enlever</button>
            <div id="image-status"></div>
        </div>

        <div class="control-group">
            <h3>üì¶ Objets 3D</h3>

            <div class="add-primitive-btn" onclick="showPrimitivePopup(event)">
                ‚ûï Ajouter une Primitive
            </div>

            <button class="danger" onclick="clearObjects()" style="margin-top:8px;">Effacer Tout</button>
        </div>

        <div class="control-group">
            <h3>‚å®Ô∏è Raccourcis</h3>
            <div class="keyboard-hint">
                <strong>Gizmo:</strong> G = Move ‚Ä¢ R = Rotate ‚Ä¢ S = Scale<br>
                <strong>Objet:</strong> Del = Supprimer ‚Ä¢ Esc = D√©s√©lectionner
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>

    <script>
    // ========== CONSTANTS ==========
    const ASPECT = 16/10;
    const LUMENS = 20000;

    const LENSES = {
        'ET-D3LEU100': { throwMin: 0.36, throwMax: 0.36, fixed: true, shiftV: [-66, 66], shiftH: [-24, 24] },
        'ET-D3LEW200': { throwMin: 0.48, throwMax: 0.55, fixed: false, shiftV: [-66, 66], shiftH: [-24, 24] },
        'ET-D3LEW60': { throwMin: 0.68, throwMax: 0.80, fixed: false, shiftV: [-66, 66], shiftH: [-24, 24] },
        'ET-D75LE6': { throwMin: 0.90, throwMax: 1.10, fixed: false, shiftV: [-66, 66], shiftH: [-24, 24] },
        'ET-D3LEW10': { throwMin: 1.01, throwMax: 1.30, fixed: false, shiftV: [-66, 66], shiftH: [-24, 24] },
        'ET-D3LES20': { throwMin: 1.36, throwMax: 1.78, fixed: false, shiftV: [-66, 66], shiftH: [-24, 24] },
        'ET-D3LET80': { throwMin: 1.81, throwMax: 2.56, fixed: false, shiftV: [-66, 66], shiftH: [-24, 24] },
        'ET-D75LE95': { throwMin: 0.80, throwMax: 0.80, fixed: true, shiftV: [-66, 66], shiftH: [-24, 24] }
    };

    // ========== STATE ==========
    let currentLens = LENSES['ET-D3LES20'];
    let throwRatio = 1.36;
    let frustumFar = 15.0;
    let projDistance = 10;
    let lensShiftV = 0, lensShiftH = 0;
    let targetLocked = true;
    let showMeasurements = true;
    let userMovedTarget = true;
    let snapPoint = 'c';
    let shadowSoftness = 1.0;
    let shadowBias = 0.003;
    let projectionIntensity = 1.0;
    let useHighQualityPCF = true;

    // Core
    let scene, camera, renderer, controls, transformControls;
    let raycaster, mouse, selectedObject = null;

    // Projector pieces
    let projectorGroup, projectorMesh, projectorCamera, projectorHelper, shadowLight;
    let targetMesh;
    let projectionTexture = null;

    let spriteWidth, spriteHeight, spriteTR, spriteInfo;
    let projectedObjects = [];
    let selectableObjects = [];

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(6,4,12);
        camera.lookAt(0,0,-5);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('container').appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        transformControls = new THREE.TransformControls(camera, renderer.domElement);
        transformControls.setSize(0.75);
        transformControls.setMode('translate'); // Initialize with translate mode
        transformControls.addEventListener('dragging-changed', e => {
            controls.enabled = !e.value;
        });
        transformControls.addEventListener('objectChange', onTransformChange);
        transformControls.addEventListener('change', updateTransformInputs);
        scene.add(transformControls);

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const dir = new THREE.DirectionalLight(0xffffff, 0.6);
        dir.position.set(5,10,5);
        scene.add(dir);

        const grid = new THREE.GridHelper(30,30,0x444444,0x222222);
        grid.userData.noProjection = true;
        scene.add(grid);

        const axes = new THREE.AxesHelper(2);
        axes.userData.noProjection = true;
        scene.add(axes);

        createProjector();
        createMeasurementSprites();

        // DON'T add wall automatically - let user add primitives manually
        // addWall();

        window.addEventListener('resize', onResize);
        renderer.domElement.addEventListener('click', onClick);
        window.addEventListener('keydown', onKeyDown);
        document.addEventListener('click', hidePrimitivePopup);

        changeLens();
        updateAll();

        animate();
    }

    function createProjector() {
        projectorGroup = new THREE.Group();
        projectorGroup.position.set(0,0,0);
        scene.add(projectorGroup);

        const s = 0.0015;
        const geo = new THREE.BoxGeometry(550*s, 220*s, 570*s);
        const mat = new THREE.MeshStandardMaterial({ color:0x1a1a1a, metalness:0.8, roughness:0.2 });
        projectorMesh = new THREE.Mesh(geo, mat);
        projectorMesh.position.z = 570*s/2;
        projectorMesh.userData = { type:'projector', name:'PT-RQ25K', isProjector:true, noProjection:true };
        projectorMesh.castShadow = false;
        projectorMesh.receiveShadow = false;
        projectorGroup.add(projectorMesh);
        selectableObjects.push(projectorMesh);

        const lensGeo = new THREE.CylinderGeometry(0.08,0.10,0.04,32);
        const lensMat = new THREE.MeshBasicMaterial({ color:0x00ffff });
        const lens = new THREE.Mesh(lensGeo, lensMat);
        lens.rotation.x = Math.PI/2;
        lens.position.z = -570*s/2 - 0.02;
        projectorMesh.add(lens);

        projectorCamera = new THREE.PerspectiveCamera(throwToFOV(throwRatio), ASPECT, 0.1, frustumFar);
        projectorGroup.add(projectorCamera);

        // INVISIBLE SPOTLIGHT - Shadow maps only
        shadowLight = new THREE.SpotLight(0x000000, 0);
        shadowLight.angle = THREE.MathUtils.degToRad(throwToFOV(throwRatio));
        shadowLight.penumbra = 0;
        shadowLight.decay = 0;
        shadowLight.distance = frustumFar;
        shadowLight.castShadow = true;
        shadowLight.shadow.mapSize.width = 4096;
        shadowLight.shadow.mapSize.height = 4096;
        shadowLight.shadow.camera.near = 0.1;
        shadowLight.shadow.camera.far = frustumFar;
        shadowLight.shadow.camera.aspect = ASPECT;
        shadowLight.shadow.radius = 2;
        shadowLight.shadow.bias = shadowBias;
        shadowLight.position.set(0,0,0);
        projectorGroup.add(shadowLight);

        const shadowTarget = new THREE.Object3D();
        shadowTarget.position.set(0,0,-projDistance);
        projectorGroup.add(shadowTarget);
        shadowLight.target = shadowTarget;
        projectorMesh.userData.shadowTarget = shadowTarget;

        projectorHelper = new THREE.CameraHelper(shadowLight.shadow.camera);
        projectorHelper.visible = false;
        scene.add(projectorHelper);

        const tGeo = new THREE.SphereGeometry(0.15, 32, 32);
        const tMat = new THREE.MeshBasicMaterial({ color:0xffff00 });
        targetMesh = new THREE.Mesh(tGeo, tMat);
        targetMesh.position.set(0,0,-projDistance);
        targetMesh.castShadow = false;
        targetMesh.receiveShadow = false;
        targetMesh.userData = { type:'target', name:'Target', isTarget:true };
        scene.add(targetMesh);
        selectableObjects.push(targetMesh);

        projectorMesh.userData.target = targetMesh;
    }

    function createMeasurementSprites() {
        spriteWidth = createTextSprite('0.00 m');
        spriteHeight = createTextSprite('0.00 m');
        spriteTR = createTextSprite('tr: 0.00');
        spriteInfo = createTextSprite('P1\n0 lx');
        scene.add(spriteWidth);
        scene.add(spriteHeight);
        scene.add(spriteTR);
        scene.add(spriteInfo);
    }

    function createTextSprite(text) {
        const canvas = document.createElement('canvas');
        canvas.width = 256; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent:true, side:THREE.DoubleSide, depthTest:false });
        const geometry = new THREE.PlaneGeometry(1.5, 0.375);
        const mesh = new THREE.Mesh(geometry, material);
        mesh.userData.canvas = canvas; mesh.userData.ctx = ctx; mesh.userData.texture = texture;
        mesh.userData.isLabel = true;
        updateSpriteText(mesh, text);
        return mesh;
    }

    function updateSpriteText(sprite, text) {
        const ctx = sprite.userData.ctx; const canvas = sprite.userData.canvas;
        ctx.clearRect(0,0,canvas.width, canvas.height);
        ctx.fillStyle = '#c0c0c0'; ctx.font = 'bold 22px monospace'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(text, canvas.width/2, canvas.height/2);
        sprite.userData.texture.needsUpdate = true;
    }

    function throwToFOV(tr) {
        const hFov = 2 * Math.atan(1 / (2 * tr));
        const vFov = 2 * Math.atan(Math.tan(hFov/2) / ASPECT);
        return THREE.MathUtils.radToDeg(vFov);
    }

    function applyLensShiftToCamera(camera, shiftH_frac, shiftV_frac) {
        camera.updateProjectionMatrix();
        const pm = camera.projectionMatrix.elements;
        pm[8] = - shiftH_frac;
        pm[9] =   shiftV_frac;
    }

    /**
     * PROFESSIONAL SHADOW-MAPPED PROJECTION SHADER
     */
    function createProjectedMaterial() {
        return new THREE.ShaderMaterial({
            uniforms: {
                projTexture: { value: projectionTexture },
                projMatrix: { value: new THREE.Matrix4() },
                projPosition: { value: new THREE.Vector3() },
                baseColor: { value: new THREE.Color(0x666666) }, // Lighter base color
                projColor: { value: new THREE.Color(0xffffff) },
                intensity: { value: projectionIntensity },
                hasTexture: { value: false },
                shiftV: { value: 0 },
                shiftH: { value: 0 },
                shadowMap: { value: null },
                shadowMatrix: { value: new THREE.Matrix4() },
                shadowMapSize: { value: new THREE.Vector2(4096,4096) },
                shadowCameraNear: { value: 0.1 },
                shadowCameraFar: { value: frustumFar },
                shadowBias: { value: shadowBias },
                shadowSoftness: { value: shadowSoftness },
                useHighQualityPCF: { value: useHighQualityPCF }
            },
            vertexShader: `
                varying vec4 vProjCoords;
                varying vec3 vNormal;
                varying vec3 vWorldPos;
                varying vec4 vShadowCoord;
                varying vec3 vViewPos;

                uniform mat4 projMatrix;
                uniform mat4 shadowMatrix;

                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPos = worldPosition.xyz;
                    vProjCoords = projMatrix * worldPosition;
                    vShadowCoord = shadowMatrix * worldPosition;
                    vViewPos = (modelViewMatrix * vec4(position, 1.0)).xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                precision highp float;

                uniform sampler2D projTexture;
                uniform sampler2D shadowMap;
                uniform vec3 baseColor;
                uniform vec3 projColor;
                uniform vec3 projPosition;
                uniform float intensity;
                uniform float shiftV;
                uniform float shiftH;
                uniform bool hasTexture;
                uniform vec2 shadowMapSize;
                uniform float shadowBias;
                uniform float shadowSoftness;
                uniform bool useHighQualityPCF;
                uniform float shadowCameraFar;

                varying vec4 vProjCoords;
                varying vec4 vShadowCoord;
                varying vec3 vNormal;
                varying vec3 vWorldPos;
                varying vec3 vViewPos;

                const vec2 poissonDisk[16] = vec2[](
                    vec2(-0.94201624, -0.39906216),
                    vec2(0.94558609, -0.76890725),
                    vec2(-0.094184101, -0.92938870),
                    vec2(0.34495938, 0.29387760),
                    vec2(-0.91588581, 0.45771432),
                    vec2(-0.81544232, -0.87912464),
                    vec2(-0.38277543, 0.27676845),
                    vec2(0.97484398, 0.75648379),
                    vec2(0.44323325, -0.97511554),
                    vec2(0.53742981, -0.47373420),
                    vec2(-0.26496911, -0.41893023),
                    vec2(0.79197514, 0.19090188),
                    vec2(-0.24188840, 0.99706507),
                    vec2(-0.81409955, 0.91437590),
                    vec2(0.19984126, 0.78641367),
                    vec2(0.14383161, -0.14100790)
                );

                float readShadowMapDepth(vec2 uv) {
                    return texture2D(shadowMap, uv).r;
                }

                float getShadowPCF_Poisson(vec3 shadowCoord, vec3 normal, vec3 lightDir, float softness) {
                    float currentDepth = shadowCoord.z;
                    vec2 texelSize = 1.0 / shadowMapSize;
                    float nDotL = clamp(dot(normalize(normal), normalize(lightDir)), 0.0, 1.0);
                    float normalBias = mix(0.005, 0.0005, nDotL);
                    float bias = max(normalBias, shadowBias);
                    float shadow = 0.0;
                    float radius = softness * 2.0;

                    for (int i = 0; i < 16; i++) {
                        vec2 offset = poissonDisk[i] * texelSize * radius;
                        vec2 uv = shadowCoord.xy + offset;
                        if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
                            shadow += 1.0;
                            continue;
                        }
                        float shadowDepth = readShadowMapDepth(uv);
                        shadow += (currentDepth - bias) > shadowDepth ? 0.0 : 1.0;
                    }
                    return shadow / 16.0;
                }

                float getShadowPCF_Standard(vec3 shadowCoord, vec3 normal, vec3 lightDir, float softness) {
                    float currentDepth = shadowCoord.z;
                    vec2 texelSize = 1.0 / shadowMapSize;
                    float nDotL = clamp(dot(normalize(normal), normalize(lightDir)), 0.0, 1.0);
                    float normalBias = mix(0.005, 0.0005, nDotL);
                    float bias = max(normalBias, shadowBias);
                    float shadow = 0.0;
                    float samples = 0.0;
                    int range = int(softness) + 1;

                    for (int y = -range; y <= range; y++) {
                        for (int x = -range; x <= range; x++) {
                            vec2 offset = vec2(float(x), float(y)) * texelSize;
                            vec2 uv = shadowCoord.xy + offset;
                            if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
                                samples += 1.0;
                                continue;
                            }
                            float shadowDepth = readShadowMapDepth(uv);
                            shadow += (currentDepth - bias) > shadowDepth ? 0.0 : 1.0;
                            samples += 1.0;
                        }
                    }
                    return samples > 0.0 ? shadow / samples : 0.0;
                }

                float getEdgeSoftness(vec2 uv, float margin) {
                    vec2 edgeDist = min(uv, 1.0 - uv);
                    float minDist = min(edgeDist.x, edgeDist.y);
                    return smoothstep(0.0, margin, minDist);
                }

                void main() {
                    vec3 color = baseColor;
                    float distToProj = distance(projPosition, vWorldPos);

                    // Don't project on objects too close to projector
                    if (distToProj < 0.15) {
                        gl_FragColor = vec4(color, 1.0);
                        return;
                    }

                    vec3 shadowCoord = vShadowCoord.xyz / vShadowCoord.w;
                    shadowCoord = shadowCoord * 0.5 + 0.5;
                    bool shadowOutside = (shadowCoord.x < 0.0 || shadowCoord.x > 1.0 ||
                                         shadowCoord.y < 0.0 || shadowCoord.y > 1.0 ||
                                         shadowCoord.z < 0.0 || shadowCoord.z > 1.0);

                    vec3 lightDir = projPosition - vWorldPos;
                    float visibility = 1.0;

                    if (!shadowOutside) {
                        if (useHighQualityPCF) {
                            visibility = getShadowPCF_Poisson(shadowCoord, vNormal, lightDir, shadowSoftness);
                        } else {
                            visibility = getShadowPCF_Standard(shadowCoord, vNormal, lightDir, shadowSoftness);
                        }
                    }

                    if (visibility > 0.01) {
                        vec3 projCoord = vProjCoords.xyz / vProjCoords.w;
                        vec2 uv = projCoord.xy * 0.5 + 0.5;
                        uv.x -= shiftH;
                        uv.y -= shiftV;

                        if (uv.x >= 0.0 && uv.x <= 1.0 &&
                            uv.y >= 0.0 && uv.y <= 1.0 &&
                            projCoord.z >= 0.0 && projCoord.z <= 1.0) {

                            vec3 projDir = normalize(lightDir);
                            float facing = clamp(dot(normalize(vNormal), projDir), 0.0, 1.0);
                            facing = max(facing, 0.25);
                            float distAttenuation = 1.0 - smoothstep(shadowCameraFar * 0.7, shadowCameraFar, distToProj);
                            float edgeSoft = getEdgeSoftness(uv, 0.05);
                            float projMix = intensity * facing * visibility * distAttenuation * edgeSoft;

                            if (hasTexture) {
                                vec4 texColor = texture2D(projTexture, uv);
                                color = mix(color, texColor.rgb * projColor, texColor.a * projMix);
                            } else {
                                color = mix(color, projColor, projMix);
                            }
                        }
                    }

                    gl_FragColor = vec4(color, 1.0);
                }
            `,
            side: THREE.DoubleSide
        });
    }

    // ===== GIZMO MODE CONTROLS =====

    window.setGizmoMode = function(mode) {
        if (!transformControls) return;
        transformControls.setMode(mode);

        // Update UI buttons
        document.querySelectorAll('.gizmo-mode-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        document.querySelector(`[data-mode="${mode}"]`).classList.add('active');
    };

    // ===== TRANSFORM CONTROLS =====

    function updateTransformInputs() {
        if (!selectedObject) return;

        const obj = selectedObject.userData.isProjector ? projectorGroup : selectedObject;

        document.getElementById('pos-x').value = obj.position.x.toFixed(2);
        document.getElementById('pos-y').value = obj.position.y.toFixed(2);
        document.getElementById('pos-z').value = obj.position.z.toFixed(2);

        document.getElementById('rot-x').value = THREE.MathUtils.radToDeg(obj.rotation.x).toFixed(1);
        document.getElementById('rot-y').value = THREE.MathUtils.radToDeg(obj.rotation.y).toFixed(1);
        document.getElementById('rot-z').value = THREE.MathUtils.radToDeg(obj.rotation.z).toFixed(1);

        document.getElementById('scale-x').value = obj.scale.x.toFixed(2);
        document.getElementById('scale-y').value = obj.scale.y.toFixed(2);
        document.getElementById('scale-z').value = obj.scale.z.toFixed(2);
    }

    window.updateTransformFromInputs = function() {
        if (!selectedObject) return;

        const obj = selectedObject.userData.isProjector ? projectorGroup : selectedObject;

        obj.position.x = parseFloat(document.getElementById('pos-x').value);
        obj.position.y = parseFloat(document.getElementById('pos-y').value);
        obj.position.z = parseFloat(document.getElementById('pos-z').value);

        obj.rotation.x = THREE.MathUtils.degToRad(parseFloat(document.getElementById('rot-x').value));
        obj.rotation.y = THREE.MathUtils.degToRad(parseFloat(document.getElementById('rot-y').value));
        obj.rotation.z = THREE.MathUtils.degToRad(parseFloat(document.getElementById('rot-z').value));

        obj.scale.x = parseFloat(document.getElementById('scale-x').value);
        obj.scale.y = parseFloat(document.getElementById('scale-y').value);
        obj.scale.z = parseFloat(document.getElementById('scale-z').value);

        updateProjectionMatrix();
        updateMeasurements();
    };

    window.resetTransform = function() {
        if (!selectedObject || selectedObject.userData.isProjector || selectedObject.userData.isTarget) return;

        selectedObject.position.set(0, 0, 0);
        selectedObject.rotation.set(0, 0, 0);
        selectedObject.scale.set(1, 1, 1);

        updateTransformInputs();
        updateProjectionMatrix();
    };

    // ===== PRIMITIVE POPUP =====

    window.showPrimitivePopup = function(event) {
        event.stopPropagation();
        const popup = document.getElementById('primitive-popup');
        popup.classList.add('visible');

        const rect = event.target.getBoundingClientRect();
        popup.style.left = rect.left + 'px';
        popup.style.top = (rect.top - popup.offsetHeight - 5) + 'px';
    };

    function hidePrimitivePopup(event) {
        const popup = document.getElementById('primitive-popup');
        if (!popup.contains(event.target) && !event.target.classList.contains('add-primitive-btn')) {
            popup.classList.remove('visible');
        }
    }

    // ===== UPDATES =====

    function updateAll() {
        updateProjectorCamera();
        updateProjectionMatrix();
        updateMeasurements();
        updateUI();
    }

    function updateProjectorCamera() {
        if (!projectorCamera) return;
        projectorCamera.aspect = ASPECT;
        projectorCamera.fov = throwToFOV(throwRatio);
        projectorCamera.far = frustumFar;
        projectorCamera.updateProjectionMatrix();
    }

    function updateProjectionMatrix() {
        if (!projectorCamera || !shadowLight) return;

        projectorCamera.updateMatrixWorld();
        projectorCamera.updateProjectionMatrix();
        applyLensShiftToCamera(projectorCamera, lensShiftH / 100, lensShiftV / 100);

        const projMatrix = new THREE.Matrix4();
        projMatrix.multiplyMatrices(projectorCamera.projectionMatrix, projectorCamera.matrixWorldInverse);

        const worldPos = new THREE.Vector3();
        projectorCamera.getWorldPosition(worldPos);

        const fov = throwToFOV(throwRatio);
        shadowLight.angle = THREE.MathUtils.degToRad(fov);
        shadowLight.shadow.camera.fov = fov;
        shadowLight.shadow.camera.aspect = ASPECT;
        shadowLight.shadow.camera.near = projectorCamera.near;
        shadowLight.shadow.camera.far = frustumFar;
        shadowLight.shadow.bias = shadowBias;
        shadowLight.shadow.camera.updateProjectionMatrix();
        applyLensShiftToCamera(shadowLight.shadow.camera, lensShiftH / 100, lensShiftV / 100);

        shadowLight.updateMatrixWorld(true);
        shadowLight.shadow.camera.updateMatrixWorld(true);

        const shadowMatrix = new THREE.Matrix4();
        shadowMatrix.multiplyMatrices(shadowLight.shadow.camera.projectionMatrix, shadowLight.shadow.camera.matrixWorldInverse);

        const dist = projDistance;
        const width = dist / throwRatio;
        const height = width / ASPECT;
        const shiftOffsetV = (lensShiftV / 100) * height;
        const shiftOffsetH = (lensShiftH / 100) * width;
        const localCenter = new THREE.Vector3(shiftOffsetH, shiftOffsetV, -dist);
        if (projectorMesh.userData.shadowTarget) {
            projectorMesh.userData.shadowTarget.position.copy(localCenter);
        }

        projectedObjects.forEach(obj => {
            if (obj.userData?.noProjection) return;
            if (obj.material?.uniforms) {
                obj.material.uniforms.projMatrix.value.copy(projMatrix);
                obj.material.uniforms.projPosition.value.copy(worldPos);
                obj.material.uniforms.shiftV.value = lensShiftV / 100;
                obj.material.uniforms.shiftH.value = lensShiftH / 100;
                obj.material.uniforms.hasTexture.value = !!projectionTexture;
                obj.material.uniforms.intensity.value = projectionIntensity;
                obj.material.uniforms.shadowSoftness.value = shadowSoftness;
                obj.material.uniforms.shadowBias.value = shadowBias;
                obj.material.uniforms.useHighQualityPCF.value = useHighQualityPCF;
                obj.material.uniforms.shadowCameraFar.value = frustumFar;

                if (projectionTexture) obj.material.uniforms.projTexture.value = projectionTexture;

                obj.material.uniforms.shadowMatrix.value.copy(shadowMatrix);
                obj.material.uniforms.shadowMap.value = shadowLight.shadow.map ? shadowLight.shadow.map.texture : null;
                obj.material.uniforms.shadowMapSize.value.set(shadowLight.shadow.mapSize.width, shadowLight.shadow.mapSize.height);
                obj.material.uniforms.shadowCameraNear.value = shadowLight.shadow.camera.near;
                obj.material.uniforms.shadowCameraFar.value = shadowLight.shadow.camera.far;

                obj.material.needsUpdate = true;
            }
        });

        if (projectorHelper) projectorHelper.update();
    }

    function updateMeasurements() {
        if (!targetMesh || !projectorGroup) return;

        const dist = targetMesh.position.distanceTo(projectorGroup.position);
        const width = dist / throwRatio;
        const height = width / ASPECT;

        const shiftOffsetV = (lensShiftV / 100) * height;
        const shiftOffsetH = (lensShiftH / 100) * width;

        const imgCenter = targetMesh.position.clone();
        imgCenter.y += shiftOffsetV;
        imgCenter.x += shiftOffsetH;

        const visible = showMeasurements;
        const projPos = projectorGroup.position.clone();

        const labelHalfHeight = 0.1875;
        const offset = 0.02;

        spriteWidth.visible = visible;
        spriteWidth.position.set(imgCenter.x, imgCenter.y + height/2 + labelHalfHeight + offset, imgCenter.z);
        spriteWidth.lookAt(projPos);
        updateSpriteText(spriteWidth, width.toFixed(3) + ' m');

        spriteHeight.visible = visible;
        spriteHeight.position.set(imgCenter.x - width/2, imgCenter.y, imgCenter.z);
        spriteHeight.lookAt(projPos);
        updateSpriteText(spriteHeight, height.toFixed(3) + ' m');

        spriteTR.visible = visible;
        spriteTR.position.set(imgCenter.x - width/2, imgCenter.y + height/2 + labelHalfHeight + offset, imgCenter.z);
        spriteTR.lookAt(projPos);
        updateSpriteText(spriteTR, 'tr: ' + throwRatio.toFixed(2));

        spriteInfo.visible = visible;
        const midPoint = projectorGroup.position.clone().lerp(targetMesh.position, 0.5);
        spriteInfo.position.copy(midPoint);
        spriteInfo.lookAt(projPos);
        const lux = LUMENS / (width * height);
        updateSpriteText(spriteInfo, lux.toFixed(0) + ' lx / ' + dist.toFixed(3) + ' m');

        document.getElementById('image-width').value = width.toFixed(2);
        document.getElementById('image-height').value = height.toFixed(2);
        document.getElementById('throw-ratio-display').textContent = throwRatio.toFixed(2) + ':1';
        document.getElementById('distance-display').textContent = dist.toFixed(2);
    }

    function updateUI() {
        document.getElementById('zoom-val').textContent = throwRatio.toFixed(2) + ':1';
        document.getElementById('shift-v-val').textContent = lensShiftV + '%';
        document.getElementById('shift-h-val').textContent = lensShiftH + '%';
        document.getElementById('shadow-softness-val').textContent = shadowSoftness.toFixed(1);
        document.getElementById('shadow-bias-val').textContent = shadowBias.toFixed(4);
        document.getElementById('proj-intensity-val').textContent = projectionIntensity.toFixed(1);
    }

    // ===== PRIMITIVE FUNCTIONS =====

    window.addPrimitive = function(type) {
        const sizeX = 1.5;
        const sizeY = 1.5;
        const sizeZ = 1.5;

        let geometry;
        let name = '';

        switch(type) {
            case 'cube':
                geometry = new THREE.BoxGeometry(sizeX, sizeY, sizeZ);
                name = 'Cube';
                break;
            case 'sphere':
                geometry = new THREE.SphereGeometry(sizeX / 2, 32, 32);
                name = 'Sph√®re';
                break;
            case 'cylinder':
                geometry = new THREE.CylinderGeometry(sizeX / 2, sizeX / 2, sizeY, 32);
                name = 'Cylindre';
                break;
            case 'cone':
                geometry = new THREE.ConeGeometry(sizeX / 2, sizeY, 32);
                name = 'C√¥ne';
                break;
            case 'torus':
                geometry = new THREE.TorusGeometry(sizeX / 2, sizeX / 6, 16, 100);
                name = 'Tore';
                break;
            case 'plane':
                geometry = new THREE.PlaneGeometry(sizeX * 3, sizeY * 3);
                name = 'Plan';
                break;
            default:
                return;
        }

        const mat = createProjectedMaterial();
        const mesh = new THREE.Mesh(geometry, mat);

        // Position primitives in front of projector
        mesh.position.set(
            Math.random() * 2 - 1,
            sizeY / 2 + 0.5,
            -5 - Math.random() * 2
        );

        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.userData = { name: name, type: 'object' };

        scene.add(mesh);
        projectedObjects.push(mesh);
        selectableObjects.push(mesh);

        console.log('Added primitive:', type, 'at position:', mesh.position);

        updateProjectionMatrix();
        selectObject(mesh);

        document.getElementById('primitive-popup').classList.remove('visible');
    };

    window.addWall = function() {
        const geo = new THREE.BoxGeometry(8, 5, 0.2);
        const mat = createProjectedMaterial();
        const wall = new THREE.Mesh(geo, mat);
        wall.position.set(0, 2.5, -8);
        wall.castShadow = true;
        wall.receiveShadow = true;
        wall.userData = { name: 'Mur', type: 'object' };
        scene.add(wall);
        projectedObjects.push(wall);
        selectableObjects.push(wall);

        console.log('Added wall at position:', wall.position);

        updateProjectionMatrix();

        document.getElementById('primitive-popup').classList.remove('visible');
    };

    window.clearObjects = function() {
        const toRemove = projectedObjects.filter(o => o.userData.type === 'object');
        toRemove.forEach(o => {
            scene.remove(o);
            o.geometry?.dispose();
            o.material?.dispose();
            projectedObjects.splice(projectedObjects.indexOf(o), 1);
            selectableObjects.splice(selectableObjects.indexOf(o), 1);
        });
        if (selectedObject && toRemove.includes(selectedObject)) selectObject(null);
    };

    // ===== UI HANDLERS =====

    window.changeLens = function() {
        const id = document.getElementById('lens-select').value;
        currentLens = LENSES[id];

        document.getElementById('spec-throw').textContent =
            currentLens.fixed ? currentLens.throwMin + ':1' : currentLens.throwMin + '-' + currentLens.throwMax + ':1';
        document.getElementById('spec-shift-v').textContent = currentLens.shiftV[0] + '% / +' + currentLens.shiftV[1] + '%';
        document.getElementById('spec-shift-h').textContent = currentLens.shiftH[0] + '% / +' + currentLens.shiftH[1] + '%';

        const zoomEl = document.getElementById('zoom');
        zoomEl.min = currentLens.throwMin;
        zoomEl.max = currentLens.throwMax;
        zoomEl.disabled = currentLens.fixed;

        throwRatio = Math.max(currentLens.throwMin, Math.min(currentLens.throwMax, throwRatio));
        zoomEl.value = throwRatio;

        const svEl = document.getElementById('shift-v');
        svEl.min = currentLens.shiftV[0];
        svEl.max = currentLens.shiftV[1];
        lensShiftV = Math.max(currentLens.shiftV[0], Math.min(currentLens.shiftV[1], lensShiftV));
        svEl.value = lensShiftV;

        const shEl = document.getElementById('shift-h');
        shEl.min = currentLens.shiftH[0];
        shEl.max = currentLens.shiftH[1];
        lensShiftH = Math.max(currentLens.shiftH[0], Math.min(currentLens.shiftH[1], lensShiftH));
        shEl.value = lensShiftH;

        updateAll();
    };

    window.updateZoom = function() { throwRatio = parseFloat(document.getElementById('zoom').value); updateAll(); };

    window.updateFrustumFar = function() {
        frustumFar = parseFloat(document.getElementById('frustum-far').value);
        document.getElementById('frustum-far-val').textContent = frustumFar.toFixed(1) + ' m';
        updateProjectorCamera();
        updateProjectionMatrix();
    };

    window.updateFromWidth = function() {
        const w = parseFloat(document.getElementById('image-width').value);
        if (isNaN(w) || w < 1) return;
        const dist = targetMesh.position.distanceTo(projectorGroup.position);
        const newTR = dist / w;
        if (newTR >= currentLens.throwMin && newTR <= currentLens.throwMax) {
            throwRatio = newTR;
            document.getElementById('zoom').value = throwRatio;
            updateAll();
        }
    };

    window.updateFromHeight = function() {
        const h = parseFloat(document.getElementById('image-height').value);
        if (isNaN(h) || h < 0.5) return;
        const w = h * ASPECT;
        const dist = targetMesh.position.distanceTo(projectorGroup.position);
        const newTR = dist / w;
        if (newTR >= currentLens.throwMin && newTR <= currentLens.throwMax) {
            throwRatio = newTR;
            document.getElementById('zoom').value = throwRatio;
            updateAll();
        }
    };

    window.updateLensShift = function() {
        lensShiftV = parseFloat(document.getElementById('shift-v').value);
        lensShiftH = parseFloat(document.getElementById('shift-h').value);
        updateAll();
    };

    window.resetLensShift = function() {
        lensShiftV = 0; lensShiftH = 0;
        document.getElementById('shift-v').value = 0;
        document.getElementById('shift-h').value = 0;
        updateAll();
    };

    window.updateShadowQuality = function() {
        shadowSoftness = parseFloat(document.getElementById('shadow-softness').value);
        shadowBias = parseFloat(document.getElementById('shadow-bias').value);
        updateAll();
    };

    window.updateProjectionIntensity = function() {
        projectionIntensity = parseFloat(document.getElementById('proj-intensity').value);
        updateProjectionMatrix();
        updateUI();
    };

    window.togglePCFQuality = function() {
        useHighQualityPCF = document.getElementById('high-quality-pcf').checked;
        updateProjectionMatrix();
    };

    window.toggleTargetLock = function() {
        targetLocked = document.getElementById('target-locked').checked;
    };

    window.toggleFrustum = function() {
        projectorHelper.visible = document.getElementById('show-frustum').checked;
    };

    window.toggleMeasurements = function() {
        showMeasurements = document.getElementById('show-measurements').checked;
        updateMeasurements();
    };

    window.setSnapPoint = function(point) {
        snapPoint = point;
        document.querySelectorAll('.snap-btn').forEach(b => b.classList.remove('active'));
        document.querySelector(`[data-snap="${point}"]`).classList.add('active');
    };

    window.setSelectedAsTarget = function() {
        if (!selectedObject || selectedObject.userData.isProjector || selectedObject.userData.isTarget) return;

        const box = new THREE.Box3().setFromObject(selectedObject);
        const center = new THREE.Vector3();
        box.getCenter(center);

        let targetPos = center.clone();
        const size = new THREE.Vector3();
        box.getSize(size);

        switch(snapPoint) {
            case 'tl': targetPos.add(new THREE.Vector3(-size.x/2, size.y/2, 0)); break;
            case 'tr': targetPos.add(new THREE.Vector3(size.x/2, size.y/2, 0)); break;
            case 'bl': targetPos.add(new THREE.Vector3(-size.x/2, -size.y/2, 0)); break;
            case 'br': targetPos.add(new THREE.Vector3(size.x/2, -size.y/2, 0)); break;
        }

        targetMesh.position.copy(targetPos);
        userMovedTarget = true;
        updateAll();
    };

    window.loadImage = function() {
        const file = document.getElementById('image-upload').files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = e => {
            new THREE.TextureLoader().load(e.target.result, tex => {
                projectionTexture = tex;
                tex.minFilter = THREE.LinearFilter;
                projectedObjects.forEach(obj => {
                    if (obj.material?.uniforms) {
                        obj.material.uniforms.projTexture.value = projectionTexture;
                        obj.material.uniforms.hasTexture.value = true;
                        obj.material.needsUpdate = true;
                    }
                });
                updateProjectionMatrix();
                document.getElementById('image-status').innerHTML = '<div class="status success">‚úì Charg√©</div>';
            });
        };
        reader.readAsDataURL(file);
    };

    window.removeImage = function() {
        projectionTexture = null;
        projectedObjects.forEach(obj => {
            if (obj.material?.uniforms) {
                obj.material.uniforms.projTexture.value = null;
                obj.material.uniforms.hasTexture.value = false;
                obj.material.needsUpdate = true;
            }
        });
        updateProjectionMatrix();
        document.getElementById('image-upload').value = '';
        document.getElementById('image-status').innerHTML = '<div class="status info">Enlev√©</div>';
    };

    function onTransformChange() {
        if (transformControls.object === targetMesh) userMovedTarget = true;
        updateProjectionMatrix();
        updateMeasurements();
    }

    function onClick(e) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObjects(selectableObjects, false);
        selectObject(hits.length > 0 ? hits[0].object : null);
    }

    function selectObject(obj) {
        selectedObject = obj;
        const transformPanel = document.getElementById('transform-params');
        const gizmoControls = document.getElementById('gizmo-controls');

        if (obj) {
            if (obj.userData.isProjector) {
                transformControls.attach(projectorGroup);
            } else {
                transformControls.attach(obj);
            }
            document.getElementById('selected-name').textContent = obj.userData.name;
            transformPanel.classList.add('visible');
            gizmoControls.classList.add('visible');
            updateTransformInputs();
        } else {
            transformControls.detach();
            document.getElementById('selected-name').textContent = 'Aucun';
            transformPanel.classList.remove('visible');
            gizmoControls.classList.remove('visible');
        }
    }

    function onKeyDown(e) {
        if (!selectedObject) return;

        switch(e.key.toLowerCase()) {
            case 'g':
                setGizmoMode('translate');
                break;
            case 'r':
                setGizmoMode('rotate');
                break;
            case 's':
                if (!e.ctrlKey && !e.metaKey) { // Avoid conflict with browser save
                    setGizmoMode('scale');
                    e.preventDefault();
                }
                break;
            case 'delete':
            case 'backspace':
                if (selectedObject && !selectedObject.userData.isProjector && !selectedObject.userData.isTarget) {
                    scene.remove(selectedObject);
                    projectedObjects.splice(projectedObjects.indexOf(selectedObject), 1);
                    selectableObjects.splice(selectableObjects.indexOf(selectedObject), 1);
                    selectedObject.geometry?.dispose();
                    selectedObject.material?.dispose();
                    selectObject(null);
                }
                e.preventDefault();
                break;
            case 'escape':
                selectObject(null);
                break;
        }
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();

        if (projectorGroup && targetMesh) {
            if (targetLocked) {
                if (userMovedTarget) {
                    const targetPos = targetMesh.position.clone();
                    const projPos = projectorGroup.position.clone();
                    const dir = new THREE.Vector3().subVectors(targetPos, projPos);
                    if (dir.length() > 0.01) {
                        const m = new THREE.Matrix4().lookAt(projPos, targetMesh.position, new THREE.Vector3(0,1,0));
                        projectorGroup.quaternion.setFromRotationMatrix(m);
                    }
                }
            } else {
                if (transformControls.object === projectorGroup && transformControls.dragging) {
                    const dir = new THREE.Vector3(0,0,-1).applyQuaternion(projectorGroup.quaternion);
                    targetMesh.position.copy(projectorGroup.position.clone().add(dir.multiplyScalar(projDistance)));
                    userMovedTarget = true;
                }
            }

            if (transformControls.dragging) projDistance = targetMesh.position.distanceTo(projectorGroup.position);

            updateProjectionMatrix();
            updateMeasurements();
        }

        renderer.render(scene, camera);
    }

    init();

    </script>
</body>
</html>
